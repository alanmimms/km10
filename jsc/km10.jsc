'use strict';

const fs = require('fs');
const util = require('util');
const assert = require('assert');

// Names of the flags and their bit numbers in a program flags word:
const flags = {
  OV: 0,
  PCP: 0,
  CY1: 1,
  CY0: 2,
  FOV: 3,
  FPD: 4,
  USR: 5,
  USRIO: 6,
  PCU: 6,
  PUB: 7,
  AFI: 8,
  TR2: 9,
  TR1: 10,
  FUF: 11,
  NDV: 12,
};


const macros = `
${Object.keys(flags)
  .map(f => `#define flag${f} BIT(${flags[f]})`)
  .join('\n')}


static volatile int running;
static volatile int tracePC;
static volatile int traceAC;
static volatile int traceMem;

// XXX do we need to emulate all eight AC blocks?
static volatile W36 AC[16];

static volatile W36 pc;
static volatile W36 flags;
static volatile W36 *memP;

static int tops20Paging, pagingEnabled;


// Currently executing interrupt level.
static volatile unsigned intLevel;

// Mask of levels that have pending interrupts. Read by CONI PI bits
// 29-35, written by "hardware".
static volatile unsigned intLevelsPending;

// Mask of levels requested by software.
static volatile unsigned intLevelsRequested;

// Mask of levels where an interrupt is in progress. Read by CONI PI
// bits 21-27.
static unsigned intLevelsInProgress;

// Mask of enabled interrupt levels.
static unsigned intLevelsEnabled;

// Master interrupt system enable.
static int piEnabled;

// These are CONI PI / CONO PI word bits.
static const W36 DROP_PROGRAM_REQUESTS = BIT(22);
static const W36 CLEAR_PI = BIT(23);
static const W36 INITIATE_INTERRUPTS = BIT(24);
static const W36 TURN_ON_SELECTED_LEVELS = BIT(25);
static const W36 TURN_OFF_SELECTED_LEVELS = BIT(26);
static const W36 TURN_OFF_PI = BIT(27);
static const W36 TURN_ON_PI = BIT(28);
static const W36 PI_LEVEL_MASK = BIT(28) - 1; // Bits 28..35


// Physical memory. This is mmap()ed for each mode we run in and memP
// is updated to point to the right address space for the current mode.
static W36 memory[256*1024];


typedef signed long long sint64_t;

static inline W36 checkGetAC(int a) {
  char buf[64];
  if (traceAC) fprintf(stderr, "                get AC%o=%s\\n", a, oct36(buf, AC[a]));
  return AC[a];
}


static inline void checkPutAC(int a, W36 v) {
  char buf[64];
  if (traceAC) fprintf(stderr, "                put AC%o=%s\\n", a, oct36(buf, v));
  AC[a] = v;
}


// XXX For now
static inline W36 checkGetMem(W36 a) {
  W36 tmp;

  if (a < 020)
    tmp = AC[a];
  else
    tmp = memP[a];

  char aBuf[64], vBuf[64];
  if (traceMem) fprintf(stderr, "                get %s=%s\\n", octVMA(aBuf, a), oct36(vBuf, tmp));

  return tmp;
}


// XXX For now
static inline void checkPutMem(W36 a, W36 v) {

  if (a < 020) {
    AC[a] = v;
  } else {
    memP[a] = v;
  }

  char aBuf[64], vBuf[64];
  if (traceMem) fprintf(stderr, "                put %s=%s\\n", octVMA(aBuf, a), oct36(vBuf, v));
}

// XXX This needs nonzero section code added.
static inline W36 pcAndFlags() {
  return flags | pc;
}


static inline int section0(W36 a) {
  return !!(a & LHMASK);
}


static void NYI(const char *mneP) {
  char buf[64];
  fprintf(stderr, ">>>>>>>>>>>>>>>>Not yet implemented: %s at %s\\n", mneP, octVMA(buf, pc));
}


// Take the EA of an instruction and compute the shift count the
// whacky way PDP10s do it.
static int getShift(W36 ea) {
  int shift = ea & 0377;
  return (ea & BIT18) ? -shift : shift;
}
`;


function oct6(v) {
  return v.toString(8).padStart(2, '0');
}


// Optionally `ac` param can be left off and 'ac' will be used. This
// makes call sites simpler.
function getAC(ac) {
  if (ac == undefined) ac = 'ac';
  return `checkGetAC(${ac})`;
}


// Optionally `ac` param can be left off and 'ac' will be used. This
// makes call sites simpler.
function getACRH(ac) {
  if (ac == undefined) ac = 'ac';
  return `checkGetAC(${ac}) & HMASK`;
}


// Optionally `ac` param can be left off and 'ac' will be used. This
// makes call sites simpler.
function getACLH(ac) {
  if (ac == undefined) ac = 'ac';
  return `checkGetAC((${ac}) >> 18) & HMASK`;
}


// Optionally `ac` param can be left off and 'ac' will be used. This
// makes call sites simpler.
function putAC(ac, value) {

  if (value == undefined) {
    value = ac;
    ac = 'ac';
  }

  return `checkPutAC(${ac}, ${value})`;
}


// Optionally `ac` param can be left off and 'ac' will be used. This
// makes call sites simpler.
function putACRH(ac, value) {

  if (value == undefined) {
    value = ac;
    ac = 'ac';
  }

  return `checkPutAC(${ac}, CONS(LH(${ac}), ${value}))`;
}


// Optionally `ac` param can be left off and 'ac' will be used. This
// makes call sites simpler.
function putACLH(ac, value) {

  if (value == undefined) {
    value = ac;
    ac = 'ac';
  }

  return `checkPutAC(${ac}, CONS(${value}, ${ac}))`;
}


// Optionally `a` param can be left off and 'ea' will be used. This
// makes call sites simpler.
function getMem(a) {
  if (a == undefined) a = 'ea';
  return `checkGetMem(${a})`;
}


// Optionally `a` param can be left off and 'ea' will be used. This
// makes call sites simpler.
function putMem(a, value) {

  if (value == undefined) {
    value = a;
    a = 'ea';
  }

  return `checkPutMem(${a}, ${value})`;
}


function setFlags(flagsList) {
  return `flags |= ${flagsList
.split(/\s+/)
.map(flag => `flag${flag}`)
.join('|')}`;
}


// Handle MOVN and MOVM flag setting.
function setSignedMoveFlags() {
  return `\
	if (tmp == BIT0) {
	  ${setFlags(`TR1 OV CY1`)};
	}
	if (tmp == 0) {
	  ${setFlags(`CY0 CY1`)};
	}`;
}


// If cond is undefined never skip. If cond is 1 always skip.
// Else generate if (cond) for skip.
function doSKIP(cond) {
  const prefix = `if (ac != 0) ${putAC('ea')};`;

  if (cond == undefined) return prefix;

  if (cond === 1) {
    return `\
  ${prefix}
  ++nextPC;`;
  } else {
    return `\
  ${prefix}
  if (TOSIGNED(${getMem()}) ${cond}) ++nextPC;`;
  }
}


// Handle the Test, Modify, and Skip instructions by passing appropriate
// getMask, modifier, and skipper functions for each case.

// Always get the AC.
//
// Get mask LH, RH, @ea, or swapped(@ea)
//
// Do nothing, set masked bits in AC to zeros, complement masked bits in AC,
// or set masked bits in AC to ones.
//
// Don't skip, always skip, or skip if masked bits all zero or not all mask bits are zero.
function testInsn(getMask, modifier, skipper) {
  return `\
  W36 mask = ${getMask()};
  W36 testAC = ${getAC()};
  ${skipper()};
  ${modifier()};`;
}


function getMemSwapped() {
  return `SWAP(memP[ea])`;
}


function getERH() {
  return `RH(ea)`;
}


function getELH() {
  return `RH(ea) << 18`;
}


function getMemRH() {
  return `RH(memP[ea])`;
}


function getMemLH() {
  return `LH(memP[ea]) << 18`;
}


function getEARH() {
  return `RH(ea)`;
}


function getEALH() {
  return `LH(ea) << 18`;
}


function skipN() {
  return `if ((testAC & mask) != 0) ++nextPC`;
}


function skipE() {
  return `if ((testAC & mask) == 0) ++nextPC`;
}


function skipAlways() {
  return `++nextPC`;
}


function skipNever() {
  return `(void) 0`;
}


function modZeros() {
  return `${putAC('testAC & ~mask')}`
}


function modOnes(mask) {
  return `${putAC('testAC | mask')}`
}


function modComplement(mask) {
  return `${putAC('testAC ^ mask')}`
}


function modNone(mask) {
  return `(void) 0`;
}


// getSrc() always puts its source right justified in tmp.
// putDest() always puts tmp to one or the other half.
// modifier() does nothing, zero, set to all 1s or sign extend the right half of tmp.
// isSelf is true if result should also go to AC[ac] if ac !== 0.

// Take a half word data transmission mnemonic and return the code to do it.
//
// `mne` must be padded so modifier byte of mnemonic is blank if
// modifier should be Do Nothing and mode byte of mnemonic is blank
// if mode is Basic.
function halfInsn(mne) {
  assert(mne[0] === 'H');
  const [S,D,MOD,MODE] = mne.substr(1, 4);
  let srcCode, dstGet, getHalf, dstPut, modCode;

  switch (MODE) {
  case 'I':
    srcCode = `W36 src = CONS(0, ea)`;
    dstGet = `W36 dst = ${getAC()}`;
    dstPut = putAC('dst');
    break;

  case 'M':
    srcCode = `W36 src = ${getAC()}`;
    dstGet = `W36 dst = ${getMem()}`;
    dstPut = putMem('dst');
    break;

  case 'S':
    srcCode = `W36 src = ${getAC()}`;
    dstGet = `W36 dst = ${getMem()}`;
    dstPut = `${putMem('dst')}; if (ac != 0) ${putAC('dst')}`;
    break;

  default:
    srcCode = `W36 src = ${getAC()}`;
    dstGet = `W36 dst = ${getMem()}`;
    dstPut = putMem('dst');
    break;
  }

  // This seems like it works in zero and in nonzero section.
  if (D == 'R') {		// RH

    if (MOD == 'Z') {
      modCode = `dst = CONS(0, src)`;
    } else if (MOD == 'O') {
      modCode = `dst = CONS(ALL1s, src)`;
    } else if (MOD == 'E') {
      modCode = `dst = SEXTEND(src)`;
    } else {
      modCode = `dst = CONS(LH(dst), src)`;
    }
  } else {			// LH

    if (MOD == 'Z') {
      modCode = `dst = CONS(src, 0)`;
    } else if (MOD == 'O') {
      modCode = `dst = CONS(src, ALL1s)`;
    } else if (MOD == 'E') {
      modCode = `dst = SWAP(SEXTEND(LH(src)))`;
    } else {
      modCode = `dst = CONS(src), RH(dst))`;
    }
  }

  // Now fetch the proper half of the source.
  switch (mne[1]) {
  case 'R':
    getHalf = `src = RH(src);`;
    break;

  case 'L':
    getHalf = `src = LH(src);`;
    break;

  default:
    assert(false, `halfInsn with bad mnemonic '${mne}'.`);
    return `!!!! assertion failed !!!!`;
  }

  return `\
  ${srcCode};
  ${getHalf};
  ${dstGet};
  ${dstPut}`;
}


// Emit code for the AOS instruction suite. Pass C fragment (e.g., '> 0')
// for `testCondition` or undefined for never skip.
function addOneSkip(testCondition) {
  return `\
  W36 tmp = ${getMem()};

  // If value overflows, we have to set some flags.
  if (tmp == ALL1s) {
    flags |= flagTR1 | flagOV | flagCY1;
  } else if (tmp == (ALL1s >> 1)) {
    flags |= flagCY0 | flagCY1;
  } 

  tmp = TO36(tmp + 1);
  ${putMem('tmp')};
  if (ac != 0) ${putAC('tmp')};
  ${testCondition ? `if (TOSIGNED(tmp) ${testCondition}) ++nextPC;` : ``}
`;
}


// Emit code for the AOJ instruction suite.
function addOneJump(testCondition) {
  return `\
  W36 tmp = ${getAC()};

  // If value overflows, we have to set some flags.
  if (tmp == ALL1s) {
    flags |= flagTR1 | flagOV | flagCY1;
  } else if (tmp == (ALL1s >> 1)) {
    flags |= flagCY0 | flagCY1;
  } 

  tmp = TO36(tmp + 1);
  ${putAC('tmp')};
  ${testCondition ? `if (TOSIGNED(tmp) ${testCondition}) nextPC = ea;` : ``}
`;
}


// Emit code for the SOS instruction suite.
function subOneSkip(testCondition) {
  return `\
  W36 tmp = ${getMem()};

  // If value overflows, we have to set some flags.
  if (tmp == (ALL1s >> 1)) {
    flags |= flagTR1 | flagOV | flagCY0;
  } else if (tmp != 0) {
    flags |= flagCY0 | flagCY1;
  } 

  tmp = TO36(tmp - 1);
  ${putMem('tmp')};
  if (ac != 0) ${putAC('tmp')};
  ${testCondition ? `if (TOSIGNED(tmp) ${testCondition}) ++nextPC;` : ``}
`;
}


// Emit code for the SOJ instruction suite.
function subOneJump(testCondition) {
  return `\
  W36 tmp = ${getAC()};

  // If value overflows, we have to set some flags.
  if (tmp == (ALL1s >> 1)) {
    flags |= flagTR1 | flagOV | flagCY0;
  } else if (tmp != 0) {
    flags |= flagCY0 | flagCY1;
  } 

  tmp = TO36(tmp - 1);
  ${putAC('tmp')};
  ${testCondition ? `if (TOSIGNED(tmp) ${testCondition}) nextPC = ea;` : ``}
`;
}


function emit(s) {
  fs.writeFileSync(process.argv[2], s);
}



////////////////////////////////////////////////////////////////////////////////////////////////
const kl10Instructions = {
// Full Word Movement
'250': `// EXCH	(ac) <-> (e)
	W36 tmp = ${getAC()};
	${putAC(getMem())};
	${putMem('tmp')};
`,
'200': `// MOVE (e) -> (ac)
  W36 tmp = ${getMem()};
  ${putAC('tmp')};
`,
'201': `// MOVEI 0,,e -> (ac)
  ${putAC('RH(ea)')};
`,
'202': `// MOVEM (ac) -> (e)
  W36 tmp = ${getAC()};
  ${putMem('tmp')};
`,
'203': `// MOVES if ac !== 0: (e) -> (ac)
  W36 tmp = ${getMem()};

  if (ac != 0) ${putAC('tmp')};

  ${putMem('tmp')};
`,
'210': `// MOVN -(e) -> (ac)
  W36 tmp = -${getMem()};
  ${putAC('tmp')};
  ${setSignedMoveFlags()}
`,
'211': `// MOVNI -[0,,e] -> (ac)
  W36 tmp = -RH(${getMem()});
  ${putAC('tmp')};	
`,
'212': `// MOVNM -(e) -> (e)
  W36 tmp = -LH(${getAC()});
  ${putMem('tmp')};	
  ${setSignedMoveFlags()}
`,
'213': `// MOVNS -(e) -> (e)
  W36 tmp = -${getMem()};
  ${putMem('tmp')};
  if (ac != 0) ${putAC('tmp')};
  ${setSignedMoveFlags()}
`,
'415': `// SETMI/XMOVEI

  if (!section0(pc)) {

    if (eaIsLocal) {
      W36 tmp = BIT17 | RH(ea);
      ${putAC('tmp')};
    } else {
      W36 tmp = ea & 07777777777ull;
      ${putAC('tmp')};
    }
  } else {	// SETMI
    ${putAC('RH(ea)')};
  }
`,
'254': `// JRST
  switch(ac) {		// AC is the JRST function F
  case 000: // JRST
    nextPC = ea;
    break;

  case 001: // PORTAL
    NYI("PORTAL");
    break;

  case 002: // JRSTF
    NYI("JRSTF");
    break;

  case 004: // HALT
    running = 0;
    break;

  case 005: // XJRSTF
    NYI("XJRSTF");
    break;

  case 006: // XJEN
    NYI("XJEN");
    break;

  case 007: // XPCW
    NYI("XPCW");
    break;

  case 010: // RSTOR
    NYI("RSTOR");
    break;

  case 012: // JEN
    NYI("JEN");
    break;

  case 014: // SFM
    NYI("SFM");
    break;
  }
`,
'264': `// JSR
  W36 tmp = !section0(nextPC) ? (nextPC & 0007777777777ull) : (nextPC | flags);
  ${putMem('tmp')};
  nextPC = ea + 1;
  flags &= ~(flagFPD | flagAFI | flagTR2 | flagTR1);
  break;
`,
'265': `// JSP
  W36 tmp = !section0(nextPC) ? (nextPC & 0007777777777ull) : (nextPC | flags);
  ${putAC('tmp')};
  nextPC = ea;
  flags &= ~(flagFPD | flagAFI | flagTR2 | flagTR1);
  break;
`,
'330': `// SKIP if ac !== 0: (e) -> (ac)
    ${doSKIP()}
`,
'331': `// SKIPL
    ${doSKIP('< 0')}
`,
'332': `// SKIPE
    ${doSKIP('== 0')}
`,
'333': `// SKIPLE
    ${doSKIP('<= 0')}
`,
'334': `// SKIPA
    ${doSKIP(1)}
`,
'335': `// SKIPGE
    ${doSKIP('>= 0')}
`,
'336': `// SKIPN
    ${doSKIP('!= 0')}
`,
'337': `// SKIPG
    ${doSKIP('> 0')}
`,
'120': `// DMOVE D(e,,e+1) -> D(ac,,ac+1)
    NYI("DMOVE");
`,
'121': `// DMOVEN -D(e,,e+1) -> D(ac,,ac+1)
    NYI("DMOVEN");
`,
'124': `// DMOVEM D(ac,,ac+1) -> D(e,,e+1)
    NYI("DMOVEM");
`,
'125': `// DMOVNM -D(ac,,ac+1) -> D(e,,e+1)
    NYI("DMOVNM");
`,
'251': `// BLT
    NYI("BLT");
`,
'204': `// MOVS (e).s -> (ac)
    NYI("MOVS");
`,
'205': `// MOVSI e,,0 -> (ac)
    NYI("MOVSI");
`,
'206': `// MOVSM (ac).s -> (e)
    NYI("MOVSM");
`,
'207': `// MOVSS (e).s -> (e); if ac !== 0: (e) -> (ac)
    NYI("MOVSS");
`,
'214': `// MOVM |(e)| -> (ac)
    NYI("MOVM");
`,
'215': `// MOVMI 0,,e -> (ac)
    NYI("MOVMI");
`,
'216': `// MOVMM
/*	|(e)| -> (tmp)
		(tmp) -> (e)
		if (tmp) == 400000_000000: 1 -> tr1 ov cy1
		if (tmp) == 0: 1 -> cy0 cy1 */
    NYI("MOVMM");
`,
'217': `// MOVMS
/*	|(e)| -> (tmp)
		(tmp) -> (e)
      		if ac !== 0: (tmp) -> (ac)
		if (tmp) == 400000_000000: 1 -> tr1 ov cy1
		if (tmp) == 0: 1 -> cy0 cy1 */
    NYI("MOVMS");
`,
'052': `// PMOVE
    NYI("PMOVE");
`,
'053': `// PMOVEM
    NYI("PMOVEM");
`,
'270': `// ADD (ac) + (e) -> (ac)
    NYI("ADD");
`,
'271': `// ADDI (ac) + 0,,e -> (ac)
    NYI("ADDI");
`,
'272': `// ADDM (ac) + (e) -> (e)
    NYI("ADDM");
`,
'273': `// ADDB (ac) + (e) -> (ac) (e)
    NYI("ADDB");
`,
'274': `// SUB (ac) - (e) -> (ac)
    NYI("SUB");
`,
'275': `// SUBI (ac) - 0,,e -> (ac)
    NYI("SUBI");
`,
'276': `// SUBM (ac) - (e) -> (e)
    NYI("SUBM");
`,
'277': `// SUBB (ac) - (e) -> (ac) (e)
    NYI("SUBB");
`,
'220': `// IMUL (ac) * (e) -> (ac).discardHi
    NYI("IMUL");
`,
'221': `// IMULI (ac) * 0,,e -> (ac).discardHi
    NYI("IMULI");
`,
'222': `// IMULM (ac) * (e) -> (e).discardHi
    NYI("IMULM");
`,
'223': `// IMULB (ac) * (e) -> (ac).discardHi (e).discardHi
    NYI("IMULB");
`,
'224': `// MUL (ac) * (e) -> D(ac,,ac+1)
    NYI("MUL");
`,
'225': `// MULI (ac) * 0,,e -> D(ac,,ac+1)
    NYI("MULI");
`,
'226': `// MULM (ac) * (e) -> (e).discardLo
    NYI("MULM");
`,
'227': `// MULB (ac) * (e) -> (ac,,ac+1) (e).discardLo
    NYI("MULB");
`,
'230': `// IDIV (ac) / (e) -> (ac).quo (ac+1).rem
    NYI("IDIV");
`,
'231': `// IDIVI (ac) / 0,,e -> (ac).quo (ac+1).rem
    NYI("IDIVI");
`,
'232': `// IDIVM (ac) / (e) -> (e).quo
    NYI("IDIVM");
`,
'233': `// IDIVB (ac) / (e) -> (ac).quo (ac+1).rem (e).quo
    NYI("IDIVB");
`,
'234': `// DIV D(ac,,ac+1) / (e) -> (ac).quo (ac+1).rem
    NYI("DIV");
`,
'235': `// DIVI D(ac,,ac+1) / 0,,e -> (ac).quo (ac+1).rem
    NYI("DIVI");
`,
'236': `// DIVM D(ac,,ac+1) / (e) -> (e).quo
    NYI("DIVM");
`,
'237': `// DIVB D(ac,,ac+1) / (e) -> (ac).quo (ac+1).rem (e).quo
    NYI("DIVB");
`,
'114': `// DADD D(ac,,ac+1) d+ D(e,,e+1) -> D(ac,,ac+1)
    NYI("DADD");
`,
'115': `// DSUB D(ac,,ac+1) d- D(e,,e+1) -> D(ac,,ac+1)
    NYI("DSUB");
`,
'116': `// DMUL D(ac,,ac+1) d* D(e,,e+1) -> Q(ac,,ac+3)
    NYI("DMUL");
`,
'117': `// DDIV D(ac,,ac+1) d/ D(e,,e+1) -> Q(ac,,ac+3)
    NYI("DDIV");
`,
'140': `// FAD (ac) f+ (e) -> (ac)
    NYI("FAD");
`,
'141': `// FADL (ac) fl+ (e) -> D(ac,,ac+1)
    NYI("FADL");
`,
'142': `// FADM (ac) f+ (e) -> (e)
    NYI("FADM");
`,
'143': `// FADB (ac) f+ (e) -> (ac) (e)
    NYI("FADB");
`,
'144': `// FADR (ac) fr+ (e) -> (ac)
    NYI("FADR");
`,
'145': `// FADRI (ac) fr+ e,,0 -> (ac)
    NYI("FADRI");
`,
'146': `// FADRM (ac) fr+ (e) -> (e)
    NYI("FADRM");
`,
'147': `// FADRB (ac) fr+ (e) -> (ac) (e)
    NYI("FADRB");
`,
'150': `// FSB (ac) f- (e) -> (ac)
    NYI("FSB");
`,
'151': `// FSBL (ac) fl- (e) -> D(ac,,ac+1)
    NYI("FSBL");
`,
'152': `// FSBM (ac) f- (e) -> (e)
    NYI("FSBM");
`,
'153': `// FSBB (ac) f- (e) -> (ac) (e)
    NYI("FSBB");
`,
'154': `// FSBR (ac) fr- (e) -> (ac)
    NYI("FSBR");
`,
'155': `// FSBRI (ac) fr- e,,0 -> (ac)
    NYI("FSBRI");
`,
'156': `// FSBRM (ac) fr- (e) -> (e)
    NYI("FSBRM");
`,
'157': `// FSBRB (ac) fr- (e) -> (ac) (e)
    NYI("FSBRB");
`,
'160': `// FMP (ac) f* (e) -> (ac)
    NYI("FMP");
`,
'161': `// FMPL (ac) fl* (e) -> D(ac,,ac+1)
    NYI("FMPL");
`,
'162': `// FMPM (ac) f* (e) -> (e)
    NYI("FMPM");
`,
'163': `// FMPB (ac) f* (e) -> (ac) (e)
    NYI("FMPB");
`,
'164': `// FMPR (ac) fr* (e) -> (ac)
    NYI("FMPR");
`,
'165': `// FMPRI (ac) fr* e,,0 -> (ac)
    NYI("FMPRI");
`,
'166': `// FMPRM (ac) fr* (e) -> (e)
    NYI("FMPRM");
`,
'167': `// FMPRB (ac) fr* (e) -> (ac) (e)
    NYI("FMPRB");
`,
'170': `// FDV (ac) f/ (e) -> (ac)
    NYI("FDV");
`,
'171': `// FDVL (ac) fl/ (e) -> D(ac,,ac+1)
    NYI("FDVL");
`,
'172': `// FDVM (ac) f/ (e) -> (e)
    NYI("FDVM");
`,
'173': `// FDVB (ac) f/ (e) -> (ac) (e)
    NYI("FDVB");
`,
'174': `// FDVR (ac) fr/ (e) -> (ac)
    NYI("FDVR");
`,
'175': `// FDVRI (ac) fr/ e,,0 -> (ac)
    NYI("FDVRI");
`,
'176': `// FDVRM (ac) fr/ (e) -> (e)
    NYI("FDVRM");
`,
'177': `// FDVRB (ac) fr/ (e) -> (ac) (e)
    NYI("FDVRB");
`,
'110': `// DFAD D(ac,,ac+1) d+ D(e,,e+1) -> D(ac,,ac+1)
    NYI("DFAD");
`,
'111': `// DFSB D(ac,,ac+1) d- D(e,,e+1) -> D(ac,,ac+1)
    NYI("DFSB");
`,
'112': `// DFMP D(ac,,ac+1) d* D(e,,e+1) -> D(ac,,ac+1)
    NYI("DFMP");
`,
'113': `// DFDV D(ac,,ac+1) d/ D(e,,e+1) -> D(ac,,ac+1)
    NYI("DFDV");
`,
'132': `// FSC (ac) f<< e -> (ac)
    NYI("FSC");
`,
'031': `// GFSC D(ac,,ac+1) f<< e -> D(ac,,ac+1)
    NYI("GFSC");
`,
'127': `// FLTR (e).ifr -> (ac)
    NYI("FLTR");
`,
'030': `// GFLTR (e).ifrD -> D(ac,,ac+1)
    NYI("GFLTR");
`,
'027': `// DGFLTR (e,,e+1).DifrD -> D(ac,,ac+1)
    NYI("DGFLTR");
`,
'122': `// FIX (e).fix -> (ac)
    NYI("FIX");
`,
'126': `// FIXR (e).fixR -> (ac)
    NYI("FIXR");
`,
'024': `// GFIX (e,,e+1).Dfix -> (ac)
    NYI("GFIX");
`,
'026': `// GFIXR (e,,e+1).DfixR -> (ac)
    NYI("GFIXR");
`,
'023': `// GDFIX (e,,e+1).DfixD -> D(ac,,ac+1)
    NYI("GDFIX");
`,
'025': `// GDFIXR (e,,e+1).DfixRD -> D(ac,,ac+1)
    NYI("GDFIXR");
`,
'021': `// GSNGL (e,,e+1).sngl -> (ac)
    NYI("GSNGL");
`,
'022': `// GDBLE (e).dble -> D(ac,,ac+1)
    NYI("GDBLE");
`,
'130': `// UFA (ac) fu+ (e) -> (ac+1)
    NYI("UFA");
`,
'131': `// DFN {cpu.doDFN(ac, e)}
    NYI("DFN");
`,
'400': `// SETZ 0 -> (ac)
  ${putAC(0)};
`,
'401': `// SETZI 0 -> (ac)
  ${putAC(0)};
`,
'402': `// SETZM 0 -> (e)
  ${putMem(0)};
`,
'403': `// SETZB 0 -> (ac) (e)
  ${putAC(0)};
  ${putMem(0)};
`,
'474': `// SETO 777777777777 -> (ac)
  ${putAC('ALL1s')};
`,
'475': `// SETOI 777777777777 -> (ac)
  ${putAC('ALL1s')};
`,
'476': `// SETOM 777777777777 -> (e)
  ${putMem('ALL1s')};
`,
'477': `// SETOB 777777777777 -> (ac) (e)
  ${putAC('ALL1s')};
  ${putMem('ALL1s')};
`,
'424': `// SETA { }	// (ac) -> (ac)
`,
'425': `// SETAI { }	// (ac) -> (ac)
`,
'426': `// SETAM (ac) -> (e)
  W36 tmp = ${getAC()};
  ${putMem('tmp')};
`,
'427': `// SETAB (ac) -> (e)
  W36 tmp = ${getAC()};
  ${putMem('tmp')};
`,
'450': `// SETCA ~(ac) -> (ac)
  W36 tmp = ${getAC()} ^ ALL1s;
  ${putAC('tmp')};
`,
'451': `// SETCAI ~(ac) -> (ac)
  W36 tmp = ${getAC()} ^ ALL1s;
  ${putAC('tmp')};
`,
'452': `// SETCAM ~(ac) -> (e)
  W36 tmp = ${getAC()} ^ ALL1s;
  ${putMem('tmp')};
`,
'453': `// SETCAB ~(ac) -> (ac) (e)
  W36 tmp = ${getAC()} ^ ALL1s;
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'414': `// SETM (e) -> (ac)
  W36 tmp = ${getAC()};
  ${putMem('tmp')};
`,
'416': `// SETMM (e) -> (e)// No-op
  W36 tmp = ${getMem()};
  ${putMem('tmp')};
`,
'417': `// SETMB (e) -> (ac) (e)
  W36 tmp = ${getMem()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'460': `// SETCM ~(e) -> (ac)
  W36 tmp = ${getMem()} ^ ALL1s;
  ${putMem('tmp')};
`,
'461': `// SETCMI ~[0,,e] -> (ac)
  W36 tmp = RH(${getMem()}) ^ ALL1s;
  ${putMem('tmp')};
`,
'462': `// SETCMM ~(e) -> (e)
  W36 tmp = ${getMem()} ^ ALL1s;
  ${putMem('tmp')};
`,
'463': `// SETCMB ~(e) -> (ac) (e)
  W36 tmp = ${getMem()} ^ ALL1s;
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'404': `// AND (ac) & (e) -> (ac)
  W36 tmp = ${getMem()} & ${getAC()};
  ${putAC('tmp')};
`,
'405': `// ANDI (ac) & 0,,e -> (ac)
  W36 tmp = RH(ea) & ${getAC()};
  ${putAC('tmp')};
`,
'406': `// ANDM (ac) & (e) -> (e)
  W36 tmp = ${getMem()} & ${getAC()};
  ${putMem('tmp')};
`,
'407': `// ANDB (ac) & (e) -> (ac) (e)
  W36 tmp = ${getMem()} & ${getAC()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'410': `// ANDCA ~(ac) & (e) -> (ac)
  W36 tmp = ${getMem()} & (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'411': `// ANDCAI ~(ac) & 0,,e -> (ac)
  W36 tmp = RH(ea) & (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'412': `// ANDCAM ~(ac) & (e) -> (e)
  W36 tmp = ${getMem()} & (ALL1s ^ ${getAC()});
  ${putMem('tmp')};
`,
'413': `// ANDCAB ~(ac) & (e) -> (ac) (e)
  W36 tmp = ${getMem()} & (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'420': `// ANDCM (ac) & ~(e) -> (ac)
  W36 tmp = (ALL1s ^ ${getMem()}) & ${getAC()};
  ${putAC('tmp')};
`,
'421': `// ANDCMI (ac) & ~[0,,e] -> (ac)
  W36 tmp = (ALL1s ^ RH(ea)) & ${getAC()};
  ${putAC('tmp')};
`,
'422': `// ANDCMM (ac) & ~(e) -> (e)
  W36 tmp = (ALL1s ^ ${getMem()}) & ${getAC()};
  ${putMem('tmp')};
`,
'423': `// ANDCMB (ac) & ~(e) -> (ac) (e)
  W36 tmp = (ALL1s ^ ${getMem()}) & ${getAC()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'440': `// ANDCB ~(ac) & ~(e) -> (ac)
  W36 tmp = (ALL1s ^ ${getMem()}) & (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'441': `// ANDCBI ~(ac) & ~[0,,e] -> (ac)
  W36 tmp = (ALL1s ^ RH(ea)) & (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'442': `// ANDCBM ~(ac) & ~(e) -> (e)
  W36 tmp = (ALL1s ^ ${getMem()}) & (ALL1s ^ ${getAC()});
  ${putMem('tmp')};
`,
'443': `// ANDCBB ~(ac) & ~(e) -> (ac) (e)
  W36 tmp = (ALL1s ^ ${getMem()}) & (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'434': `// IOR (ac) | (e) -> (ac)
  W36 tmp = ${getMem()} | ${getAC()};
  ${putAC('tmp')};
`,
'435': `// IORI (ac) | 0,,e -> (ac)
  W36 tmp = RH(ea) | ${getAC()};
  ${putAC('tmp')};
`,
'436': `// IORM (ac) | (e) -> (e)
  W36 tmp = ${getMem()} | ${getAC()};
  ${putMem('tmp')};
`,
'437': `// IORB (ac) | (e) -> (ac) (e)
  W36 tmp = ${getMem()} | ${getAC()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'454': `// ORCA ~(ac) | (e) -> (ac)
  W36 tmp = (ALL1s ^ ${getMem()}) | (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'455': `// ORCAI ~(ac) | 0,,e -> (ac)
  W36 tmp = (ALL1s ^ RH(ea)) | (ALL1s ^ ${getAC()});
  ${putMem('tmp')};
`,
'456': `// ORCAM ~(ac) | (e) -> (e)
  W36 tmp = (ALL1s ^ ${getMem()}) | (ALL1s ^ ${getAC()});
  ${putMem('tmp')};
`,
'457': `// ORCAB ~(ac) | (e) -> (ac) (e)
  W36 tmp = (ALL1s ^ ${getMem()}) | (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'464': `// ORCM (ac) | ~(e) -> (ac)
  W36 tmp = (ALL1s ^ ${getMem()}) | ${getAC()};
  ${putAC('tmp')};
`,
'465': `// ORCMI (ac) | ~[0,,e] -> (ac)
  W36 tmp = (ALL1s ^ RH(ea)) | ${getAC()};
  ${putAC('tmp')};
`,
'466': `// ORCMM (ac) | ~(e) -> (e)
  W36 tmp = (ALL1s ^ ${getMem()}) | ${getAC()};
  ${putMem('tmp')};
`,
'467': `// ORCMB (ac) | ~(e) -> (ac) (e)
  W36 tmp = (ALL1s ^ ${getMem()}) | ${getAC()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'470': `// ORCB ~(ac) | ~(e) -> (ac)
  W36 tmp = (ALL1s ^ ${getMem()}) | (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'471': `// ORCBI ~(ac) | ~[0,,e] -> (ac)
  W36 tmp = (ALL1s ^ RH(ea)) | (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
`,
'472': `// ORCBM ~(ac) | ~(e) -> (e)
  W36 tmp = (ALL1s ^ ${getMem()}) | (ALL1s ^ ${getAC()});
  ${putMem('tmp')};
`,
'473': `// ORCBB ~(ac) | ~(e) -> (ac) (e)
  W36 tmp = (ALL1s ^ ${getMem()}) | (ALL1s ^ ${getAC()});
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'430': `// XOR (ac) ^ (e) -> (ac)
  W36 tmp = ${getMem()} ^ ${getAC()};
  ${putAC('tmp')};
`,
'431': `// XORI (ac) ^ 0,,e -> (ac)
  W36 tmp = RH(ea) ^ ${getAC()};
  ${putAC('tmp')};
`,
'432': `// XORM (ac) ^ (e) -> (e)
  W36 tmp = ${getMem()} ^ ${getAC()};
  ${putMem('tmp')};
`,
'433': `// XORB (ac) ^ (e) -> (ac) (e)
  W36 tmp = ${getMem()} ^ ${getAC()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'444': `// EQV (ac) >< (e) -> (ac)
  W36 tmp = ALL1s ^ ${getMem()} ^ ${getAC()};
  ${putAC('tmp')};
`,
'445': `// EQVI (ac) >< 0,,e -> (ac)
  W36 tmp = ALL1s ^ RH(ea) ^ ${getAC()};
  ${putAC('tmp')};
`,
'446': `// EQVM (ac) >< (e) -> (e)
  W36 tmp = ALL1s ^ ${getMem()} ^ ${getAC()};
  ${putMem('tmp')};
`,
'447': `// EQVB (ac) >< (e) -> (ac) (e)
  W36 tmp = ALL1s ^ ${getMem()} ^ ${getAC()};
  ${putAC('tmp')};
  ${putMem('tmp')};
`,
'240': `// ASH (ac) <<a e -> (ac)
  int shift = getShift(ea) % 36;
  W36 tmp = ${getAC()};

  if (shift >= 0) {		// Left shift
    W36 original = tmp;

    tmp <<= shift;

    // XXX needs to set flags!

    if (original & BIT(0)) {	// Negative number
    } else {
    }
  } else {			// Right shift
    // Use native arithmetic shift but must make a signed value
    sint64_t signedTmp = (tmp & BIT(0)) ? (sint64_t) (~ALL1s | tmp) : (sint64_t) tmp;
    tmp = (W36) (signedTmp >> shift);
  }

  ${putAC('tmp')};
`,
'241': `// ROT (ac) <<r e -> (ac)
  int shift = getShift(ea) % 36;
  W36 tmp = ${getAC()};

  if (shift > 0) {
    tmp = (tmp << shift) | (tmp >> (36 - shift));
  } else if (shift < 0) {
    shift = -shift;
    tmp = (tmp >> shift) | (tmp << (36 - shift));
  }

  tmp &= ALL1s;
  ${putAC('tmp')};
`,
'242': `// LSH (ac) <<u e -> (ac)
  int shift = getShift(ea) % 36;
  W36 tmp = ${getAC()};

  if (shift > 0)
    tmp >>= shift;
  else
    tmp <<= -shift;

  ${putAC('tmp')};
`,
'244': `// ASHC D(ac,,ac+1) <<a e -> D(ac,,ac+1)
  W36 hi = ${getAC('ac')};
  W36 lo = ${getAC('ac+1')};
  int shift = getShift(ea) % 70;
  W36 signBit = hi & BIT(0);

  if (shift != 0) {

    if (shift > 0) {		// Left shift

      if (shift <= 35) {	// Shift within a word
	hi = (hi << shift) | (lo >> (35 - shift));
	lo <<= shift;
      } else {			// Big shift longer than a word
        hi = lo << (70 - shift);
        lo = 0;
      }
    } else if (shift < 0) {	// Right shift
      shift = -shift;

      if (shift <= 35) {	// Shift within a word
        lo = (hi << (35 - shift)) | (lo >> shift);
        hi >>= shift;
      } else {			// Big shift longer than a word
        lo = hi >> (70 - shift);
        hi = 0;
      }
    }

    // XXX needs to set flags!

    // Clean any extra bits left outside of 36 bit word. Any nonzero
    // shift count copies sign bit from original.
    hi = (hi & ALL1s & ~signBit) | signBit;
    lo = (lo & ALL1s & ~signBit) | signBit;
  }

  ${putAC('ac', 'hi')};
  ${putAC('ac+1', 'lo')};
`,
'245': `// ROTC D(ac,,ac+1) <<r e -> D(ac,,ac+1)
  W36 hi = ${getAC('ac')};
  W36 lo = ${getAC('ac+1')};
  int shift = getShift(ea) % 72;

  // XXX these are just shifts right now not rots.

  if (shift != 0) {

    if (shift > 0) {		// Left shift

      if (shift < 36) {		// Shift within a word
	hi = (hi << shift) | (lo >> (35 - shift));
	lo <<= shift;
      } else {			// Big shift longer than a word
        hi = lo << (72 - shift);
        lo = 0;
      }
    } else if (shift < 0) {	// Right shift
      shift = -shift;

      if (shift < 36) {		// Shift within a word
        lo = (hi << (36 - shift)) | (lo >> shift);
        hi >>= shift;
      } else {			// Big shift longer than a word
        lo = hi >> (72 - shift);
        hi = 0;
      }
    }

    // Clean any extra bits left outside of 36 bit word.
    hi &= ALL1s;
    lo &= ALL1s;
  }

  ${putAC('ac', 'hi')};
  ${putAC('ac+1', 'lo')};
`,
'246': `// LSHC D(ac,,ac+1) <<u e -> D(ac,,ac+1)
  W36 hi = ${getAC('ac')};
  W36 lo = ${getAC('ac+1')};
  int shift = getShift(ea) % 72;

  if (shift != 0) {

    if (shift > 0) {		// Left shift

      if (shift < 36) {		// Shift within a word
	hi = (hi << shift) | (lo >> (35 - shift));
	lo <<= shift;
      } else {			// Big shift longer than a word
        hi = lo << (72 - shift);
        lo = 0;
      }
    } else if (shift < 0) {	// Right shift
      shift = -shift;

      if (shift < 36) {		// Shift within a word
        lo = (hi << (36 - shift)) | (lo >> shift);
        hi >>= shift;
      } else {			// Big shift longer than a word
        lo = hi >> (72 - shift);
        hi = 0;
      }
    }

    // Clean any extra bits left outside of 36 bit word.
    hi &= ALL1s;
    lo &= ALL1s;
  }

  ${putAC('ac', 'hi')};
  ${putAC('ac+1', 'lo')};
`,
'252': `// AOBJP
/*	(ac).l + 1 -> (ac).l
		(ac).r + 1 -> (ac).r
      		if (ac) >= 0: e -> (pc) */
    NYI("AOBJP");
`,
'253': `// AOBJN
/*	(ac).l + 1 -> (ac).l
		(ac).r + 1 -> (ac).r
      		if (ac) < 0: e -> (pc) */
    NYI("AOBJN");
`,
'300': `// CAI { }
    NYI("CAI");
`,
'301': `// CAIL if (ac) < e: skip
    NYI("CAIL");
`,
'302': `// CAIE if (ac) === e: skip
    NYI("CAIE");
`,
'303': `// CAILE if (ac) <= e: skip
    NYI("CAILE");
`,
'304': `// CAIA skip
    NYI("CAIA");
`,
'305': `// CAIGE if (ac) >= e: skip
    NYI("CAIGE");
`,
'306': `// CAIN if (ac) !== e: skip
    NYI("CAIN");
`,
'307': `// CAIG if (ac) > e: skip
    NYI("CAIG");
`,
'310': `// CAM { }
    NYI("CAM");
`,
'311': `// CAML if (ac) < (e): skip
    NYI("CAML");
`,
'312': `// CAME if (ac) === (e): skip
    NYI("CAME");
`,
'313': `// CAMLE if (ac) <= (e): skip
    NYI("CAMLE");
`,
'314': `// CAMA skip
    NYI("CAMA");
`,
'315': `// CAMGE if (ac) >= (e): skip
    NYI("CAMGE");
`,
'316': `// CAMN if (ac) !== (e): skip
    NYI("CAMN");
`,
'317': `// CAMG if (ac) > (e): skip
    NYI("CAMG");
`,
'320': `// JUMP { }
    NYI("JUMP");
`,
'321': `// JUMPL if (ac) < 0: e -> (pc)
    NYI("JUMPL");
`,
'322': `// JUMPE if (ac) === 0: e -> (pc)
    NYI("JUMPE");
`,
'323': `// JUMPLE if (ac) <= 0: e -> (pc)
    NYI("JUMPLE");
`,
'324': `// JUMPA e -> (pc)
    NYI("JUMPA");
`,
'325': `// JUMPGE if (ac) >= 0: e -> (pc)
    NYI("JUMPGE");
`,
'326': `// JUMPN if (ac) !== 0: e -> (pc)
    NYI("JUMPN");
`,
'327': `// JUMPG if (ac) > 0: e -> (pc)
    NYI("JUMPG");
`,
'340': /* AOJ */ addOneJump(),
'341': /* AOJL */ addOneJump('< 0'),
'342': /* AOJE */ addOneJump('== 0'),
'343': /* AOJLE */ addOneJump('<= 0'),
'344': /* AOJA */ addOneJump('|| 1'),
'345': /* AOJGE */ addOneJump('>= 0'),
'346': /* AOJN */ addOneJump('!= 0'),
'347': /* AOJG */ addOneJump('> 0'),
'360': /* SOJ */ subOneJump(),
'361': /* SOJL */ subOneJump('< 0'),
'362': /* SOJE */ subOneJump('== 0'),
'363': /* SOJLE */ subOneJump('<= 0'),
'364': /* SOJA */ subOneJump('|| 1'),
'365': /* SOJGE */ subOneJump('>= 0'),
'366': /* SOJN */ subOneJump('!= 0'),
'367': /* SOJG */ subOneJump('> 0'),
'350': /* AOS */ addOneSkip(),
'351': /* AOSL */ addOneSkip('< 0'),
'352': /* AOSE */ addOneSkip('== 0'),
'353': /* AOSLE */ addOneSkip('<= 0'),
'354': /* AOSA */ addOneSkip('|| 1'),
'355': /* AOSGE */ addOneSkip('>= 0'),
'356': /* AOSN */ addOneSkip('!= 0'),
'357': /* AOSG */ addOneSkip('> 0'),
'370': /* SOS */ subOneSkip(),
'371': /* SOSL */ subOneSkip('< 0'),
'372': /* SOSE */ subOneSkip('== 0'),
'373': /* SOSLE */ subOneSkip('<= 0'),
'374': /* SOSA */ subOneSkip('|| 1'),
'375': /* SOSGE */ subOneSkip('>= 0'),
'376': /* SOSN */ subOneSkip('!= 0'),
'377': /* SOSG */ subOneSkip('> 0'),
'600': `// TRN
  (void) 0;
`,
'601': `// TLN
  (void) 0;
`,
'602': `// TRNE
  ${testInsn(getERH, modNone, skipE)}
`,
'603': `// TLNE
  ${testInsn(getELH, modNone, skipE)}
`,
'604': `// TRNA
  ++nextPC;
`,
'605': `// TLNA
  ++nextPC;
`,
'606': `// TRNN
  ${testInsn(getERH, modNone, skipN)}
`,
'607': `// TLNN
  ${testInsn(getELH, modNone, skipN)}
`,
'620': `// TRZ
  ${testInsn(getERH, modZeros, skipNever)}
`,
'621': `// TLZ
  ${testInsn(getELH, modZeros, skipNever)}
`,
'622': `// TRZE
  ${testInsn(getERH, modZeros, skipE)};
`,
'623': `// TLZE
  ${testInsn(getELH, modZeros, skipE)};
`,
'624': `// TRZA
  ${testInsn(getERH, modZeros, skipAlways)};
`,
'625': `// TLZA
  ${testInsn(getELH, modZeros, skipAlways)};
`,
'626': `// TRZN
  ${testInsn(getERH, modZeros, skipN)};
`,
'627': `// TLZN
  ${testInsn(getELH, modZeros, skipN)};
`,
'640': `// TRC (ac).r ^ e.r -> (ac).r
  ${testInsn(getERH, modComplement, skipN)};
`,
'641': `// TLC (ac).l ^ e.r -> (ac).l
  ${testInsn(getELH, modComplement, skipN)};
`,
'642': `// TRCE
  ${testInsn(getERH, modComplement, skipE)};
`,
'643': `// TLCE
  ${testInsn(getELH, modComplement, skipE)};
`,
'644': `// TRCA skip; (ac).r ^ e.r -> (ac).r
  ${testInsn(getERH, modComplement, skipAlways)};
`,
'645': `// TLCA skip; (ac).l ^ e.r -> (ac).l
  ${testInsn(getELH, modComplement, skipAlways)};
`,
'646': `// TRCN
  ${testInsn(getERH, modComplement, skipN)};
`,
'647': `// TLCN
  ${testInsn(getELH, modComplement, skipN)};
`,
'660': `// TRO (ac).r | e -> (ac).r
  ${testInsn(getERH, modOnes, skipN)};
`,
'661': `// TLO (ac).l | e -> (ac).l
  ${testInsn(getELH, modOnes, skipN)};
`,
'662': `// TROE
  ${testInsn(getERH, modOnes, skipE)};
`,
'663': `// TLOE
  ${testInsn(getELH, modOnes, skipE)};
`,
'664': `// TROA
  ${testInsn(getERH, modOnes, skipAlways)};
`,
'665': `// TLOA
  ${testInsn(getELH, modOnes, skipAlways)};
`,
'666': `// TRON
  ${testInsn(getERH, modOnes, skipN)};
`,
'667': `// TLON
  ${testInsn(getELH, modOnes, skipN)};
`,
'610': `// TDN
    (void) 0;
`,
'611': `// TSN
    (void) 0;
`,
'612': `// TDNE if (ac) & (e) === 0: skip
  ${testInsn(getMem, modNone, skipE)};
`,
'613': `// TSNE if (ac) & (e).s === 0: skip
  ${testInsn(getMemSwapped, modNone, skipE)};
`,
'614': `// TDNA
    ++nextPC;
`,
'615': `// TSNA
    ++nextPC;
`,
'616': `// TDNN if (ac) & (e) !== 0: skip
  ${testInsn(getMem, modNone, skipN)};
`,
'617': `// TSNN if (ac) & (e).s !== 0: skip
  ${testInsn(getMemSwapped, modNone, skipN)};
`,
'630': `// TDZ (ac) & ~(e) -> (ac)
  ${testInsn(getMem, modZeros, skipNever)};
`,
'631': `// TSZ
  ${testInsn(getMemSwapped, modZeros, skipNever)};
`,
'632': `// TDZE
  ${testInsn(getMem, modZeros, skipE)};
`,
'633': `// TSZE
  ${testInsn(getMemSwapped, modZeros, skipE)};
`,
'634': `// TDZA
  ${testInsn(getMem, modZeros, skipAlways)};
`,
'635': `// TSZA
  ${testInsn(getMemSwapped, modZeros, skipAlways)};
`,
'636': `// TDZN
  ${testInsn(getMem, modZeros, skipN)};
`,
'637': `// TSZN
  ${testInsn(getMemSwapped, modZeros, skipN)};
`,
'650': `// TDC
  ${testInsn(getMem, modComplement, skipNever)};
`,
'651': `// TSC
  ${testInsn(getMemSwapped, modComplement, skipNever)};
`,
'652': `// TDCE
  ${testInsn(getMem, modComplement, skipE)};
`,
'653': `// TSCE
  ${testInsn(getMemSwapped, modComplement, skipE)};
`,
'654': `// TDCA
  ${testInsn(getMem, modComplement, skipAlways)};
`,
'655': `// TSCA
  ${testInsn(getMemSwapped, modComplement, skipAlways)};
`,
'656': `// TDCN
  ${testInsn(getMem, modComplement, skipN)};
`,
'657': `// TSCN
  ${testInsn(getMemSwapped, modComplement, skipAlways)};
`,
'670': `// TDO
  ${testInsn(getMem, modOnes, skipNever)};
`,
'671': `// TSO
  ${testInsn(getMemSwapped, modOnes, skipNever)};
`,
'672': `// TDOE
  ${testInsn(getMem, modOnes, skipE)};
`,
'673': `// TSOE
  ${testInsn(getMemSwapped, modOnes, skipE)};
`,
'674': `// TDOA
  ${testInsn(getMem, modOnes, skipAlways)};
`,
'675': `// TSOA
  ${testInsn(getMemSwapped, modOnes, skipAlways)};
`,
'676': `// TDON
  ${testInsn(getMem, modOnes, skipN)};
`,
'677': `// TSON
  ${testInsn(getMemSwapped, modOnes, skipN)};
`,
'500': `// HLL
  ${halfInsn('HLL  ')};
`,
'501': `// HLLI/XHLLI
  if (LH(pc) == 0) {
    ${halfInsn('HLLI ')};
  } else {
    ${putAC('ea')};
  }
`,
'502': `// HLLM
  ${halfInsn('HLLM ')};
`,
'503': `// HLLS
  ${halfInsn('HLLS ')};
`,
'510': `// HLLZ
  ${halfInsn('HLLZ  ')};
`,
'511': `// HLLZI
  ${putAC(0)};
`,
'512': `// HLLZM
  ${halfInsn('HLLZM')};
`,
'513': `// HLLZS
  ${halfInsn('HLLZS')};
`,
'530': `// HLLE
  ${halfInsn('HLLE ')};
`,
'531': `// HLLEI
  ${halfInsn('HLLEI')};
`,
'532': `// HLLEM
  ${halfInsn('HLLEM')};
`,
'533': `// HLLES
  ${halfInsn('HLLES')};
`,
'520': `// HLLO
  ${halfInsn('HLLO ')};
`,
'521': `// HLLOI
  ${halfInsn('HLLOI')};
`,
'522': `// HLLOM
  ${halfInsn('HLLOM')};
`,
'523': `// HLLOS
  ${halfInsn('HLLOS')};
`,
'544': `// HLR
  ${halfInsn('HLR  ')};
`,
'545': `// HLRI
  ${halfInsn('HLRI ')};
`,
'546': `// HLRM
  ${halfInsn('HLRM ')};
`,
'547': `// HLRS
  ${halfInsn('HLRS ')};
`,
'554': `// HLRZ
  ${halfInsn('HLRZ ')};
`,
'555': `// HLRZI
  ${putAC(0)};
`,
'556': `// HLRZM
  ${halfInsn('HLRZM')};
`,
'557': `// HLRZS
  ${halfInsn('HLRZS')};
`,
'564': `// HLRO
  ${halfInsn('HLRO ')};
`,
'565': `// HLROI
  ${halfInsn('HLROI')};
`,
'566': `// HLROM
  ${halfInsn('HLROM')};
`,
'567': `// HLROS
  ${halfInsn('HLROS')};
`,
'574': `// HLRE
  ${halfInsn('HLRE ')};
`,
'575': `// HLREI
  ${halfInsn('HLREI')};
`,
'576': `// HLREM
  ${halfInsn('HLREM')};
`,
'577': `// HLRES
  ${halfInsn('HLRES')};
`,
'540': `// HRR
  ${halfInsn('HRR  ')};
`,
'541': `// HRRI
  ${halfInsn('HRRI ')};
`,
'542': `// HRRM
  ${halfInsn('HRRM ')};
`,
'543': `// HRRS
  ${halfInsn('HRRS ')};
`,
'550': `// HRRZ
  ${halfInsn('HRRZ ')};
`,
'551': `// HRRZI
  ${halfInsn('HRRZI')};
`,
'552': `// HRRZM
  ${halfInsn('HRRZM')};
`,
'553': `// HRRZS
  ${halfInsn('HRRZS')};
`,
'560': `// HRRO
  ${halfInsn('HRRZO')};
`,
'561': `// HRROI
  ${halfInsn('HRROI')};
`,
'562': `// HRROM
  ${halfInsn('HRROM')};
`,
'563': `// HRROS
  ${halfInsn('HRROS')};
`,
'570': `// HRRE
  ${halfInsn('HRRE ')};
`,
'571': `// HRREI
  ${halfInsn('HRREI')};
`,
'572': `// HRREM
  ${halfInsn('HRREM')};
`,
'573': `// HRRES
  ${halfInsn('HRRES')};
`,
'504': `// HRL
  ${halfInsn('HRL  ')};
`,
'505': `// HRLI
  ${halfInsn('HRLI ')};
`,
'506': `// HRLM
  ${halfInsn('HRLM ')};
`,
'507': `// HRLS
  ${halfInsn('HRLS ')};
`,
'514': `// HRLZ
  ${halfInsn('HRLZ ')};
`,
'515': `// HRLZI
  ${halfInsn('HRLZI')};
`,
'516': `// HRLZM
  ${halfInsn('HRLZM')};
`,
'517': `// HRLZS
  ${halfInsn('HRLZS')};
`,
'524': `// HRLO
  ${halfInsn('HRLO ')};
`,
'525': `// HRLOI
  ${halfInsn('HRLOI')};
`,
'526': `// HRLOM
  ${halfInsn('HRLOM')};
`,
'527': `// HRLOS
  ${halfInsn('HRLOS')};
`,
'534': `// HRLE
  ${halfInsn('HRLE ')};
`,
'535': `// HRLEI
  ${halfInsn('HRLEI')};
`,
'536': `// HRLEM
  ${halfInsn('HRLEM')};
`,
'537': `// HRLES
  ${halfInsn('HRLES')};
`,
'256': `// XCT/PXCT

  if (ac == 0) {
    iw = ${getMem()};
    goto XCT_ENTRYPOINT;
  } else {
    NYI("PXCT");
  }
`,
'243': `// JFFO
  W36 tmp = ${getAC()};

  if (tmp != 0) {
    unsigned count = 0;

    while ((tmp & BIT(0)) == 0) {
      ++count;
      tmp <<= 1;
    }

    tmp = (W36) count;
  }

  ${putAC('ac+1', 'tmp')};
`,
'255': `// JFCL
  unsigned jfclFlags = !!(flags & flagOV) << 3 |
		       !!(flags & flagCY0) << 2 |
		       !!(flags & flagCY1) << 1 |
		       !!(flags & flagFOV) << 0;

  jfclFlags &= ac;

  if (jfclFlags) {
    if (ac & 010) flags &= ~flagOV;
    if (ac & 004) flags &= ~flagCY0;
    if (ac & 002) flags &= flagCY1;
    if (ac & 001) flags &= flagFOV;
    nextPC = ea;
  }
`,
'266': `// JSA
  W36 tmp = CONS(ea, nextPC);
  ${putMem('ac')};
  ${putAC('tmp')};
  nextPC = ea + 1;
`,
'267': `// JRA
  W36 tmp = ${getMem('LH(ac)')};
  ${putAC('tmp')};
  nextPC = ea;
`,
'257': `// MAP
    NYI("MAP");
`,
  '261': `// PUSH
  W36 tmp = ${getAC()};
  W36 newItem = ${getMem()};

  if (section0(pc) || ISNEG(tmp) || (tmp & MASKFOR(6, 17)) == 0) {
    tmp = CONS(LH(tmp) + 1, RH(tmp) + 1);
    ${putMem('RH(tmp)', 'newItem')};
    ${putAC('tmp')};
    if (LH(tmp) == 0) flags |= flagTR2;
  } else if (!section0(pc) && (tmp & BIT(0)) && (tmp & MASKFOR(6,17)) != 0) {
    ++tmp;
    ${putMem('tmp', 'newItem')};
    ${putAC('tmp')};
  }
`,
'262': `// POP
    NYI("POP");
`,
'260': `// PUSHJ
    NYI("PUSHJ");
`,
'263': `// POPJ
    NYI("POPJ");
`,
'105': `// ADJSP
    NYI("ADJSP");
`,
'133': `// IBP/ADJBP
    NYI("IBP/ADJBP");
`,
'135': `// LDB
    NYI("LDB");
`,
'137': `// DPB
    NYI("DPB");
`,
'134': `// ILDB
    NYI("ILDB");
`,
'136': `// IDPB
    NYI("IDPB");
`,
'001': `// LUUO
    NYI("LUUO");
`,
'104': `// JSYS
    NYI("JSYS");
`,
'123': `// EXTEND
    NYI("EXTEND");
`,
'700': `// I/O instructions
  unsigned ioOp = ((op << 4) | ac) << 2;
  W36 tmp;

  switch (ioOp) {
  case 070000: // APRID
    tmp =
      BIT(0) |			// TOPS-20 paging
      BIT(1) |			// Microcode handles extended addresses
      BIT(2) |			// Microcode differs in some way from the standard version
      (0442 << 18) |		// Microcode version number
      // BIT(18) |		// Line frequency is 50Hz
      BIT(21) |			// Extended KL10
      // BIT(22) |		// System has master oscillator
      04321;			// Processor serial number
    ${putMem('tmp')};
    break;

  case 070004: // DATAI APR,
    NYI("DATAI APR,");
    break;

  case 070014: // DATAO APR,
    NYI("DATAO APR,");
    break;

  case 070044: // DATAI PI,
    NYI("DATAI PI,");
    break;

  case 070054: // DATAO PI,
    NYI("DATAO PI,");
    break;

  case 070060: // CONO PI,

    if (ea & CLEAR_PI) {
      piEnabled = 0;
      intLevelsInProgress = 0;
      intLevelsPending = 0;
      intLevel = 0;
    } else if (ea & TURN_ON_PI) {
      piEnabled = 1;
    } else if (ea & TURN_OFF_PI) {
      piEnabled = 0;
    } else if (ea & DROP_PROGRAM_REQUESTS) {
      intLevelsRequested &= ~(ea & PI_LEVEL_MASK);
    } else if (ea & INITIATE_INTERRUPTS) {
      intLevelsRequested |= ea & PI_LEVEL_MASK;
    } else if (ea & TURN_OFF_SELECTED_LEVELS) {
      intLevelsEnabled &= ~(ea & PI_LEVEL_MASK);
    } else if (ea & TURN_ON_SELECTED_LEVELS) {
      intLevelsEnabled |= ea & PI_LEVEL_MASK;
    } 

    break;

  case 070064: // CONI PI,
    tmp =
      intLevelsRequested << ShiftForBit(17) |
      intLevelsInProgress << ShiftForBit(27) |
      piEnabled << ShiftForBit(28) |
      intLevelsEnabled << ShiftForBit(35);
    ${putAC('tmp')};
    break;

  case 070104: // DATAI PAG,
    NYI("DATAI PAG,");
    break;

  case 070114: // DATAO PAG,
    NYI("DATAO PAG,");
    break;

  case 070120: // CONO PAG,
    NYI("CONO PAG,");
    break;

  case 070124: // CONI PAG,
    NYI("CONI PAG,");
    break;

  case 070020: // CONO APR,
    NYI("CONO APR,");
    break;

  case 070024: // CONI APR,
    NYI("CONI APR,");
    break;

  case 070220: // CONO TIM,
    NYI("CONO TIM,");
    break;

  case 070224: // CONI TIM,
    NYI("CONI TIM,");
    break;

  case 070264: // CONI MTR,
    NYI("CONI MTR,");
    break;

  case 070144: // SWPIA
    NYI("SWPIA");
    break;

  case 070164: // SWPIO
    NYI("SWPIO");
    break;

  case 070150: // SWPVA
    NYI("SWPVA");
    break;

  case 070170: // SWPVO
    NYI("SWPVO");
    break;

  case 070154: // SWPUA
    NYI("SWPUA");
    break;

  case 070174: // SWPUO
    NYI("SWPUO");
    break;

  case 070010: // WRFIL
    NYI("WRFIL");
    break;

  case 070110: // CLRPT
    NYI("CLRPT");
    break;

  case 070260: // WRTIME
    NYI("WRTIME");
    break;

  case 070204: // RDTIME
    NYI("RDTIME");
    break;

  case 070244: // RDEACT
    NYI("RDEACT");
    break;

  case 070240: // RDMACT
    NYI("RDMACT");
    break;

  case 070210: // WRPAE
    NYI("WRPAE");
    break;

  case 070200: // RDPERF
    NYI("RDPERF");
    break;

  case 070040: // RDERA
    NYI("RDERA");
    break;

  case 070050: // SBDIAG
    NYI("SBDIAG");
    break;

  default:
    char nyi[64];
    sprintf(nyi, "%05o", ioOp);
    NYI(nyi);
    break;
  }

  break;
`,
};


emit(`\
#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kl10.h"
#include "disasm.h"
#include "loada10.h"


${macros}

static void emulate() {
  W36 nextPC = 0;

  do {
    // XXX Put interrupt, trap, HALT, etc. handling here...
    W36 iw;

    // If a trap occurs, XCT instruction from appropriate location
    // instead of next PC, but leave PC alone while doing so. The
    // location of the trap instruction is the same for user or exec
    // mode if memP is in the right mode's address map. None of this
    // happens if paging is not enabled.
    if ((flags & (flagTR1 | flagTR2)) && pagingEnabled) {
      volatile ExecutiveProcessTable *eptP = (volatile ExecutiveProcessTable *) memP;
      iw = (flags & flagTR1) ? eptP->trap1Insn : eptP->stackOverflowInsn;
    } else {
      iw  = memP[pc];
    }

    // Initial assumption is that next instruction is what we will
    // fetch next time through this loop.
    nextPC = RH(pc + 1);

XCT_ENTRYPOINT:
    W36 ea;
    int eaIsLocal = 1;		// XXX THIS IS TEMPORARY UNTIL WE HAVE EXTENDED STUFF
    unsigned op;
    unsigned ac;
    unsigned i;
    unsigned x;
    unsigned y;

    // XXX support extended version of this...
    W36 eaw = iw;
    do {
      op = Extract(eaw, 0, 8);
      ac = Extract(eaw, 9, 12);
      i = Extract(eaw, 13, 13);
      x = Extract(eaw, 14, 17);
      y = Extract(eaw, 18, 35);

      ea = x ? RH(AC[x] + y) : y;

      if (i) eaw = memP[ea];
    } while (i);

    if (tracePC) {
      char pcBuf[64];
      char eaBuf[64];
      char daBuf[256];

      DisassembleToString(iw, daBuf);
      fprintf(stderr, "%s: [ea=%s] %s\\n", octVMA(pcBuf, pc), octVMA(eaBuf, ea), daBuf);
    }

    switch (op) {
    ${Object.keys(kl10Instructions)
	    .map(k => `
	case 0${k}: {
${kl10Instructions[k]}\
	  break; }`).join('\n')}
    }

    pc = nextPC;
  } while (running);
}


int main(int argc, char *argv[]) {
  W36 startAddr, lowestAddr, highestAddr;
  char *fileNameP;

  assert(sizeof(ExecutiveProcessTable)/sizeof(W36) == 01000);
  assert(sizeof(UserProcessTable)/sizeof(W36) == 01000);

  if (argc == 2) {
    fileNameP = argv[1];
  } else {
    fprintf(stderr, "Usage:\\n\\
    %s <filename to load>\\n", argv[0]);
    return -1;
  }

  int st = LoadA10(fileNameP, memory, &startAddr, &lowestAddr, &highestAddr);
  fprintf(stderr, "[Loaded %s  st=%d  start=" PRI06o64 "]\\n", fileNameP, st, startAddr);

  pc = startAddr;
  memP = memory;
  tracePC = 1;
  traceAC = 1;
  traceMem = 1;
  running = 1;


  // Initially paging is OFF
  tops20Paging = 0;
  pagingEnabled = 0;

  emulate();
}`);

// Local Variables:
// mode: javascript
// End:
