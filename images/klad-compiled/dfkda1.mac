SUBTTL	MEMORY RELIABILITY,  SETUP SECTION

BEGMEM:	SUBTST
	SKIPE	USER
	JRST	TSTEND
	SWITCH
	TRNE	INHMEM		;INHIBIT MEMORY TESTING ?
	JRST	TSTEND		;YES
	JSR	TSTIME
	SETOM	MAPNEW		;DO 4096K MAPPING
	MAPMEM
	MOVE	[JRST	PARERR]	;SETUP SPECIAL PARITY ROUTINE
	MOVEM	$PARER
	SETOM	ERRFST#		;SET FIRST ERROR FLAG
	SETOM	PARFST#		;SET PARITY FIRST ERROR FLAG
	SETZM	WASERR#		;CLEAR ERROR FLAG
	CONO	APR,LDPAER
	MEMZRO			;CLEAR MEMORY
	CLRBTH
MEMT0:	JRST	PHYTST		;PERFORM PHYSICAL ADDRESS 
MEMT1:	JRST	PATTST		;PERFORM DATA PATTERNS 
	SWITCH
	TLNE	0,TOTALS	;PRINT TOTALS ?
	GO	TOTAL		;YES, PRINT THEM
	JRST	TSTEND
;CREATE ADDRESS CONTROL POINTERS

COMPSZ:	HRRZ	MAXMEM#
	AOS			;COMPUTE NEG WORD COUNT
	SUBI	400000		;START VIRTUAL ADR IS 400000
	MOVNS
	HRLI	400000
	MOVSM	ADRLST		;SAVE FOR ADRCON POINTERS
	SETZM	ADRLST+1
	RTN

;SEGMENT SETUP FOR TESTING SEQUENCE

SEGSET:	SKIPE	TSTSEG#		;SINGLE SEGMENT SELECTED ?
	JRST	XPOPJ1		;YES, RETURN +2
	AOS	SEGNBR#		;INC SEGMENT NUMBER
	MOVE	SEGNBR
	CAILE	37		;COMPLETED ALL SEGMENTS ?
	JRST	XPOPJ1		;YES, RETURN +2
	MEMSEG
	FATAL
	JUMPE	.-6		;NO MEMORY IN THIS SEGMENT
	TLZ	400000		;DON'T CARE IF COMBINED MEMORY
	MOVEM	MAXMEM		;SAVE MAXIMUM VIRTUAL ADDRESS
	GO	COMPSZ		;CREATE ADDRESS POINTERS
	RTN

SEGINI:	SETOM	SEGNBR		;INITIALIZE FOR SEGMENT 0
	GO	SEGSET
	RTN
	RTN
SUBTTL	PHYSICAL ADDRESS TEST

;TEST EXECUTION CONTROL SEQUENCE
;1ST PASS, BOTTOM TO TOP, PHYSICAL ADDRESSES
;2ND PASS, TOP TO BOTTOM, COMPLEMENT PHYSICAL ADDRESSES
;RELIABILITY - REPEATS CHECK OF PHY ADDRESS 10 TIMES
;FAST CYCLE - CHECKS ONCE

PHYTST:	SUBTST
	MOVEI	0
	MOVEM	TSTN#
	JSR	TSTIME
	SETOM	ADRFST#		;SET FIRST PASS FLAG
	MOVEI	PATIX,10	;PATTERN IS PHYSICAL ADDRESS
PHYTS1:	MOVEM	PATIX,PATXSV
	MOVE	TAC,CONSW
	TLNN	TAC,RELIAB
	SKIPA	TAC1,[^D1]
	MOVEI	TAC1,^D10
	SETZM	ADRSCM
	SETOM	GCFST		;SET FIRST TIME FLAG
	GO	PHYFIL		;FILL MEMORY WITH PHYSICAL ADDRESSES
	SETOM	GCFST
	GO	PHYCHK		;CHECK
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5
	SOJG	TAC1,.-4
	SETCMM	ADRFST		;SET FOR SECOND PASS
	AOS	PATIX
	SKIPN	ADRFST		;DONE ?
	JRST	PHYTS1		;NO, DO SECOND PASS
	JRST	MEMT1
SUBTTL	DATA PATTERNS TEST

;TEST EXECUTION CONTROL SEQUENCE

PATTST:	SUBTST
	MOVEI	1
	MOVEM	TSTN
	GO	MABIT		;SELECT FAST RATE ADDRESSING BIT
	GO	PATSEL		;SELECT DATA PATTERN
	GO	SEGINI
PATTS2:	SETOM	GCFST#		;SET FIRST TIME FLAG
	SETZB	PATIX,PATXSV#	;CLEAR PATTERN INDEX
PATTS1:	SETZM	SEGIX		;CLEAR SEGMENT INDEX
	SETZM	ADRSCM#		;SET ADDRESS SCHEME TO SEQ
	SETZM	FLTFLG#		;CLEAR FLOATING DATA FLAG
	SETZM	PRANF#		;CLEAR PARITY RANDOM FLAG
	JSR	TSTIME
	XCT	@DPATN(PATIX)	;GENERATE DATA PATTERN
	GO	GETADR		;GET ADDRESS CONTROL WORD
	GO	FILMEM		;FILL MEMORY WITH PATTERN
	GO	GETADR
	GO	MRDRST		;READ/RESTORE MEMORY
	GO	GETADR
	GO	MCHECK		;TEST MEMORY
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5		;LOOP
	SETOM	ADRSCM		;SET ADDRESS SCHEME TO BLT
	GO	GETADR
	GO	BLTEX		;BLOCK TRANSFER EXERCISE
	GO	GETADR
	GO	MCHECK		;TEST MEMORY
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5		;LOOP
	SKIPGE	SVMA
	JRST	PATTS1		;IF SVMA NEG, DON'T DO FAST RATE
	SETOM	FRFST#		;SET FAST RATE FIRST TIME FLAG
	GO	FASTR		;SETUP FAST RATE ADDRESSING
	JRST	.+10		;FAST RATE COMPLETED
	GO	GETADR
	GO	FRRCW		;RD-COMP-WRT, FAST RATE
	GO	GETADR
	GO	MCHECK		;TEST MEMORY
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5		;LOOP
	JRST	.-10		;REPEAT FR FOR ALL ADR BITS
	JRST	PATTS1		;REPEAT SEQUENCE FOR NEXT PATTERN
;PHYSICAL ADDRESS FILL ALL OF MEMORY
;1ST - PHYSICAL ADDRESS IN PHYSICAL ADDRESS
;2ND - COMPLEMENT PHY ADR IN PHY ADR DOWNWARD
;BASIC PART OF ROUTINE OPERATES IN THE FAST AC'S

PHYFIL:	MOVE	TSTAC,[MOVEM	PATRN,(ADRCON)]	;SETUP AC'S
	MOVE	TSTAC+1,[ADDI	PATRN,1]
	MOVE	TSTAC+2,[ADDI	ADRCON,1]
	MOVE	TSTAC+3,[AOJN	CNT,TSTAC]
	MOVE	TSTAC+4,[JRST	PF1]
	SKIPN	ADRFST
	MOVE	TSTAC+2,[SUBI	ADRCON,1]

PF1:	MOVE	PSEG#		;GET PHY SEGMENT ADR
	SKIPN	ADRFST
	JRST	PF2		;2ND PASS
	SKIPE	GCFST
	MOVE	MEMLOW		;INITIAL START AT BREAK ABOVE JOBFF
	SKIPN	GCFST
	ADDI	1000		;STEP UP A PAGE
	CAML	[17,,-1]	;COMPLETED ALL 4096K ?
	RTN			;YES

PF3:	MOVEM	PSEG
	SETZM	GCFST
	MEMSEG			;SETUP PHY MEMORY SEGMENT
	FATAL
	JUMPE	0,PF1		;NO MEMORY
	MOVEI	400000		;1ST, START FROM 400000 VIRTUAL
	SKIPN	ADRFST
	TRO	777		;2ND, DOWN FROM 400777 VIRTUAL
	MOVE	ADRCON,0
	MAPADR			;GET ACTUAL PHY ADR
	FATAL
	SKIPN	ADRFST		;1ST, USE PHY ADR
	SETCA			;2ND, USE COMPLEMENT OF PHY ADR
	MOVE	PATRN,0
	HRROI	CNT,-1000
	JRST	TSTAC		;PERFORM ROUTINE IN AC'S

PF2:	SKIPE	GCFST		;2ND PASS, COMP PHY ADR DOWN
	MOVSI	20		;INITIAL START AT 4096K-1
	SUBI	1000
	CAML	MEMLOW		;COMPLETED ?
	JRST	PF3		;NO
	RTN

;PHYSICAL ADDRESS CHECK MEMORY
;FAST AC ROUTINE ONLY DIFFERENCE FROM "PHYFIL"
;ERROR DETECTED GOES TO MEMER0

PHYCHK:	MOVE	TSTAC,[CAME	PATRN,(ADRCON)]
	MOVE	TSTAC+1,[GO	MEMER0]
	MOVE	TSTAC+2,[ADDI	PATRN,1]
	MOVE	TSTAC+3,[ADDI	ADRCON,1]
	MOVE	TSTAC+4,[AOJN	CNT,TSTAC]
	MOVE	TSTAC+5,[JRST	PF1]
	SKIPN	ADRFST
	MOVE	TSTAC+3,[SUBI	ADRCON,1]
	JRST	PF1
;DATA GENERATION ROUTINES
;ENTERED VIA XCT, NORMAL RETURN + 1
;DATA PATTERN COMPLETED, RETURN AND REPEAT
;DATA WORD PUT IN PATRN

ONES:	GO	.+1		;ALL ONES
	SETOM	PATRN
	SKIPN	GCFST		;FIRST TIME
	JRST	GEXT1		;NO, EXIT
	SETZM	GCFST		;CLEAR FIRST TIME FLAG
	RTN

ZEROS:	GO	.+1		;ALL ZEROS
	SETZM	PATRN
	JRST	ONES+2

ALTB:	GO	.+1		;ALTERNATE BITS
	SKIPN	GCFST		;FIRST TIME
	JUMPL	PATRN,GEXT1	;NO, DATA COMPLETE
	SKIPE	GCFST
	MOVE	PATRN,[525252525252]
	JRST	JEX

PRAND:	GO	.+1		;PSEUDO RANDOM, PARITY BIT CHECK
	SETOM	PRANF
	SKIPE	GCFST
	JRST	.+3
	CAMN	PATRN,[123456,,701234]
	JRST	GEXT1		;DATA COMPLETED
	SKIPE	GCFST
	MOVE	PATRN,[123456,,701234]
	ROT	PATRN,3
	JRST	JEX+1

FLZRO:	GO	.+1		;FLOATING ZERO
	SETOM	FLTFLG
	SKIPN	GCFST
	JUMPG	PATRN,GEXT1	;DATA COMPLETED
	SKIPE	GCFST
	SKIPA	PATRN,[735673567356]
JEX:	ROT	PATRN,1		;ROTATE PATTERN WORD
	SETZM	GCFST
	RTN
FLONE:	GO	.+1		;FLOATING ONE
	SETOM	FLTFLG
	SKIPN	GCFST
	JUMPL	PATRN,GEXT1	;DATA COMPLETED
	SKIPE	GCFST
	SKIPA	PATRN,[042104210421]
	JRST	JEX
	JRST	JEX+1

SKPPAT:	GO	.+1		;THIS PATTERN SKIPPED

GEXT1:	SETOM	GCFST		;SET FIRST TIME FLAG
	SETZM	FLTFLG		;CLEAR FLOATING DATA FLAG
	SETZM	PRANF		;CLEAR PARITY RANDOM FLAG
	AOS	PATIX		;INCREMENT PATTERN INDEX
	MOVEM	PATIX,PATXSV
	SOS	(P)		;DECREMENT RETURN
	RTN			;RETURN TO XCT

DONE:	JRST	.+1
	GO	SEGSET
	JRST	PATTS2
	JRST	MEMT1+1

;DATA PATTERN SELECTION

PATSEL:	MOVEI	SKPPAT		;INITIALIZE PATTERNS TABLE
	MOVEM	DPATN
	MOVEM	DPATN+1
	MOVEM	DPATN+2
	MOVEM	DPATN+3
	MOVEM	DPATN+4
	MOVEM	DPATN+5
	HLRZ	AC12,RANDBS
	ANDI	AC12,7		;GET RANDOM SELECTION DIGIT
	GO	@SETPAT(AC12)	;SETUP PATTERNS TO DO
	RTN
;GET ADDRESS CONTROL WORD FROM LIST
;PUT IT IN ADRCON
;IF WORD = 0, RETURN +2
;OTHERWISE, INCREMENT INDEX, RETURN +1

GETADR:	MOVE	ADRCON,ADRLST(SEGIX)	;GET ADR CONTROL WORD
	JUMPE	ADRCON,.+3	;IS IT 0
	AOS	SEGIX		;NO, INC INDEX
	RTN			;EXIT
	SETZM	SEGIX		;YES, CLEAR INDEX
	AOS	(P)
	RTN			;RETURN +2

;FILL MEMORY SEGMENT
;DATA IN PATRN
;ADDRESS CONTROL WORD IN ARDCON
;WHEN COMPLETED RETURN -1
;ROUTINE OPERATES IN FAST AC'S

FILMEM:	SKIPE	FLTFLG			;FLOATING DATA WORD
	JRST	FMFLT			;YES
	SKIPE	PRANF			;PARITY RANDOM
	JRST	FMPRN			;YES
	MOVE	TSTAC,[MOVEM PATRN,(ADRCON)]	;SETUP AC'S
	MOVE	TSTAC+1,[AOBJN ADRCON,TSTAC]
	MOVE	TSTAC+2,[JRST XPOPM1]
	JRST	TSTAC		;PERFORM FILL MEMORY
FMFLT:	MOVE	AC11,PATRN			;DON'T CHANGE PATRN
	MOVE	TSTAC,[MOVEM	AC11,(ADRCON)]	;DATA ROTATES WD TO WD
	MOVE	TSTAC+1,[ROT	AC11,1]
	MOVE	TSTAC+2,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+3,[JRST	XPOPM1]
	JRST	TSTAC
FMPRN:	MOVE	AC12,PATRN
	MOVE	TSTAC,[MOVEM	AC12,(ADRCON)]
	MOVE	TSTAC+1,[MOVNS	AC12]
	MOVE	TSTAC+2,[ROT	AC12,1]
	MOVE	TSTAC+3,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+4,[JRST	XPOPM1]
	JRST	TSTAC
;READ/RESTORE MEMORY
;PERFORMS READ/RESTORE CYCLE 20 TIMES
;ADDRESS CONTROL WORD IN ADRCON, USED IN TAC
;ITERATION COUNT IN TAC1
;ROUTINE OPERATES IN THE FAST AC'S

MRDRST:	MOVE	CONSW
	TLNN	RELIAB		;RELIABILITY ?
	SKIPA	TAC1,[^D1]	;NO, PERFORM R/R ONCE
	MOVEI	TAC1,^D20	;YES, PERFORM R/R 20 TIMES
	MOVE	TAC,ADRCON
	MOVE	TSTAC,[MOVE	ADRCON,TAC]	;SETUP AC'S
	MOVE	TSTAC+1,[CAM	(ADRCON)]
	MOVE	TSTAC+2,[AOBJN	ADRCON,TSTAC+1]
	MOVE	TSTAC+3,[SOJN	TAC1,TSTAC]
	MOVE	TSTAC+4,[JRST RDRTN]
	JRST	TSTAC		;PERFORM READ/RESTORE
RDRTN:	JRST	XPOPM1		;RETURN -1

;BLOCK TRANSFER MEMORY EXERCISE
;PERFORM 1 OR 20 TIMES
;DOES BLT OF DATA FROM/TO SAME LOCATIONS
;ROUTINE OPERATES IN THE FAST AC'S

BLTEX:	MOVE	CONSW
	TLNN	RELIAB		;RELIABILITY ?
	SKIPA	TAC1,[^D1]	;NO, PERFORM BLT ONCE
	MOVEI	TAC1,^D20	;YES, PERFORM BLT 20 TIMES
	HRRZ	TAC,ADRCON
	HLRE	AC14,ADRCON
	MOVMS	AC14
	ADD	AC14,TAC	;SETUP AC14 = 0,LAST ADR
	HRLS	TAC		;SETUP TAC = FIRST ADR,FIRST ADR
	MOVE	TSTAC,[MOVE	AC13,TAC]
	MOVE	TSTAC+1,[BLT	AC13,-1(AC14)]
	MOVE	TSTAC+2,[SOJN	TAC1,TSTAC]
	MOVE	TSTAC+3,[JRST	BLTRTN]
	JRST	TSTAC		;PERFORM BLT ROUTINE
BLTRTN:	JRST	XPOPM1		;RETURN -1
;CHECK MEMORY SEGMENT
;ADDRESS CONTROL WORD IN ADRCON
;COMPARE DATA IN PATRN
;ERROR DETECTED, GOES TO MEMER0
;ROUTINE OPERATES IN THE FAST AC'S

MCHECK:	SKIPE	FLTFLG			;FLOATING DATA WORD
	JRST	CKFLT			;YES
	SKIPE	PRANF			;PARITY RANDOM
	JRST	CKPRN			;YES
	MOVE	TSTAC,[CAME PATRN,(ADRCON)]	;SETUP AC'S
	MOVE	TSTAC+1,[GO MEMER0]
	MOVE	TSTAC+2,[AOBJN ADRCON,TSTAC]
	MOVE	TSTAC+3,[JRST CKRTN]
	CONO	APR,LDPAER	;DISABLE PARITY INTERRUPTS
	JRST	TSTAC		;PERFORM ERROR CHECK
CKFLT:	MOVE	AC12,PATRN			;DON'T CHANGE PATRN
	MOVE	TSTAC,[CAME	AC12,(ADRCON)]	;DATA ROTATES WD TO WD
	MOVE	TSTAC+1,[GO	MEMER1]
	MOVE	TSTAC+2,[ROT	AC12,1]
	MOVE	TSTAC+3,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+4,[JRST	CKRTN]
	CONO	APR,LDPAER	;DISABLE PARITY INTERRUPTS
	JRST	TSTAC
CKRTN:	CLRBTH
	JRST	XPOPM1
CKPRN:	MOVE	AC13,PATRN	;DON'T CHANGE PATRN
	MOVE	TSTAC,[CAME	AC13,(ADRCON)]
	MOVE	TSTAC+1,[JRST	ERPRN]
	MOVE	TSTAC+2,[MOVNS	AC13]
	MOVE	TSTAC+3,[ROT	AC13,1]
	MOVE	TSTAC+4,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+5,[JRST	CKRTN]
	JRST	CKFLT-3
ERPRN:	MOVEM	AC13,GDWORD
	GO	MEMER2
	JRST	TSTAC+2
;FAST RATE ADDRESSING SETUP
;SETS UP FAST RATE BIT WHICH IS ADDED
;TO THE ADDRESS WORD, STARTS WITH 1B35
;GOES TO 1B18
;FAST RATE WORD IN FRBIT
;NORMAL-RETURN +2, COMPLETED - RETURN +1

FASTR:	SKIPN	SVMA		;ALL MA BITS ?
	JRST	FASTR1		;YES
	MOVE	FRBIT,SVMA
	SKIPE	FRFST		;FIRST TIME ?
	JRST	FASTR2		;YES
	RTN			;NO, DONE, EXIT
FASTR1:	SKIPE	FRFST		;FIRST TIME
	SKIPA	FRBIT,[1]	;YES, START WITH 1B35
	ROT	FRBIT,1		;ROTATE ONE LEFT
	TLNE	FRBIT,1		;ALL BITS DONE
	RTN			;YES, EXIT
FASTR2:	MOVEM	FRBIT,ADRSCM	;SET ADDRESS SCHEME TO FAST RATE
	SETZM	FRFST		;CLEAR FIRST TIME FLAG
	JRST	XPOPJ1		;RETURN +2

;FAST RATE MA BIT SELECTION

MABIT:	MOVE	RANDBS		;GET RANDOM BASE NUMBER
	ANDI	37		;MAKE INTO RANGE 8. TO 39.
	ADDI	10
	CAIL	^D18		;IF 18. TO 35. USE AS FAST RATE BIT
	CAILE	^D35
	JRST	MABIT1		;OTHERWISE, DO ALL FAST RATE MA BITS
	MOVNM	TAC		;SETUP MA BIT IN PROPER POSITION
	MOVSI	400000
	LSH	(TAC)
	MOVEM	SVMA#		;SAVE FOR FAST RATE
	RTN

MABIT1:	SETZM	SVMA
	CAIGE	^D18		;IF 0. TO 17., DON'T DO FAST RATE
	SETOM	SVMA		;IF 36. TO 39. DO ALL FAST RATE BITS
	RTN
;FAST RATE ADDRESS
;READ-COMPLEMENT-WRITE
;ADDRESS CONTROL WORD IN ADRCON
;USED IN MFIRST, MLAST, ADR, ADRCON
;FAST RATE ADDRESS BIT IN FRBIT
;ROUTINE OPERATES IN THE FAST AC'S

FRRCW:	JSR	TSTIME
	MOVEM	PATRN,ACEE1#
	MOVEM	PATIX,ACEE2#	;SAVE THREE AC'S
	MOVEM	SEGIX,ACEE3#
	MOVE	AC14,CONSW	;GET SWITCHES
	TLNN	AC14,RELIAB	;FAST MODE
	SKIPA	1,[^D2]		;YES, PERFORM TWICE
	MOVEI	1,^D20		;NO, PERFORM 20 TIMES
	HRRZ	MFIRST,ADRCON	;SETUP MFIRST = 0, FIRST ADR
	HLRE	MLAST,ADRCON
	MOVMS	MLAST
	ADD	MLAST,MFIRST	;SETUP MLAST = 0,LAST ADR
	HLLZ	CNT,ADRCON	;SETUP COUNT = COUNT,0
	CAML	FRBIT,MLAST	;ADDRESS BIT GREATER THAN SEG
	JRST	FREXT		;YES, EXIT
	MOVEM	MFIRST,SVFRST#		;SAVE CONTROL WORDS
	MOVEM	CNT,SVCNT#
	MOVE	TSTAC,[MOVE ADRCON,MFIRST]
	MOVE	TSTAC+1,[SETCMM	(ADRCON)]
	MOVE	TSTAC+2,[AOBJN	CNT,TSTAC+4]
	MOVE	TSTAC+3,[JRST	FRRTN]
	MOVE	TSTAC+4,[ADD	ADRCON,FRBIT]
	MOVE	TSTAC+5,[CAMGE	ADRCON,MLAST]
	MOVE	TSTAC+6,[JRST	TSTAC+1]
	MOVE	TSTAC+7,[AOJA	MFIRST,TSTAC]
	JRST	TSTAC				;PERFORM ROUTINE

FRRTN:	SOJE	1,FREXT		;COMPLETED ITERATIONS ?
	MOVE	MFIRST,SVFRST		;NO, RESET CONTROL WORDS
	MOVE	CNT,SVCNT
	JSR	TSTIME
	JRST	TSTAC		;REPEAT SEQUENCE

FREXT:	MOVE	PATRN,ACEE1
	MOVE	PATIX,ACEE2	;RESTORE AC'S
	MOVE	SEGIX,ACEE3
	JRST	XPOPM1		;EXIT-1
;DATA PATTERNS TEST
;PATTERN EXECUTE LIST

DPATN:	ONES			;ALL ONES
	ZEROS			;ALL ZEROS
	ALTB			;ALTERNATE ONES AND ZEROS
	FLONE			;FLOATING ONE
	FLZRO			;FLOATING ZERO
	PRAND			;PSEUDO RANDOM, PARITY BIT CHECK
	DONE			;TEST EXIT

;PATTERN MNEMONICS LIST

DPATPT:	ASCII	/ONES /
	ASCII	/ZEROS/
	ASCII	/ALTB /
	ASCII	/FLONE/
	ASCII	/FLZRO/
	ASCII	/PRAND/

	ASCII	/PADR /
	ASCII	/CPADR/

;LOOP ON ERROR CHECK

ERLPCK:	SWITCH
	TLNN	0,LOOPER	;LOOP ON ERROR ?
	JRST	.+3		;NO
	SKIPE	WASERR		;YES, WAS THERE AN ERROR ?
	RTN			;YES, LOOP ON EXERCISE/CHECK
	SETZM	WASERR		;NO LOOP, CLEAR ERROR INDICATOR
	JRST	XPOPJ1		;RETURN +2
;DATA PATTERNS SETUP LIST

SETPAT:	ALLPAT			;ALL DATA PATTERNS
	SET1S			;ONES
	SET0S			;ZEROS
	SETALT			;ALT BITS
	SETFL1			;FLOATING ONES
	SETFL0			;FLOATING ZEROS
	STFL10			;FLOATING ONES/FLOATING ZEROS
	SETPRN			;PSEUDO RANDOM, PARITY BIT CHECK

ALLPAT:	GO	SET1S
	GO	SET0S
	GO	SETALT
	GO	SETFL1
	GO	SETFL0
	GO	SETPRN
	RTN

SET1S:	MOVEI	ONES
	MOVEM	DPATN
	RTN

SET0S:	MOVEI	ZEROS
	MOVEM	DPATN+1
	RTN

SETALT:	MOVEI	ALTB
	MOVEM	DPATN+2
	RTN

SETFL1:	MOVEI	FLONE
	MOVEM	DPATN+3
	RTN

SETFL0:	MOVEI	FLZRO
	MOVEM	DPATN+4
	RTN

STFL10:	GO	SETFL1
	GO	SETFL0
	RTN

SETPRN:	MOVEI	PRAND
	MOVEM	DPATN+5
	RTN
SUBTTL	MEMORY RELIABILITY, ERROR ROUTINES
;ERROR TYPEOUT ROUTINE
;PRINTS ERRORS AS THEY OCCUR
;TOTALIZES ERRORS FOR TOTALS PRINTOUT

MEMER0:	MOVEM	PATRN,GDWORD#	;SAVE GOOD WORD
	CAIA
MEMER1:	MOVEM	AC12,GDWORD
MEMER2:	MOVEM	0,ACEEE0#	;SAVE AC0
	HRRZ	ADRCON
	MOVEM	ERRPC
	MOVE	0,(ADRCON)	;GET ERROR WORD
	MOVEM	0,BADWRD#	;SAVE
	MOVEM	10,ACE10#	;SAVE AC'S
	MOVEM	11,ACE11#
	MOVEM	12,ACE12#
	MOVEM	13,ACE13#
	MOVE	10,GDWORD	;FIND FAILING BITS
	XOR	10,BADWRD
	MOVEM	10,FAIL#	;SAVE FAILED BITS
	SETOM	WASERR		;SET ERROR FLAG
MEMER3:	SKIPN	ERRFST		;FIRST ERROR
	JRST	.+4		;NO
	JSR	RUNTIM
	MOVEI	[ASCIZ/
MEMORY DATA ERROR
TN  AS  PAT  ADDRESS      CORRECT         ERROR       FAILED BITS PAR
/]
	PNTAL			;PRINT HEADER
	GO	ERADRP		;PRINT TEST NUMBER
	MOVEI	[ASCIZ/ /]
	PNTA			;SPACE 1
ERRADR:	SKIPLE	ADRSCM		;SEQUENTIAL ADDRESSING ?
	JRST	FRPNT		;NO
	MOVEI	[ASCII/SEQ/]	;YES, PRINT 'SEQ'
	SKIPE	ADRSCM
	MOVEI	[ASCII/BLT/]
	PNTA
	MOVEI	SPACE
	PNTA			;SPACE 1
	MOVEI	DPATPT(PATIX)
	PNTA			;PRINT DATA PATTERN
	MOVEI	SPACE
	PNTA			;SPACE 1
	HRRZ	ADRCON
	MAPADR
	ERRHLT
	MOVEM	PHYADR#
	PNTADR			;PRINT ADDRESS
	MOVEI	[ASCIZ/  /]
	PNTA			;SPACE 2
	MOVE	GDWORD
	PNTHW			;PRINT CORRECT
	MOVEI	SPACE
	PNTA			;SPACE 1
	MOVE	BADWRD
	PNTHW			;PRINT ERROR
	MOVEI	SPACE
	PNTA			;SPACE 1
	MOVE	FAIL
	PNTHW			;PRINT FAILED BITS
	MOVEI	[ASCIZ/P/]
	GO	PARCK		;CHECK PARITY
	PNTA			;YES, PRINT 'P'
	MOVEI	CRLF
	PNTA
	SETZM	ERRFST		;CLEAR FIRST ERROR FLAG
	SETOM	PARFST		;SET FIRST PARITY FLAG
;ERROR TOTALIZING ROUTINE

ERRRTN:	SWITCH
	TLNN	0,DING		;RING BELL ON ERROR
	JRST	.+3		;NO
	MOVEI	BELL		;BELL
	PNTAF
	GO	PARCK		;CHECK PARITY
	AOS	TOTPAR		;YES, INCREMENT PARITY TOTAL
	MOVE	10,TSTN		;INCREMENT TEST ERROR TOTAL
	AOS	TOTPAT-1(10)
	MOVE	10,GDWORD	;DETERMINE BITS PICKED UP
	MOVE	11,BADWRD
	ANDCA	10,11
	MOVEM	10,PICKED#	;SAVE
	SETZ	13,
	GO	ERRADD
	MOVE	10,GDWORD	;DETERMINE BITS DROPPED
	MOVE	11,BADWRD
	ANDCM	10,11
	MOVEM	10,DROPED#	;SAVE
	AOS	13
	GO	ERRADD

ERRTN1:	SKIPN	PICKED		;ANY DATA PICKUP FAILURES
	JRST	.+5		;NO
	MOVE	10,PHYADR	;DETERMINE ADR BITS WITH PICKUP
	LSH	10,^D14
	AOS	13
	GO	ERRADD
	SKIPN	DROPED		;ANY DATA DROPPED FAILURES
	JRST	.+5		;NO
	MOVE	10,PHYADR	;DETERMINE ADR BITS WITH DROPOUT
	LSH	10,^D14
	MOVE	13,[3]
	GO	ERRADD

ERRTN2:	MOVE	10,ACE10	;RESTORE AC'S
	MOVE	11,ACE11
	MOVE	12,ACE12
	MOVE	13,ACE13
	MOVE	0,GDWORD	;FIX ERROR
	MOVEM	0,(ADRCON)
	GO	ERCHK		;CHK FOR ERROR LIMIT
	MOVE	0,ACEEE0	;RESTORE AC0
	CLRBTH
	RTN			;RETURN TO CHECK
;ERROR TOTALIZING ADDITION SUBROUTINE

ERRADD:	JFFO	10,.+2		;COMPUTE BIT POSITION
	RTN			;NO ERRORS
	XCT	ADDTOT(13)	;INCREMENT ERROR TOTAL
	MOVNS	11
	HRLZI	12,400000	;CLEAR THIS BIT POSITION
	LSH	12,(11)
	TDZ	10,12
	JRST	.-7		;GET NEXT POSITION WITH FAILURE

ADDTOT:	AOS	PCKDB(11)	;ADD 1 TO DATA PICKUP TOTAL
	AOS	DRPDB(11)	;ADD 1 TO DATA DROPOUT TOTAL
	AOS	PCKAB(11)	;ADD 1 TO ADR BIT WITH DATA PICKUP
	AOS	DRPAB(11)	;ADD 1 TO ADR BIT WITH DATA DROPOUT

FRPNT:	MOVEI	[ASCII/F/]	;FAST RATE ADDRESSING
	PNTA			;PRINT 'F'
	MOVE	10,ADRSCM	;GET FAST RATE BIT
	JFFO	10,.+1		;COMPUTE BIT POSITION
	MOVE	11
	PNTDEC			;PRINT IT
	JRST	ERRADR+6	;CONTINUE PRINTOUT

;ERROR TEST NUMBER TYPEOUT

ERADRP:	MOVE	TSTN
	PNT1			;PRINT TEST NUMBER
	RTN			;EXIT

ERCHK:	SKIPL	MONCTL		;DON'T CHK IF STAND-ALONE
	RTN
	GO	ERRTOT		;ADD ERROR TOTALS
	CAIG	0,^D25		;25 ALLOWABLE ERRORS
	RTN			;OK
	JRST	@RETURN		;EXCEEDED LIMIT
;TOTAL ERRORS TYPEOUT ROUTINE

TOTAL:	MOVEI	[ASCIZ/
MEMORY /]
	PNTAL
	MOVEI	[ASCIZ/, PASS COUNT  /]
	PNTAL
	MOVE	PASCNT
	PNTDEC			;PRINT PROGRAM PASS COUNT
	JSR	RUNTIM
TOTAL1:	MOVEI	[ASCIZ/
ERROR TOTALS : /]		;PRINT TEST TOTALS
	PNTAL
	GO	ERRTOT		;ADD ERROR TOTALS
	JUMPN	0,TOTAL2	;ANY ERRORS
	MOVEI	[ASCIZ/NONE/]	;NO
	PNTAL			;PRINT 'NONE'
	JRST	TOTRTN		;EXIT

ERRTOT:	MOVE	0,TOTPAT	;ADD ERROR TOTALS
	ADD	0,TOTPHY
	MOVEM	ERRTLS
	RTN

TOTAL2:	PNTDEC			;PRINT TOTALS
	MOVEI	[ASCIZ/
PARITY ERRORS : /]
	PNTAL
	MOVE	TOTPAR
	PNTDEC			;PRINT PARITY TOTALS
	MOVEI	CRLF
	PNTA
	MOVEI	[ASCIZ/
DATA BIT FAILURES
BIT	    PICKUP   DROPOUT
/]
	PNTAL			;PRINT HEADER
	SETZ	1,
TOTAL3:	MOVE	2,PCKDB(1)	;ANY ERRORS, THIS BIT
	ADD	2,DRPDB(1)
	JUMPE	2,TOTAL4	;NO
	MOVE	1		;YES, PRINT DATA BIT NUMBER
	PNTDEC
	MOVEI	[ASCIZ/	/]
	PNTAL
	MOVE	PCKDB(1)
	PNTDS			;PRINT PICKUP TOTAL
	MOVE	DRPDB(1)
	PNTDS			;PRINT DROPOUT TOTAL
	MOVEI	CRLF
	PNTA
TOTAL4:	AOS	1		;INCREMENT INDEX
	CAIG	1,^D35		;DONE
	JRST	TOTAL3		;NO, REPEAT FOR NEXT BIT
	MOVEI	CRLF
	PNTA
	MOVEI	[ASCIZ/
ADDRESS BITS WITH DATA FAILURES
BIT         PICKUP   DROPOUT
/]
	PNTAL
	SETZ	1,

TOTAL5:	MOVEI	^D14(1)		;PRINT ADR BIT NUMBER
	PNTDEC
	MOVE	2,PCKAB(1)	;ANY ERRORS, THIS ADR BIT
	ADD	2,DRPAB(1)
	JUMPE	2,TOTAL6-2	;NO
	MOVEI	[ASCIZ/	/]
	PNTAL
	MOVE	PCKAB(1)
	PNTDS			;PRINT PICKUP TOTAL
	MOVE	DRPAB(1)
	PNTDS			;PRINT DROPOUT TOTAL
	MOVEI	CRLF
	PNTA

TOTAL6:	AOS	1		;INCREMENT INDEX
	CAIG	1,^D21		;DONE
	JRST	TOTAL5		;NO, REPEAT FOR NEXT BIT

TOTRTN:	MOVEI	CRLF2
	PNTA
	GO	CLRERR		;CLEAR ERROR TOTALS TABLE
	SETOM	ERRFST		;SET FIRST ERROR FLAG
	SETOM	PARFST		;SET PARITY FIRST ERROR FLAG
;CLEAR ERROR TOTALS

CLRERR:	SETZM	TOTPHY
	MOVE	TAC,[TOTPHY,,TOTPHY+1]
	BLT	TAC,DRPAB+^D21
	RTN

;MISC ROUTINES

XPOPJ1:	AOS	(P)		;RETURN +2
	RTN

XPOPM1:	SOS	(P)		;RETURN-1
	SOS	(P)
	RTN

;CHECK FOR PARITY ERROR
PARCK:	CONSZ	APR,LPARER	;KL10
	RTN
	JRST	XPOPJ1
SUBTTL	MEMORY RELIABILITY, SPECIAL PARITY INTERRUPT ROUTINE

;PARITY ERROR ROUTINE

PARERR:	MOVEM	10,ACE10	;SAVE AC'S
	MOVEM	11,ACE11
	MOVEM	12,ACE12
	MOVEM	13,ACE13
	SKIPN	PARFST		;FIRST ERROR
	JRST	.+4		;NO
	JSR	RUNTIM
	MOVEI	[ASCIZ/
MEMORY PARITY ERROR
TN    PROG     PC    AS    PAT    ADDRESS        DATA       PARITY
/]
	PNTAL			;PRINT HEADER
	GO	ERADRP		;PRINT TEST NUMBER
	MOVEI	[ASCIZ/  /]
	PNTA
	HRLZ	0,(P)		;PRINT LAST PUSHJ ENTRY
	HRR	0,ITRCH1	;AND PC OF INTERRUPTED
	SUB	0,[1,,1]	;LOCATION
	PNTHW
	MOVEI	[ASCIZ/  /]
	PNTA
PARER1:	SKIPLE	ADRSCM		;SEQUENTIAL ADDRESSING ?
	JRST	PFRPNT		;NO
	MOVEI	[ASCIZ/SEQ/]
	SKIPE	ADRSCM
	MOVEI	[ASCIZ/BLT/]
	PNTA
	MOVEI	[ASCIZ/   /]
	PNTA
	MOVE	AC10,PATXSV	;GET SAVED PATTERN INDEX
	MOVEI	DPATPT(AC10)
	PNTA			;PRINT DATA PATTERN
	MOVEI	[ASCIZ/  /]
	PNTA
	HRRZ	ADRCON
	MAPADR
	ERRHLT
	PNTADR
	MOVEI	[ASCIZ/  /]
	PNTA
	CLRBTH
	CAML	ADRCON,MAXMEM	;DOES CURRENT TEST ADR POINT TO MEMORY
	JRST	PARER2-2	;NO, OUTSIDE MEMORY
	MOVE	0,(ADRCON)	;GET CURRENT TEST ADR DATA
	PNTHW
	MOVEI	[ASCIZ/  /]
	PNTA
	MOVEI	[ASCIZ/P/]
	GO	PARCK		;CHECK PARITY
	PNTA			;YES, PRINT 'P'
	MOVEI	CRLF
	PNTA
PARER2:	MOVE	10,CONSW
	MOVEI	BELL
	TLNE	10,DING
	PNTAF
	AOS	TOTPAR		;INCREMENT PARITY TOTAL
	SETOM	ERRFST		;SET FIRST ERROR FLAG
	SETZM	PARFST		;CLEAR FIRST PARITY FLAG
	HRRZ	0,ITRCH1	;GET INTERRUPT PC
	CAIG	0,17		;PARITY ERROR IN PROGRAM AREA
	JRST	PARER3		;NO
	HRRZ	(P)		;YES
	CAIG	0,17		;WAS PROGRAM IN AC'S ?
	JRST	PARER3		;YES
	MOVEI	[ASCIZ/
**********
PARITY ERROR IN PROGRAM
PROGRAM OPERATION QUESTIONABLE FROM THIS POINT
**********
/]
	PNTAL
	SETOM	PARFST		;SET FIRST PARITY FLAG
PARER3:	MOVE	AC10,ACE10	;RESTORE AC'S
	MOVE	AC11,ACE11
	MOVE	AC12,ACE12
	MOVE	AC13,ACE13
	GO	ERCHK		;CHK FOR ERROR LIMIT
	MOVE	0,$ACC0
	CONO	PI,PARCLR
	JRST	10,@ITRCH1	;CONTINUE TEST

;PARITY FAST RATE ADDRESSING PRINT

PFRPNT:	MOVEI	[ASCIZ/F/]
	PNTA
	MOVE	AC10,ADRSCM	;GET FAST RATE BIT
	JFFO	AC10,.+1	;COMPUTE BIT POSITION
	MOVE	AC11
	PNTDEC			;PRINT IT
	JRST	PARER1+6
;ERROR TOTALS TABLE

ADRLST:	BLOCK	2		;ADDRESS LIST

TOTPHY:	0			;PHYSICAL ADDRESS TEST TOTAL
TOTPAT:	0			;DATA PATERNS TEST TOTAL
TOTPAR:	0			;PARITY ERROR TOTAL

PCKDB:	BLOCK	^D36		;DATA BIT PICKUP TOTAL
DRPDB:	BLOCK	^D36		;DATA BIT DROPOUT TOTAL
PCKAB:	BLOCK	^D22		;ADDRESS BIT, DATA PICKUP, TOTAL
DRPAB:	BLOCK	^D22		;ADDRESS BIT, DATA DROPOUT, TOTAL
  