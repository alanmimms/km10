;*MAINDEC-10-DFKCB

MCNVER=0
DECVER=1

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<

TITLE	DFKCB DECSYSTEM KL10 ADVANCED INSTRUCTION DIAGNOSTIC #2, VER MCNVER,DECVER
>
	LIST
	LALL

NAME	\MCNVER,\DECVER

	LOC	137
MCNVER,,DECVER

;*COPYRIGHT 1979
;*DIGITAL EQUIPMENT CORPORATION
;*MARLBORO, MASS.

;*JOHN R. KIRCHOFF

	SEARCH	MONSYM
	NOSYM

IF2,<PRINTX	[STARTING PASS 2]>
SUBTTL	ASSEMBLY TIME PARAMETERS

; **********************************************************************
;*ACCUMULATOR DEFINITIONS
; **********************************************************************

AC1=1				;AC,AC+1,AC+2,AC+3 - CONTAIN OPERANDS USED
				;  BY DADD,DSUB,DMUL,DDIV

CNT=11				;COUNT AC

SCR0=12				;SCRATCH ACS USED IN THE ADDL ERROR PRINT
SCR1=SCR0+1			;  ROUTINE
SCR2=SCR0+2
SCR3=SCR0+3

; **********************************************************************
;*BEGIN PARAMETERS
; **********************************************************************

SADR1=STARTA
SADR2=STARTA
SADR3=START
SADR4=SRTDDT
SADR5=STARTA
SADR6=PHALT
SADR7=HALT BEGIN
SADR8=HALT BEGIN
SADR9=HALT BEGIN
SADR10=HALT BEGIN
SADR11=HALT BEGIN
ITERAT=10
PAREA1=0
PAREA2=0
PAREA3=SIXBIT/DFKCB/
PAREA4=SIXBIT/LST/
PAREA5=0
PAREA6=0

KL10==1
KL10P0==1
PGMEND==1
EXCASB==1
USRASB==1
DEBUG==30
SUBTTL	MACROS

; **********************************************************************
;*PCSAVE - GET AND SAVE PC
; **********************************************************************

DEFINE	PCSAVE<
	JSR	.+1		;STORE PC
FLAGL=.				;LOCATION OF PC
	0			;PC
>

; **********************************************************************
;*TFLAG - TEST PC FLAGS SET BY THE PRIOR DADD/DSUB
; **********************************************************************

DEFINE	TFLAG (FLGGS,TT,ADDR<APRINT>,LOC<LOC>)<

	MOVE	SCR1,FLAGL	;GET FLAGS
	MOVE	SCR2,FLGGS 	;SCR2 - CORRECT FLAGS
	SKIPN	USER		;EXEC MODE ?
	TLZ	SCR2,AROV	;YES, NO AROV FLAG IN EXEC ON KL10
	XOR	SCR1,SCR2	;SET ALL MATCHING BITS TO 0
	TLNE	SCR1,740000	;TEST IF MATCH CORRECTLY
	ERROR	(LOC,13,SCR2,FLAGL,,
TEST 'TT' - PC FLAGS INCORRECT (LEFT 4 BITS),ADDR)
>
; **********************************************************************
;*MULT - PERFORM DMUL AND TEST RESULTS
; **********************************************************************

DEFINE	MULT (T,A1<0>,A2<0>,E1<0>,E2<0>,R1<0>,R2<0>,R3<0>,R4<0>,%BEGIN)<

; --- MULTIPLICAND = (A1,A2)
; --- MULTIPLIER === (E1,E2)
; --- RESULT ======= (R1,R2,R3,R4)

%BEGIN:	MOVE	AC1,[[EXP A1,A2,E1,E2,R1,R2,R3,R4],,MCAND]
	BLT	AC1,MRES+3	;SET UP OPERANDS FOR SUBROUTINE
	GO	MSUBR		;GO DO TEST
	ERROR	(%BEGIN,14,SCR1,SCR2,,
TEST 'T' - RESULT CALCULATED INCORRECTLY,MPRINT)
>

; **********************************************************************
;*MULTF - PERFORM DMUL AND TEST RESULTS & PC FLAGS
; **********************************************************************

DEFINE	MULTF (T,A1<0>,A2<0>,E1<0>,E2<0>,R1<0>,R2<0>,R3<0>,R4<0>,%BEGIN,%TSTPC)<

; --- MULTIPLICAND = (A1,A2)
; --- MULTIPLIER === (E1,E2)
; --- RESULT ======= (R1,R2,R3,R4)

%BEGIN:	MOVE	AC1,[[EXP A1,A2,E1,E2,R1,R2,R3,R4],,MCAND]
	BLT	AC1,MRES+3	;SET UP OPERANDS FOR SUBROUTINE
	GO	MSUBR		;GO DO TEST
	ERROR	(%BEGIN,14,SCR1,SCR2,,
TEST 'T' - RESULT CALCULATED INCORRECTLY,MPRINT)

%TSTPC:	MOVE	SCR2,MFLOC	;GET PC - TO TEST PC FLAGS
	TLZE	SCR2,AROV	;CALC OK PC (NO - AROV) & TEST
	ERROR	(%BEGIN,13,SCR2,MFLOC,,
TEST 'T' - PC FLAGS INCORRECT - BITS 0 TO 4,MPRINT)
>
; **********************************************************************
;*PDIV - PERFORM DDIV AND TEST RESULTS
; **********************************************************************

DEFINE	PDIV (T,A1,A2,A3,A4,E1,E2,R1<0>,R2<0>,R3<0>,R4<0>,%BEGIN)<

; --- DIVIDEND == (A1,A2,A3,A4)
; --- DIVISOR === (E1,E2)
; --- QUOTIENT == (R1,R2)
; --- REMAINDER = (R3,R4)

%BEGIN:	MOVE	AC1,[[EXP A1,A2,A3,A4,E1,E2,R1,R2,R3,R4],,PDEND]
	BLT	AC1,PRES+3	;SET UP OPERANDS
	GO	PSUBR		;GO DO TEST
	ERROR	(%BEGIN,14,SCR1,SCR2,,
TEST 'T' - QUOTIENT/REMAINDER INCORRECT,DPRINT)
>

; **********************************************************************
;*PDIVF - PERFORM DDIV AND TEST RESULTS & PC FLAGS
; **********************************************************************

DEFINE	PDIVF (T,A1,A2,A3,A4,E1,E2,R1<0>,R2<0>,R3<0>,R4<0>,%BEGIN,%TSTPC)<

; --- DIVIDEND == (A1,A2,A3,A4)
; --- DIVISOR === (E1,E2)
; --- QUOTIENT == (R1,R2)
; --- REMAINDER = (R3,R4)

%BEGIN:	MOVE	AC1,[[EXP A1,A2,A3,A4,E1,E2,R1,R2,R3,R4],,PDEND]
	BLT	AC1,PRES+3	;SET UP OPERANDS
	GO	PSUBR		;GO DO TEST
	ERROR	(%BEGIN,14,SCR1,SCR2,,
TEST 'T' - QUOTIENT/REMAINDER INCORRECT,DPRINT)

%TSTPC:	MOVE	SCR2,PFLOC	;GET PC
	TLZE	SCR2,AROV+DCK	;CALC OK PC (NO - OV/DIV) & TEST
	ERROR	(%BEGIN,13,SCR2,PFLOC,,
TEST 'T' - PC FLAGS INCORRECT - BITS 0 & 12,DPRINT)
>
; **********************************************************************
;*ODIV - PERFORM DDIV AND TEST RESULTS & PC FLAGS
;*       (HANDLES OVERFLOW/NO DIVIDE CONDITIONS)
; **********************************************************************

DEFINE	ODIV (A1,A2,A3,A4,E1,E2,%BEGIN,%TSTPC)<

; --- DIVIDEND == (A1,A2,A3,A4)
; --- DIVISOR === (E1,E2)
; --- QUOTIENT/REMAINDER - NOT CALCULATED (DIVIDEND UNCHANGED)

%BEGIN:	MOVE	AC1,[[EXP A1,A2,A3,A4,E1,E2],,ODEND]
	BLT	AC1,ORES-1	;SET UP OPERANDS
	GO	OSUBR		;GO DO TEST
	ERROR	(%BEGIN,14,SCR1,SCR2,,
TEST G - DIVIDEND CHANGED ON OV/NODIV,DPRINT)

%TSTPC:	MOVE	SCR2,OFLOC	;GET PC
	IOR	SCR2,[AROV+DCK,,0]	;CALC CORRECT PC (OV/NO DIV)
	SKIPN	USER		;EXEC MODE ?
	TLZ	SCR2,AROV	;YES, NO AROV FLAG IN EXEC ON KL10
	CAME	SCR2,OFLOC	;PC CORRECT?
	ERROR	(%BEGIN,13,SCR2,OFLOC,,
TEST G - PC FLAGS INCORRECT - BITS 0&12,DPRINT)
>

; **********************************************************************
;*CHECKA - CHECK RESULTS OF A DADD & DO ERROR HANDLING
;*	 (RESULT 'R1' IS PASSED AS THE OCTAL DATA ITSELF)
; **********************************************************************

DEFINE	CHECKA (LOC,T,R1< 0>,R2< 0>,%ERROR,%END)<

	SETZ	SCR1,		;POINTER TO WHICH WORD IN ERROR
	CAME	AC1,[R1]	;IS LEFT HALF OF RESULT CORRECT?
	JRST	%ERROR		;NO - GO TO ERROR HANDLING
	MOVEI	SCR1,1		;YES, POINTER TO RIGHT HALF
	CAMN	AC1+1,[R2]	;IS RIGHT HALF CORRECT?
	JRST	%END+1  	;YES - DONT DO ERROR HANDLING
				; EXCEPT FOR ERLOOP

%ERROR:	MOVE	SCR2,AC1(SCR1)	;GET ACTUAL WORD OF RESULT
	MOVE	SCR1,[EXP R1,R2](SCR1)	;GET CORRECT RESULT
%END:	ERROR	(LOC,14,SCR1,SCR2,,
TEST 'T' - RESULT IS INCORRECT,APRINT)
>
; **********************************************************************
;*CHECKS - CHECK RESULTS OF A DSUB & DO ERROR HANDLING
;*	 (RESULT 'R1' IS PASSED AS THE OCTAL DATA ITSELF)
; **********************************************************************

DEFINE	CHECKS (LOC,T,R1< 0>,R2< 0>,%ERROR,%END)<

	SETZ	SCR1,		;POINTER TO WHICH WORD IN ERROR
	CAME	AC1,[R1]	;IS LEFT HALF OF RESULT CORRECT?
	JRST	%ERROR		;NO - GO TO ERROR HANDLING
	MOVEI	SCR1,1		;YES, POINTER TO RIGHT HALF
	CAMN	AC1+1,[R2]	;IS RIGHT HALF CORRECT?
	JRST	%END+1  	;YES - DONT DO ERROR HANDLING
				;	EXCEPT FOR ERLOOP

%ERROR:	MOVE	SCR2,AC1(SCR1)	;GET ACTUAL WORD OF RESULT
	MOVE	SCR1,[EXP R1,R2](SCR1)	;GET CORRECT RESULT
%END:	ERROR	(LOC,14,SCR1,SCR2,,
TEST 'T' - RESULT IS INCORRECT,SPRINT)
>

; **********************************************************************
;*CHECKB - CHECK RESULTS OF A DADD & DO ERROR HANDLING
;*	 (RESULT 'R1' IS PASSED AS THE ADDRESS OF THE DATA)
; **********************************************************************

DEFINE	CHECKB (LOC,T,R1,%ERROR,%END)<

	SETZ	SCR1,		;POINTER TO WHICH WORD IN ERROR
	CAME	AC1,R1		;IS LEFT HALF OF RESULT CORRECT?
	JRST	%ERROR		;NO - GO TO ERROR HANDLING
	MOVEI	SCR1,1		;YES, POINTER TO RIGHT HALF
	CAMN	AC1+1,R1+1	;IS RIGHT HALF CORRECT?
	JRST	%END+1  	;YES - DONT DO ERROR HANDLING
				;	EXCEPT FOR ERLOOP

%ERROR:	MOVE	SCR2,AC1(SCR1)	;GET ACTUAL WORD OF RESULT
	MOVE	SCR1,R1(SCR1)	;GET CORRECT WORD OF RESULT
%END:	ERROR	(LOC,14,SCR1,SCR2,,
TEST 'T' - RESULT IS INCORRECT,APRINT)
>
; **********************************************************************
;*CHECKT - CHECK RESULTS OF A DSUB & DO ERROR HANDLING
;*	 (RESULT 'R1' IS PASSED AS THE ADDRESS OF THE DATA)
; **********************************************************************

DEFINE	CHECKT (LOC,T,R1,%ERROR,%END)<

	SETZ	SCR1,		;POINTER TO WHICH WORD IN ERROR
	CAME	AC1,R1  	;IS LEFT HALF OF RESULT CORRECT?
	JRST	%ERROR		;NO - GO TO ERROR HANDLING
	MOVEI	SCR1,1		;YES, POINTER TO RIGHT HALF
	CAMN	AC1+1,R1+1      	;IS RIGHT HALF CORRECT?
	JRST	%END+1  	;YES - DONT DO ERROR HANDLING
				;	EXCEPT FOR ERLOOP

%ERROR:	MOVE	SCR2,AC1(SCR1)	;GET ACTUAL WORD OF RESULT
	MOVE	SCR1,R1(SCR1)	;GET CORRECT WORD OF RESULT
%END:	ERROR	(LOC,14,SCR1,SCR2,,
TEST 'T' - RESULT IS INCORRECT,SPRINT)
>
    