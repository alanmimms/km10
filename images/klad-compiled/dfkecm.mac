SUBTTL	TEST CONTROL SECTION
								SALL
T=SIXBTZ	<KL10 PXCT TEST>

; **********************************************************************
;*START - STARTUP CODE
; **********************************************************************

START:
S:	MOVEI	.
	MOVEM	TESTPC
	PGMINT			;INIT SUBRTN PACKAGE
	SETZM	ERRTLS

	MOVEM	P,GOODP		;SAVE A GOOD P

	DATAI	PAG,A
	TLZ	A,(7B8)		;CLR BLK NO
	TDO	A,[<MYACS>B8+UPTPN] ;SET AC BLK TO MINE
	DATAO	PAG,A		;DO IT

	MOVE	P,GOODP		;RESTORE P

	SETZ	F,		;CLEAR ALL FLAGS

	APRID	A		;GET APRID TO A

	TLNE	A,(1B0)		;KL PAGING IN UCODE?
	TLO	F,(KLPGNG)	;YES

	TLNE	A,(1B1)		;EXTENDED ADDR IN UCODE?
	TLO	F,(UCODX)	;YES

	TLNN	A,(1B2)		;SPECIAL FLAVOR OF UCODE?
	JRST	ST1		;NO

	TLO	F,(UCODSP)	;YES
	PMSG	<^NOTE: THIS IS A NON-STANDARD VERSION OF THE MICROCODE.^>

ST1:	TLNE	F,(KLPGNG)	;KL PAGING?
	TLNE	F,(UCODX)	;YES, UCODE EXTENDED?
	JRST	ST2		;NOT KLA OR KLB

	TLO	F,(KLAKLB)	;NOTE KLA OR KLB

ST2:	TRNE	A,1B21		;HDW EXTENDED?
	TLO	F,(KL10X)	;YES

	TLC	F,(KLXCON)	;CHECK KLXTST CONDITIONS
	TLCN	F,(KLXCON)	;SKIP IF NOT ALL SET
	TLO	F,(KLXTST)	;NOTE EXTENDED ADR TEST

	SETZM	GCASEN		;CLR GRAND TOTAL CASES CNTR
	MOVEM	F,GOODF		;SAVE A COPY OF FLAGS

; **********************************************************************
;*STARTA - PROGRAM PASS RESTART SECTION
; **********************************************************************

STARTA:	MOVE	F,GOODF		;GET A COPY OF FLAGS
	TLNN	F,(KLPGNG)	;SKIP IF KL PAGING
	FATALE	<LOAD KLL (MODEL A) OR KLX (MODEL B) MICROCODE AND RESTART>

	TLNE	F,(KLPGNG)	;SKIP IF KI PAGING
	GO	KLPSET		;SETUP KL PAGING

; **********************************************************************
;*TSTLOP -  MAIN LOOP
; **********************************************************************

	MOVSI	TN,-TTABSZ	;SETUP AOBJN CTR
TSTLOP:	SETOM	CASE		;INIT CASE COUNTER
	MOVEM	TN,SAVETN	;SAVE A GOOD COPY OF TN FOR PXDISP

	GO	TSTTAB(TN)	;DO THE TEST

	MOVE	TN,SAVETN	;RECOVER TN
	AOBJN	TN,TSTLOP	;CONTINUE TILL DONE

	SKIPN	ERRTLS		;SEE IF ANY ERRORS
	JRST	BEGEND		;GO DECR ITER CTR, ETC

	PMSG	<^TOTAL ERRORS ENCOUNTERED = >
	MOVE	0,ERRTLS	;GET COUNT
	PNTOCS			;SHOW IT
	PCRL
	JRST	BEGEND		;GO DECR ITER CTR, ETC

SUBTTL	TEST SECTION

; **********************************************************************
;*.MOVE -  TEST OF 'PXCT N,[MOVE A,Y]'
; **********************************************************************
									SALL
T=SIXBTZ	<'PXCT N,[MOVE A,Y]'>

.MOVE:	MOVEI	.
	MOVEM	TESTPC
	MOVE	P,TESTP		;GET A GOOD VALUE OF P

	AOS	A,CASE		;GET CURRENT CASE NUMBER
	CAML	A,CASTAB(TN)	;COMPARE AGAINST MAX TO TRY
	RTN			;DONE

	GO	CLRPGS		;CLEAR EXTRA PAGES

	IDIVI	A,2		;GET INDEX INTO 'N' TABLE DATA
	MOVE	B,[4
		   14](B)	;PXCT 'N' IS EITHER 4 OR 14 FOR THIS TEST
	MOVEM	B,PXCTN		;SAVE 'N' TO TEST
	DPB	B,[POINT 4,PXCTIN,12] ;PUT IN PXCT INSTR

	GO	SETCXT		;SETUP PREVIOUS CONTEXTS

.MOVE0:	IDIVI	A,AMODLN	;GET ADDR MODE TO TRY
	MOVEM	B,TMOD		;SAVE TEST ADDR MODE

			; ******************************
ELOOP=.			;PLACE TO LOOP BACK TO ON ERROR
			; ******************************

	MOVE	B,TMOD		;RECOVER INCASE LOOPING
	MOVEI	A,AMODTB(B)	;GET ADDR OF INSTR TO BE TESTED

	MOVE	C,(A)		;GET ADDR MODE TO BE TESTED
	MOVEM	C,PXCTEA	;SETUP @ PXCT'S EA

	MOVEI	C,<MOVE>_-^D27	;GET OPCODE FOR MOVE INSTR
	DPB	C,[POINT 9,PXCTEA,8] ;DEPOSIT OPCODE

; ************************************************
;SETUP FOR EFFECTIVE ADDRESS CALCULATION
; ************************************************

	SETOM	SETFLG		;NOTE WE'RE SETTING UP

	MOVEI	C,10		;VALUE FOR INDEX REGISTER
	MOVEM	C,EXECAC+B	;SAVE IN EXEC AC BLOCK

	MOVE	C,PXCTN		;GET 'N'
	HRL	A,CCS		;START IN CURRENT CONTEXT SECTION

	TRNE	C,1B<9+23>	;SKIP IF CURRENT CONTEXT EA CALC
	HRL	A,PCS		;ELSE USE PCS

	TLZ	A,(1B1)		;ASSUME CURRENT CONTEXT FOR EACALC
	TRNE	C,1B<9+23>	;BUT NOT IF PXCT BIT 9 = 1
	TLO	A,(1B1)		;USE PREVIOUS CONTEXT

	GO	CASECK		;SEE IF THIS CASE VALID FOR SECTION-0
	 JRST	.MOVE		;N, SEC-0 & GLOBAL ADDRESSING CASE

	GO	AMAP		;MAP IN ADDR MODE PAGE

	GO	EACALC		;DO EA CALC TO SETUP ADDR CHAINS
	MOVEM	A,PEA		;SAVE INSTR'S EA

	SETZM	SETFLG		;CLEAR SET FLAG

	GO	RANDOM		;GET A RANDOM NUMBER
	MOVEM	0,PQ		;SAVE FOR EA OF MOVE INSTR
	MOVEM	0,OLDSRC	;SAVE SRC DATA

; ************************************************
;CALC MAPPING FOR DATA PAGE
; ************************************************

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREVIOUS
	LDB	B,[POINT 12,PEA,17] ;GET GLOBAL VIRT SECTION FROM EA
	SETZM	PCSSUB#		;CLEAR SUBSTITUTION FLAG

	TRNN	A,1B<10+23>	;CHECK N BIT FOR PREV CXT
	JRST	.MOV10		;CURRENT CONTEXT FOR DATA REF

	SKIPN	PCU		;CHECK PCU BIT FOR PREV CXT USER
	SETZ	T3,		;NO, EXEC

.MOV10:	SKIPN	LOCGBL		;IS EA GLOBAL OR LOCAL?
	JRST	.MOV20		;GLOBAL, DON'T DO SUBSTITUTION

	CAIE	A,4		;IS PXCT-N EQUAL TO DATA REF ONLY CASE?
	JRST	.MOV20		;NO, DON'T DO SUBSTITUTION

	MOVE	B,PCS		;GET PREVIOUS CXT SECTION
	SETOM	PCSSUB		;NOTE WE SUBSTITUTED PCS FOR DATA REF

.MOV20:	HRLM	B,PXDEA		;SAVE SECTION FOR PXDISP TO PRINT
	MOVE	C,PEA		;GET ADDRESS
	HRRM	C,PXDEA		;SAVE FOR PXDISP TO PRINT

	MOVEI	C,<VQ_-9>	;GET VIR PAG NUM
	MOVEI	A,PQ		;GET PHYS ADR
	GO	PMAPRT		;MAP IN PAGE

; ************************************************
;CALCULATE MAPPING FOR ADDR CHAIN PAGE
; ************************************************

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREVIOUS

	TRNE	A,1B<9+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU
	SETZ	T3,		;NO, CURRENT CONTEXT

	HRR	B,CCS		;ASSUME CURRENT CONTEXT SECTION

	TRNE	A,1B<9+23>	;CHECK 'N' BIT
	HRR	B,PCS		;NO, PREVIOUS

	MOVEI	A,AMOD		;GET ADDR OF ADDR CHAIN PAGE
	MOVEI	C,AMODPN	;GET PAGE NUMBER
	GO	PMAPRT		;MAP IN THE ADDR MODE PAGE

; ************************************************
;GET READY TO DO ACTUAL PXCT
; ************************************************

.MOVE1:	SETZM	PFHSPC		;CLR SPECIAL PF HANDLER ADDR

	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101

	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;GO DO PXCT
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,MOVE,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.MOVE		;DO NEXT CASE

	MOVE	B,EXECAC+1	;GET RESULT OF MOVE
	CAMN	B,OLDSRC	;CHECK AGAINST RESULT EXPECTED
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,OLDSRC,EXECAC+1,MOVE,AC RESULT INCORRECT,PXDISP)
	JRST	.MOVE		;ELSE DO NEXT CASE

	GO	RANDOM		;GET A RANDOM VALUE
	MOVEM	0,PQ		;CHG DESTINATION LOC

	MOVEI	C,<MOVEM>_-^D27	;GET OPCODE FOR MOVEM
	DPB	C,[POINT 9,PXCTEA,8] ;SET IT

; **********************************************************************
;*.MOVE2 - TEST OF PXCT N,[MOVEM A,Y]'>
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[MOVEM A,Y]'>

.MOVE2:	SETZM	PFHSPC		;NO PF EXPECTED
	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101

	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;REWRITE DATA TO MEMORY
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,MOVEM,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.MOVE		;DO NEXT CASE

	MOVE	A,OLDSRC	;GET ORIGINAL SRC DATA
	CAME	A,PQ		;SEE IF IT GOT REWRITTEN CORRECTLY
	ERROR	(ELOOP,13,OLDSRC,PQ,MOVEM,MEM DATA INCORRECT,PXDISP)
	JRST	.MOVE		;DO NEXT CASE


; **********************************************************************
;*.BLT - TEST OF 'PXCT N,[BLT A,Y]'
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[BLT A,Y]'>

.BLT:	MOVEI	.
	MOVEM	TESTPC
	MOVE	P,TESTP		;GET A GOOD VALUE OF P

	AOS	A,CASE		;GET NEXT CASE NUMBER
	CAML	A,CASTAB(TN)	;SEE IF DONE
	RTN			;YES

	GO	CLRPGS		;CLEAR EXTRA PAGES

	IDIVI	A,BLNTLN	;DIVIDE BY NUMBER OF N'S TO TEST
	MOVE	B,BLTNTB(B)	;GET AN 'N'
	MOVEM	B,PXCTN		;SAVE IT

	GO	SETCXT		;SETUP PREVIOUS CONTEXTS

	SETZ	B,		;READY B TO GET A BIT
	LSHC	A,-2		;MOVE BITS TO B
	ROT	B,2		;RIGHT JUSTIFY THEM IN B
	MOVEM	B,BLTYPE	;SAVE BLT TYPE

	IDIVI	A,NSECS
	MOVE	B,SECTAB(B)
	MOVEM	B,BLEASC	;SAVE BLT'S EA SECTION

			; ******************************
ELOOP=.			;PLACE TO LOOP BACK TO ON ERROR
			; ******************************

	MOVE	A,[BLT A,@VEA]	;GET AN INSTRUCTION TO TEST
	MOVEM	A,PXCTEA	;SAVE AT PXCT'S EA

	MOVE	A,PXCTN		;GET N FOR PXCT N,[BLT A,Y]
	DPB	A,[POINT 4,PXCTIN,12] ;PUT IN PXCT INSTR

	MOVE	B,BLTYPE	;GET BLT TEST TYPE
	MOVE	B,BLSTOP(B)	;GET A STOP ADDR
	MOVEM	B,PEA		;SAVE IT

; ************************************************
;READY TO MAP PAGE FOR EACALC
; ************************************************

	MOVE	A,PXCTN		;GET 'N'
	MOVE	B,PCS		;ASSUME PREVIOUS CXT
	TRNN	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CXT
	MOVE	B,CCS		;NO, USE CURRENT CXT SEC

	MOVEI	C,VPXPN		;GET VIRTUAL PAGE NUMBER
	MOVE	T3,PCU		;GET PREV CXT USER BIT
	TRNN	A,1B<9+23>	;SKIP IF PREVIOUS CXT
	SETZ	T3,		;ELSE SETUP FOR CURRENT CXT

	MOVEI	A,PEA		;POINT TO PAGE CONTAINING EA
	GO	PMAPRT		;MAP IN PAGE

	MOVE	A,BLEASC	;GET SECTION FOR BLT EA
	DPB	A,[POINT 12,PEA,17] ;PUT IN EA

	MOVE	B,BLTYPE	;GET BLT TEST TYPE
	MOVE	A,BLACWD(B)	;GET BLT AC WD
	MOVEM	A,BLTAC		;SAVE BLT'S AC CONTENTS

	MOVE	A,PXCTN		;GET 'N'
	CAIE	A,1		;SRC ONLY IN PREV CXT?
	JRST	BLT10		;NO

	MOVE	A,[16,,VD1]	;BLT PTR
	MOVEM	A,BLTAC		;SRC MUST BE AC REF

	MOVEI	A,VD1+1		;STOP ADDRESS
	HRRZM	A,PEA		;SAVE STOP ADDR
	JRST	BLT50		;OK

BLT10:	CAIE	A,4		;DST ONLY IN PREV CXT?
	JRST	BLT20		;NO

BLT30:	MOVE	A,[VS1,,16]	;BLT PTR
	MOVEM	A,BLTAC		;DST MUST BE AC REF

	MOVEI	A,17		;STOP ADDR
	HRRZM	A,PEA		;SAVE STOP ADDR
	JRST	BLT50		;OK

BLT20:	CAIN	A,14		;DST + EACALC IN PREV CXT?
	JRST	BLT30		;YES, SETUP AS FOR PXCTN=4

BLT50:	MOVE	A,PEA		;GET EA
	MOVEM	A,PXDEA		;SAVE A COPY FOR PXDISP

	MOVSI	T3,1		;ASSUME PREV CXT
	MOVE	A,PXCTN		;GET PXCT 'N'
	TRNE	A,1B<12+23>	;SKIP IF NOT PREV CXT FOR SRC
	SKIPN	PCU		;SEE IF IT MATTERS
	SETZ	T3,		;CURRENT CONTEXT

	MOVEM	T3,SRCCXT	;SAVE SOURCE CONTEXT

	MOVE	B,BLEASC	;ASSUME CURRENT CONTEXT
	TRNE	A,1B<12+23>	;SKIP IF CURRENT CXT FOR SRC
	MOVE	B,PCS		;ELSE USE PREVIOUS CXT SEC
	MOVEM	B,SRCSEC	;SAVE SOURCE SECTION

	HLRZ	C,BLTAC		;GET FROM ADDR
	MOVEM	C,SRCADD	;SAVE SOURCE ADDR
	HRLM	B,SRCADD	;SAVE SECTION IN ADDR

	LSH	C,-11		;MAKE PAGE NUMBER
	MOVEM	C,SRCPG1	;SAVE 1ST SRC PAGE NUM

	MOVEI	A,PS1		;ADDR OF DATA PAGE
	GO	PMAPRT		;GO MAP IN PAGE

	AOS	A,SRCADD	;GET SRCADD+1
	SKIPN	SRCSEC		;SKIP IF NON-ZERO SECTION
	HRRZS	A		;ELSE INSURE WRAPAROUND

	LDB	C,[POINT 9,A,26] ;GET PAGE NUMBER
	HLRZ	B,A		;GET SECTION NUMBER
	MOVEI	A,PS2		;SECOND SRC PAGE
	CAMN	B,SRCSEC	;SEE IF SECTION SAME
	CAME	C,SRCPG1	;SEE IF SAME AS SRC PAGE 1
	GO	PMAPRT		;MAP IN 2ND PAGE IF EITHER IS DIFFERENT

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREVIOUS
	TRNE	A,1B<10+23>	;SKIP IF NOT PREVIOUS CXT
	SKIPN	PCU		;SKIP IF PREVIOUS CXT USER
	SETZ	T3,		;ELSE EXEC CXT
	MOVEM	T3,DSTCXT	;SAVE DESTINATION CONTEXT

	MOVE	B,BLEASC	;ASSUME CURRENT CONTEXT
	TRNE	A,1B<10+23>	;SKIP IF CURRENT CXT FOR DST
	MOVE	B,PCS		;ELSE USE PREVIOUS CXT SEC

	HRRZ	C,BLTAC		;GET 'TO' ADDR
	MOVEM	C,DSTADD	;SAVE DESTINATION ADDRESS

	HRLM	B,DSTADD	;PUT SECTION NUMBER IN ADDR
	LSH	C,-11		;MAKE PAGE NUMBER
	MOVEM	C,DSTPG1	;SAVE 1ST DESTINATION PAGE

	MOVEI	A,PD1		;ADDR OF DST DATA PAGE
	GO	PMAPRT		;MAP IN PAGE

	AOS	A,DSTADD	;GET 2ND DESTINATION ADDR
	SKIPN	BLEASC		;SKIP IF NON-ZERO SECTION
	HRRZS	A		;ELSE INSURE WRAPAROUND

	LDB	C,[POINT 9,A,26] ;GET PAGE NUMBER
	HLRZ	B,A		;GET SECTION NUMBER
	MOVEI	A,PD2		;SECOND DESTINATION PAGE
	CAMN	B,BLEASC	;SEE IF SAME SECTION
	CAME	C,DSTPG1	;SEE IF SAME PAGE
	GO	PMAPRT		;NEED TO MAP IN SECOND PAGE

	HRLZ	A,SRCSEC	;GET SOURCE SECTION
	HLR	A,BLTAC		;PUT FROM ADDR IN RH(A)

	GO	RANDOM		;GET A RANDOM WORD
	MOVE	B,0		;GET TO B
	MOVEM	B,BLT1		;SAVE BLT 1ST WORD

	MOVE	C,SRCCXT	;GET CORRECT CONTEXT FOR WRITE
	GO	CXWRIT		;WRITE TO PROPER ADDR
	AOS	A		;NEXT ADDR

	SKIPN	SRCSEC		;SKIP IF NOT SECTION ZERO
	HRRZS	A		;ELSE INSURE WRAPAROUND

	GO	RANDOM		;GET ANOTHER RANDOM WORD
	MOVE	B,0		;GET WORD TO B
	MOVEM	B,BLT2		;SAVE BLT 2ND WORD

	GO	CXWRIT		;WRITE ANOTHER WORD

	MOVE	B,BLTAC		;GET CONTENTS
	MOVEM	B,EXECAC+A	;PUT IN EXEC AC A

	HLRZ	A,PEA		;GET SECTION NUMBER FOR STOP ADDR
	CAIGE	A,40		;ILLEGAL?
	JRST	.BLT1		;NO

	MOVEI	A,S0PFIN	;SPECIAL PF HANDLER
	SETZM	PFFLAG		;CLR FLAG
	MOVEM	A,PFHSPC	;SAVE ADDR FOR PFH ROUTINE
	JRST	.BLT2		;DON'T CLR THAT WD

.BLT1:	SETZM	PFHSPC		;NO SPECIAL PF ROUTINE

.BLT2:	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101

	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;DO THE PXCT
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,BLT,UNEXPECTED PAGE FAULT,PXDISP)
	RTNSKP			;OK, RETURN GOOD

	MOVE	A,BLTAC		;GET BLT AC
	HRL	A,DSTSEC	;GET DESTINATION SECTION TO LH(A)
	MOVE	C,DSTCXT	;GET CORRECT CONTEXT

	GO	CXREAD		;GET RESULTS OF 1ST XFER

	CAMN	B,BLT1		;SAME AS EXPECTED?
	JRST	SNDCHK		;Y, CHK 2ND WD
	ERROR1	(13,BLT1,B,BLT,FIRST WORD XFER'D INCORRECTLY,PXDISP)

	AOS	A		;INCR ADDR
	SKIPN	DSTSEC		;BUT CHECK FOR SECTION ZERO
	HRRZS	A		;AND INSURE WRAPROUND

	GO	CXREAD		;GET 2ND WD XFER'D

	CAMN	B,BLT2		;OK?
	JRST	FSTBAD		;YES, ONLY FIRST WAS BAD

	ERROR1	(13,BLT2,B,BLT,BOTH WORDS XFER'D INCORRECTLY,PXDISP)
	ERLP2	ELOOP
	JRST	.BLT		;DO NEXT CASE

FSTBAD:	ERLP2	ELOOP
	JRST	.BLT		;DO NEXT CASE

SNDCHK:	AOS	A		;INCR ADDR
	SKIPN	DSTSEC		;BUT CHECK FOR SECTION ZERO
	HRRZS	A		;AND INSURE WRAPROUND

	GO	CXREAD		;GET 2ND WD XFER'D

	CAME	B,BLT2		;OK?
	ERROR	(ELOOP,13,BLT2,B,BLT,LAST WORD XFER'D INCORRECTLY,PXDISP)
	JRST	.BLT		;DO NEXT CASE


; **********************************************************************
;*.XBLT - TEST OF 'PXCT N,[EXTEND A,[XBLT]]'>
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[EXTEND A,[XBLT]]'>

.XBLT:	MOVEI	.
	MOVEM	TESTPC
	MOVE	P,TESTP		;GET A GOOD VALUE OF P

	AOS	A,CASE		;GET NEXT CASE NUMBER
	CAML	A,CASTAB(TN)	;SEE IF DONE
	RTN			;Y

	GO	CLRPGS		;CLEAR EXTRA PAGES

	SETZM	PFHSPC		;ASSUME REGULAR PF HANDER

	IDIVI	A,XBLNTL	;DIV BY NUMBER OF N'S TO TEST
	MOVE	B,XBLNTB(B)	;GET AN 'N' TO TEST
	MOVEM	B,PXCTN		;SAVE N

	SETZ	B,		;READY B TO GET TWO BITS
	LSHC	A,-2		;MOVE BITS TO B
	ROT	B,2		;RIGHT JUSTIFY IN B
	MOVEM	B,BLTYPE	;SAVE BLT TYPE

	IDIVI	A,XBLTBL	;DIVIDE BY XBLT LENGTH-TAB LENGTH
	MOVE	B,XBLTAB(B)	;GET A LENGTH TO USE
	MOVEM	B,XBLAC1	;SAVE IT.

	IDIVI	A,NSECS
	MOVE	B,SECTAB(B)
	MOVEM	B,XBSRCS	;GET SOURCE SECTION NUMBER

	IDIVI	A,NSECS
	MOVE	B,SECTAB(B)
	MOVEM	B,XBDSTS	;GET DESTINATION SECTION

	GO	SETCXT		;SETUP PREVIOUS CONTEXTS

			; ******************************
ELOOP=.			;PLACE TO LOOP BACK TO ON ERROR
			; ******************************

	MOVE	A,[EXTEND 1,VEA] ;GET INSTR TO TEST
	MOVEM	A,PXCTEA	;SAVE AT PXCT'S EA

	MOVE	A,[XBLT]	;GET SUB INSTR TO TEST
	MOVEM	A,PEA		;SAVE AT EXTEND'S EA

	MOVE	A,PXCTN		;GET N TO TEST
	DPB	A,[POINT 4,PXCTIN,12] ;PUT IN PXCT INSTR

	MOVE	B,BLTYPE	;GET BLT TYPE
	HLRZ	A,BLACWD(B)	;GET FROM ADDR
	HRL	A,XBSRCS	;GET SECTION NUMBER
	MOVEM	A,XBLAC2	;SAVE SRC ADDR

	HRRZ	B,BLACWD(B)	;GET "TO" ADDR
	HRL	B,XBDSTS	;GET SECTION NUMBER
	MOVEM	B,XBLAC3	;SAVE DST ADDR

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREV CXT
	TRNE	A,1B<11+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU BIT
	SETZ	T3,		;CURRENT CXT
	MOVEM	T3,SRCCXT	;SAVE SRC CXT

	MOVEI	A,PS1		;USE SRC PAGE
	LDB	B,[POINT 12,XBLAC2,17] ;GET SECTION NUMBER
	LDB	C,[POINT 9,XBLAC2,26] ;GET PAGE NUMBER
	GO	PMAPRT		;MAP THE PAGE

	MOVE	A,XBLAC2	;GET AC2
	AOS	A		;GET SRC+1
	TRZ	A,777		;CLEAR WORD ADDR
	CAMN	A,XBLAC2	;SEE IF WE CHANGED PAGE NUMBER
	JRST	.XBL05		;NO

	LDB	B,[POINT 12,A,17] ;YES, GET SECTION NUMBER
	CAIG	B,37		;ILL SECTION NUMBER?
	JRST	.XBL04		;NO, OK

	MOVEI	C,S0PFIN	;GET ADR OF SPECIAL PF HANDLER
	MOVEM	C,PFHSPC	;SAVE FOR PFH ROUTINE
	JRST	.XBL05		;DON'T MAP IN ILLEGAL PAGE

.XBL04:	LDB	C,[POINT 9,A,26] ;GET PAGE NUMBER
	MOVEI	A,PS2		;MAP TO SECOND SRC PAGE
	GO	PMAPRT		;DO THE MAP

.XBL05:	LDB	B,[POINT 12,XBLAC3,17] ;GET SECTION NUMBER
	LDB	C,[POINT 9,XBLAC3,26] ;GET PAGE NUMBER
	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREV CXT
	TRNE	A,1B<12+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU BIT
	SETZ	T3,		;CURRENT CXT
	MOVEM	T3,DSTCXT	;SAVE DST CXT

	MOVEI	A,PD1		;USE DST PAGE
	GO	PMAPRT		;MAP THE PAGE

	MOVE	A,XBLAC3	;GET DST ADR
	AOS	A		;DST ADR+1
	TRZ	A,777		;CLEAR WORD ADDR
	CAMN	A,XBLAC3	;SEE IF WE CHANGED PAGE NUMBER
	JRST	.XBL06		;NO

	LDB	B,[POINT 12,A,17] ;YES, GET SECTION NUMBER
	CAIG	B,37		;ILL SEC NUM?
	JRST	.XBL07		;NO, OK

	MOVEI	A,S0PFIN	;GET ADR OF SPECIAL PF HANDLER
	MOVEM	A,PFHSPC	;SAVE FOR PFH ROUTINE
	JRST	.XBL06		;DONT MAP ILL PAGE

.XBL07:	LDB	C,[POINT 9,A,26] ;GET PAGE NUMBER
	MOVEI	A,PD2		;MAP TO SECOND DST PAGE
	GO	PMAPRT		;DO THE MAP

.XBL06:	SKIPGE	D,XBLAC1	;GET LEN AND SKIP IF NOT NEG
	MOVN	D,XBLAC1	;ELSE GET ABSOLUTE VALUE

	JUMPE	D,XBLNOC	;SETUP FOR ZERO LEN TEST

	MOVE	A,XBLAC2	;GET SRC ADDR TO A
	MOVE	E,XBLAC3	;DST TO E

.XBL11:	LDB	B,[POINT 12,A,17] ;GET SECTION NUMBER
	CAILE	B,37		;SKIP IF OK
	JRST	.XBL12		;ELSE DON'T WRITE TO THAT ADR

	GO	RANDOM		;GET A RANDOM VALUE
	MOVE	B,0		;GET TO B
	MOVE	C,SRCCXT	;SOURCE CONTEXT
	GO	CXWRIT		;WRITE TO CORRECT MEMORY

.XBL12:	AOS	A		;NEXT A
	EXCH	A,E		;GET DST, SAVE SRC

	LDB	B,[POINT 12,A,17] ;GET SECTION NUMBER
	CAILE	B,37		;SKIP IF OK
	JRST	.XBL13		;ELSE DON'T WRITE TO THAT ADR

	GO	RANDOM		;GET A RANDOM VALUE
	MOVE	B,0		;GET IT TO B
	MOVE	C,DSTCXT	;DESTINATION CONTEXT
	GO	CXWRIT		;WRITE IT

.XBL13:	AOS	A		;NEXT ADDR
	EXCH	A,E		;GET SRC, SAV DST
	SOJG	D,.XBL11	;LOOP TILL DONE

	JRST	.XBL22

XBLNOC:	GO	RANDOM		;GET A VALUE
	MOVE	B,0		;GET IT TO B
	MOVE	A,XBLAC3	;GET ADDR OF DESTINATION
	MOVE	C,DSTCXT	;GET THE CONTEXT
	GO	CXWRIT		;WRITE THE VALUE

.XBL22:	SKIPL	XBLAC1		;NEGATIVE?
	JRST	.XBL23		;NO

	MOVN	A,XBLAC1	;Y, GET ABS VALUE
	ADDM	A,XBLAC2	;START AT 'END+1' OF SRC BLOCK
	ADDM	A,XBLAC3	;START AT 'END+1' OF DST BLOCK

.XBL23:	MOVE	B,XBLAC1	;GET LENGTH FOR MOVE
	MOVEM	B,EXECAC+1	;WRITE TO EXEC AC 1

	MOVE	B,XBLAC2	;GET SRC ADDR
	MOVEM	B,EXECAC+2	;WRITE TO EXEC AC 2

	MOVE	B,XBLAC3	;GET DESTINATION ADDR
	MOVEM	B,EXECAC+3	;WRITE TO EXEC AC 3

	HLRZ	A,XBLAC2	;GET SECTION NUMBER OF SRC ADDR
	CAIL	A,40		;ILLEGAL?
	JRST	XBLT1B		;Y, SETUP SPECIAL RETURN ADDR

XBLT1A:	HLRZ	A,XBLAC3	;GET SECTION NUMBER OF DST ADDR
	CAIGE	A,40		;ILLEGAL?
	JRST	.XBLT2		;NO

XBLT1B:	MOVEI	A,S0PFIN	;SPECIAL PF HANDLER
	MOVEM	A,PFHSPC	;SAVE ADDR FOR PFH ROUTINE
	SETZM	PFFLAG		;CLR FLAG

; **************************************************

.XBLT2:	GO	DOPXCT		;DO THE PXCT
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,XBLT,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.XBLT		;DO NEXT CASE

	MOVE	A,XBLAC2	;GET SRC ADDR
	MOVEM	A,SVAC2		;SAVE A COPY OF AC2

	MOVE	A,XBLAC3	;GET DST ADDR
	MOVEM	A,SVAC3		;SAVE A COPY OF AC3

	SKIPGE	D,XBLAC1	;LENGTH NEGATIVE?
	JRST	.XBLT4		;GO COMPARE BACKWARDS

.XBLT3:	MOVE	A,SVAC2		;GET SRC ADR TO READ
	MOVE	C,SRCCXT	;GET CONTEXT
	GO	CXREAD		;GET CONTENTS
	PUT	B		;SAVE RESULT

	MOVE	A,SVAC3		;GET A DST ADDR
	MOVE	C,DSTCXT	;GET CONTEXT
	GO	CXREAD		;GET CONTENTS

	GET	A		;SRC IN A, DST IN B
	JUMPE	D,NOCHG		;IF LEN IS ZERO, SHOULD BE DIFFERENT
	CAMN	A,B		;ELSE SHOULD BE THE SAME
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,A,B,XBLT,CORRECT DATA NOT TRANSFERRED,PXDISP)
	JRST	.XBLT		;DO NEXT CASE

	AOS	SVAC2		;INCR SRC ADDR
	LDB	B,[POINT 12,SVAC2,17] ;GET SECTION
	CAILE	B,37		;STILL VALID?
	JRST	.XBLT		;NO

	AOS	SVAC3		;INCR DST ADDR
	LDB	B,[POINT 12,SVAC3,17] ;GET SECTION
	CAILE	B,37		;STILL VALID?
	JRST	.XBLT		;NO

	SOJG	D,.XBLT3	;LOOP TILL DONE

	JRST	.XBLT		;NEXT CASE

.XBLT4:	SOS	A,SVAC2		;GET SRC ADDR TO READ
	MOVE	C,SRCCXT	;GET SRC CONTEXT
	LDB	B,[POINT 12,A,17] ;GET SECTION
	CAILE	B,37		;STILL VALID?
	JRST	.XBLT		;NO, OK DONE.

	GO	CXREAD		;READ THE LOC
	PUT	B		;SAVE RESULT

	SOS	A,SVAC3		;GET DST ADDR TO READ
	MOVE	C,DSTCXT	;GET CONTEXT TO READ IN
	LDB	B,[POINT 12,A,17] ;GET SECTION
	CAILE	B,37		;STILL VALID?
	JRST	.XBLT		;NO, OK DONE.

	GO	CXREAD		;READ DST
	GET	A		;SRC IN A, DST IN B
	CAMN	A,B		;SHOULD BE THE SAME
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,A,B,XBLT,CORRECT DATA NOT TRANSFERRED,PXDISP)
	JRST	.XBLT		;NEXT CASE

	AOJL	D,.XBLT4	;LOOP TILL DONE

	JRST	.XBLT		;NEXT CASE

NOCHG:	CAMN	A,B		;SHOULD BE DIFFERENT
	ERROR	(ELOOP,13,A,B,XBLT,ZERO LENGTH XBLT CHANGED DESTINATION,PXDISP)
	JRST	.XBLT		;DO NEXT CASE


; **********************************************************************
;*.PUSH - TEST OF 'PXCT N,[PUSH A,Y]'
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[PUSH A,Y]'>

.PUSH:	MOVEI	.
	MOVEM	TESTPC
	MOVE	P,TESTP		;GET A GOOD VALUE OF P

	AOS	A,CASE		;GET NEXT CASENUMBER
	CAML	A,CASTAB(TN)	;SEE IF DONE
	RTN			;Y

	GO	CLRPGS		;CLEAR EXTRA PAGES

	IDIVI	A,2		;GET INDEX INTO 'N' TABLE DATA
	MOVE	B,[4
		   14](B)	;PXCT 'N' IS EITHER 4 OR 14 FOR THIS TEST
	MOVEM	B,PXCTN		;SAVE 'N' TO TEST
	DPB	B,[POINT 4,PXCTIN,12] ;PUT IN PXCT INSTR

	GO	SETCXT		;SETUP PREVIOUS CONTEXTS

.PUSH0:	IDIVI	A,AMODLN	;GET ADDR MODE TO TRY
	MOVEM	B,TMOD		;SAVE TEST ADDR MODE

			; ******************************
ELOOP=.			;PLACE TO LOOP BACK TO ON ERROR
			; ******************************

	MOVE	B,TMOD		;RECOVER INCASE LOOPING
	MOVEI	A,AMODTB(B)	;GET ADDR OF INSTR TO BE TESTED
	MOVE	C,(A)		;GET ADDR MODE TO BE TESTED
	MOVEM	C,PXCTEA	;SETUP @ PXCT'S EA

	MOVEI	C,<PUSH>_-^D27	;GET OPCODE FOR PUSH INSTR
	DPB	C,[POINT 9,PXCTEA,8] ;DEPOSIT OPCODE

; ************************************************
;SETUP FOR EFFECTIVE ADDRESS CALCULATION
; ************************************************

	SETOM	SETFLG		;NOTE WE'RE SETTING UP

	MOVEI	C,10		;VALUE FOR INDEX REGISTER
	MOVEM	C,EXECAC+B	;SAVE IN EXEC AC BLOCK

	MOVE	C,PXCTN		;GET 'N'
	HRL	A,CCS		;START IN CURRENT CONTEXT SECTION
	TRNE	C,1B<9+23>	;SKIP IF CURRENT CONTEXT EA CALC
	HRL	A,PCS		;ELSE USE PCS

	TLZ	A,(1B1)		;ASSUME CURRENT CONTEXT FOR EACALC
	TRNE	C,1B<9+23>	;BUT NOT IF PXCT BIT 9 = 1
	TLO	A,(1B1)		;USE PREVIOUS CONTEXT

	GO	CASECK		;SEE IF THIS CASE VALID FOR SECTION-0
	 JRST	.PUSH		;N, SEC-0 & GLOBAL ADDRESSING CASE

	GO	AMAP		;MAP IN ADDR MODE PAGE

	GO	EACALC		;DO EA CALC TO SETUP ADDR CHAINS
	MOVEM	A,PEA		;SAVE INSTR'S EA

	SETZM	SETFLG		;CLEAR SET FLAG

	GO	RANDOM		;GET A RANDOM NUMBER
	MOVEM	0,PQ		;SAVE FOR EA OF MOVE INSTR
	MOVEM	0,OLDSRC	;SAVE SRC DATA

; ************************************************
;CALC MAPPING FOR DATA PAGE
; ************************************************

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREVIOUS
	LDB	B,[POINT 12,PEA,17] ;GET GLOBAL VIRT SECTION FROM EA
	SETZM	PCSSUB#		;CLEAR SUBSTITUTION FLAG
	TRNN	A,1B<10+23>	;CHECK N BIT FOR PREV CXT
	JRST	.PSH10		;CURRENT CONTEXT FOR DATA REF

	SKIPN	PCU		;CHECK PCU BIT FOR PREV CXT USER
	SETZ	T3,		;NO, EXEC

.PSH10:	SKIPN	LOCGBL		;IS EA GLOBAL OR LOCAL?
	JRST	.PSH20		;GLOBAL, DON'T DO SUBSTITUTION

	CAIE	A,4		;IS PXCT-N EQUAL TO DATA REF ONLY CASE?
	JRST	.PSH20		;NO, DON'T DO SUBSTITUTION

	MOVE	B,PCS		;GET PREVIOUS CXT SECTION
	SETOM	PCSSUB		;NOTE WE SUBSTITUTED PCS FOR DATA REF

.PSH20:	HRLM	B,PXDEA		;SAVE SECTION FOR PXDISP TO PRINT
	MOVE	C,PEA		;GET ADDRESS
	HRRM	C,PXDEA		;SAVE FOR PXDISP TO PRINT

	MOVEI	C,<VQ_-9>	;GET VIR PAG NUM
	MOVEI	A,PQ		;GET PHYS ADR
	GO	PMAPRT		;MAP IN PAGE

; ************************************************
;CALC MAPPING FOR ADDR CHAIN PAGE
; ************************************************

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREVIOUS
	TRNE	A,1B<9+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU
	SETZ	T3,		;NO, CURRENT CONTEXT

	HRR	B,CCS		;ASSUME CURRENT CONTEXT SECTION
	TRNE	A,1B<9+23>	;CHECK 'N' BIT
	HRR	B,PCS		;NO, PREVIOUS

	MOVEI	A,AMOD		;GET ADDR OF ADDR CHAIN PAGE
	MOVEI	C,AMODPN	;GET PAGE NUMBER
	GO	PMAPRT		;MAP IN THE ADDR MODE PAGE

	GO	RANDOM		;GET A VALUE FOR STK OF PUSH INSTR
	MOVEM	0,OLDDST	;SAVE WHAT DST VAL WAS
	MOVEM	0,PD1+101	;SETUP PREVIOUS DESTINATION CONTENTS

	MOVSI	T3,1		;ASSUME PREV CXT
	TRNE	A,1B<12+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU BIT
	SETZ	T3,		;NO, CURRENT CONTEXT
	MOVEM	T3,DSTCXT	;SAVE DESTINATION CONTEXT

	MOVEI	A,PD1		;GET ADDR OF PHYS PAGE
	SKIPN	B,DSTSEC	;GET SECTION IF NON-ZERO
	MOVE	B,CCS		;ELSE USE CURRENT SECTION

	MOVEI	C,VD1PN		;GET VIRT PAGE NUM
	GO	PMAPRT		;MAP A PAGE

	HRLZ	B,DSTSEC	;GET DESTINATION SECTION
	SKIPN	B		;SKIP IF NON-ZERO W/ GLOBAL SECTION
	HRLZI	B,-2		;NEGATIVE COUNT FOR LOCAL PTR

	HRRI	B,VD1+100	;CURRENT END OF STACK
	MOVEM	B,OLDSP		;SAVE OLD SP
	MOVEM	B,EXECAC+A	;WRITE AC

	SKIPN	DSTSEC		;SEE IF DESTINATION SECTION IS ZERO
	ADD	B,[1,,0]	;IF SO, INCR LH (STK LEN)

	AOS	B		;NOW INCR END-OF-STK ADDR
	MOVEM	B,NEWSP		;SAVE WHAT AC SHOULD BE AFTER PUSH

.PUSH1:	SETZM	PFHSPC		;CLR SPECIAL PF HANDLER ADDR

	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101

	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;GO DO PXCT
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,PUSH,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.PUSH		;DO NEXT CASE

	MOVE	A,PQ		;GET THE VALUE OF THE SRC FIELD
	CAMN	A,PD1+101	;SEE IF STACK CHANGED
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,PQ,PD1+101,PUSH,FAILED TO CHANGE STACK,PXDISP)
	JRST	.PUSH		;DO NEXT CASE

	MOVE	A,EXECAC+1	;GET NEW VAL FOR SP
	CAMN	A,NEWSP		;SEE IF CORRECT
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,NEWSP,A,PUSH,INCORRECT STACK PTR AFTER PUSH,PXDISP)
	JRST	.PUSH		;NEXT CASE

	GO	RANDOM		;GET A RANDOM VALUE
	MOVEM	0,PQ		;CHG DESTINATION LOC

	MOVEI	C,<POP>_-^D27	;GET OPCODE FOR POP
	DPB	C,[POINT 9,PXCTEA,8] ;SET IT

; **********************************************************************
;*.PUSH2 - TEST OF 'PXCT N,[POP A,Y]'
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[POP A,Y]'>

.PUSH2:	SETZM	PFHSPC		;NO PF EXPECTED

	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101

	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;REWRITE DATA TO MEMORY
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,POP,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.PUSH		;DO NEXT CASE

	MOVE	A,OLDSRC	;GET ORIGINAL SRC DATA
	CAME	A,PQ		;SEE IF IT GOT REWRITTEN CORRECTLY

	ERROR	(ELOOP,13,OLDSRC,PQ,POP,MEM DATA INCORRECT,PXDISP)
	JRST	.PUSH		;DO NEXT CASE

; **********************************************************************
;*.LDB - TEST OF 'PXCT N,[LDB A,Y]'
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[LDB A,Y]'>

.LDB:	MOVEI	.
	MOVEM	TESTPC
	MOVE	P,TESTP		;GET A GOOD VALUE OF P

	AOS	A,CASE		;GET NEXT CASE NUMBER
	CAML	A,CASTAB(TN)	;SEE IF DONE
	RTN			;Y

	GO	CLRPGS		;CLEAR EXTRA PAGES
	IDIVI	A,LBLNTL	;DIV BY NUM OF 'N'S TO TEST
	MOVE	B,LBLNTB(B)	;GET AN 'N'
	MOVEM	B,PXCTN		;SAVE IT

			; ******************************
ELOOP=.			;PLACE TO LOOP BACK TO ON ERROR
			; ******************************

	IDIVI	A,BMODLN/2	;GET ADDR MODE FOR BYTE PTR
	MOVEM	B,BPMOD		;SAVE IT

	IDIVI	A,AMODLN	;GET ADDR MODE FOR INSTR
	MOVEM	B,TMOD		;SAVE IT

	MOVEI	A,AMODTB(B)	;GET ADDR OF INSTR TO BE TESTED
	MOVE	C,(A)		;GET ADDR MODE TO BE TESTED
	MOVEM	C,PXCTEA	;SAVE AT PXCT'S EA

	MOVE	B,BPMOD		;GET INDEX INTO BYTE PTR TABLE
	LSH	B,1		;TIMES 2, CAUSE 2 WD ENTRIED
	DMOVE	B,BMODTB(B)	;GET DBL WORD BYTE PTR
	DMOVEM	B,PQ		;SAVE AT PQ,PQ+1

	MOVEI	C,<LDB>_-^D27	;GET OPCODE
	DPB	C,[POINT 9,PXCTEA,8] ;PUT IN INSTR TO BE TESTED

	SETOM	SETFLG		;NOTE WE'RE SETTING UP ADDR CHAINS

	MOVEI	C,10		;VALUE FOR INDEX REGISTER
	MOVEM	C,EXECAC+2	;SET IT
	GO	CASECK		;SEE IF VALID CASE
	 JRST	.LDB		;N, SEC-0 & GLOBAL CASE

	GO	AMAP		;MAP IN ADDR CHN PAGE

	GO	EACALC		;SETUP ADDR CHAINS
	MOVEM	A,PEA		;SAVE INSTR'S EA

	MOVE	A,PXCTN		;GET 'N'
	DPB	A,[POINT 4,PXCTIN,12] ;PUT IN PXCT INSTR
	MOVSI	T3,1		;ASSUME PREV CXT
	TRNE	A,1B<10+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU BIT
	SETZ	T3,		;NO, CURRENT CONTEXT
	MOVEM	T3,BPCXT	;SAVE BYTE PTR CONTEXT

	MOVEI	A,PQ		;GET PHYS ADDR
	LDB	B,[POINT 12,PEA,17] ;GET SECTION NUMBER FROM EA
	MOVEM	B,BPSEC		;SAVE BYTE PTR SECTION

	MOVEI	C,VQ_-9		;VIRTUAL PAG NUM
	GO	PMAPRT		;MAP IN PAGE

	MOVE	A,PQ		;GET BYTE PTR
	TLNN	A,(1B12)	;SEE IF LOCAL/GLOBAL WORD
	JRST	LDBLOC		;LOCAL

	SKIPE	BPSEC		;SKIP IF SECTION ZERO
	SKIPA	A,[[Z VQ+1]]	;USE GLOBAL WORD INSTEAD

LDBLOC:	MOVEI	A,VQ		;GET ADDR OF BYTE PTR
	GO	EACALC
	MOVEM	A,PEA		;SAVE EA CALC

	SETZM	BPLG		;ASSUME GLOBAL
	TLZE	A,(1B0)		;CLEAR AND CHECK LOCAL/GLOBAL FLAG
	SETOM	BPLG		;NO, LOCAL

	MOVEM	A,BPEA		;SAVE BYTE PTR'S EA
	SETZM	SETFLG		;DONE SETTING UP

	MOVEI	A,VS1		;ADDR OF SOURCE DATA PAGE
	HLRZ	B,BPEA		;GET SECTION NUMBER FROM BYTE PTR'S EA
	LDB	C,[POINT 9,BPEA,26] ;GET VIR PAG NUM FROM BP EA
	GO	PMAPRT		;MAP IN THAT PAGE

	MOVE	A,PXCTN		;GET 'N'
	MOVSI	T3,1		;ASSUME PREV CXT
	TRNE	A,1B<12+23>	;CHECK 'N' BIT
	SKIPN	PCU		;CHECK PCU BIT
	SETZ	T3,		;NO, CURRENT CONTEXT
	MOVEM	T3,SRCCXT	;SAVE BYTE PTR CONTEXT

	GO	RANDOM		;GET A RANDOM WORD
	MOVEM	0,BPDATA	;INIT THE WORD
	MOVEM	0,OLDSRC	;ALSO SAVE A COPY FOR LATER

	HLLZ	A,PQ		;GET LH OF BP
	HRRI	A,BPDATA	;POINT TO DATA
	MOVEM	A,BP		;SAVE A COPY OF THE BYTE PTR

	LDB	B,A		;GET THE BYTE THAT WILL RESULT
	MOVEM	B,BPBYTE	;SAVE THE BYTE

.LDB2:	SETZM	PFHSPC		;NO SPECIAL PFHANDLER

	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101
	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;DO THE PXCT
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,LDB,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.LDB		;DO NEXT CASE

	MOVE	A,EXECAC+A	;GET C(AC)
	CAMN	A,BPBYTE	;SEE IF OK
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,BPBYTE,EXECAC+A,LDB,FAILED TO LOAD CORRECT DATA,PXDISP)
	JRST	.LDB		;DO NEXT CASE

	MOVE	A,OLDSRC	;GET ORIGINAL SOURCE DATA
	CAMN	A,BPDATA	;SEE IF LDB CHANGED DATA
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,OLDSRC,BPDATA,LDB,CHANGED SOURCE DATA,PXDISP)
	JRST	.LDB		;DO NEXT CASE

; **********************************************************************
;*.DPB - TEST OF 'PXCT N,[DPB A,Y]'
; **********************************************************************
								SALL
T=SIXBTZ	<'PXCT N,[DPB A,Y]'>

.DPB:	MOVEI	C,<DPB>_-^D27	;GET OPCODE
	DPB	C,[POINT 9,PXCTEA,8] ;PUT IN INSTR
	MOVE	A,BP		;GET BYTE PTR

CHGBYT:	GO	RANDOM		;GET A RANDOM WORD
	DPB	0,A		;CHANGE DESTINATION CONTENTS

	MOVE	A,BPDATA	;FIND OUT WHAT THE WORD LOOKS LIKE
	CAMN	A,OLDSRC	;DID IT CHANGE?
	JRST	CHGBYT		;NO

	SETZM	PFHSPC		;NO SPECIAL PF HANDLER

	MOVEI	B,10		;USER GETS 10
	MOVEI	C,101		;EXEC GET 101
	MOVE	A,PXCTN		;GET 'N' BIT
	TRNE	A,1B<9+23>	;SEE IF EACALC IN PREVIOUS CONTEXT
	SKIPN	PCU		;CHECK PCU BIT
	EXCH	B,C		;EXEC GETS 10 IF -(PCU AND 'N'BIT)

	MOVEM	C,EXECAC+B	;SET EXEC VALUE
	MOVEM	B,PACBLK+B	;SAVE USER AC

; **************************************************

	GO	DOPXCT		;DO THE PXCT
	JRST	.+4		;OK, AVOID ERROR CALL

; **************************************************

	ERROR	(ELOOP,13,0,0,DPB,UNEXPECTED PAGE FAULT,PXDISP)
	JRST	.LDB		;DO NEXT CASE

	MOVE	A,BPDATA	;GET DESTINATION
	CAMN	A,OLDSRC	;BACK TO ORIGINAL VALUE?
	JRST	.+4		;OK, AVOID ERROR CALL

	ERROR	(ELOOP,13,OLDSRC,BPDATA,DPB,DID NOT WRITE BYTE CORRECTLY,PXDISP)
	JRST	.LDB		;DO NEXT CASE

	MOVE	A,EXECAC+A	;GET BYTE
	CAME	A,BPBYTE	;STILL OK?

	ERROR	(ELOOP,13,BPBYTE,EXECAC+A,DPB,CHANGED SOURCE AC,PXDISP)
	JRST	.LDB		;DO NEXT CASE

SUBTTL	SUPPORT ROUTINES
								SALL
; **********************************************************************
;*EACALC - EXTENDED EFFECTIVE ADDRESS CALCULATION
;*
;*	ENTER WITH EFFECTIVE ADDRESS (IN A) OF INSTRUCTION FORMAT WORD (IFW)
;*	 TO WHICH THE EFFECTIVE ADDRESS CALCULATION IS TO BE APPLIED, AND
;*	 BITS 0,1 SET ACCORDINGLY.
;*
;*	B0(A)=1 => PREVIOUS CONTEXT FOR FETCH OF IFW
;*	B1(A)=1 => PREVIOUS CONTEXT FOR EFFECTIVE ADDRESS CALCULATION OF IFW
;*
;*	RETURNS+1 ALWAYS, EFFECTIVE ADDRESS IN A(6-35), AND LOCAL/GLOBAL SET
;*	 ACCORDINGLY IN A(0) (1=LOCAL, 0=GLOBAL)
; **********************************************************************

EACALC:	PUT	B		;SAVE B
	PUT	C		;SAVE C

	MOVEM	A,XEA		;INIT EA SECTION TO CURRENT SECTION

	LDB	C,[POINT 1,A,0]	;GET CONTEXT FOR IFW FETCH
	GO	XXREAD		;DO CONTEXT-READ TO GET IFW TO B

	SETZB	C,CHNPTR	;INIT CHAIN TABLE INDEX

	HRRZM	B,CHNTAB+0	;SAVE FETCHED WD IN TABLE

	TLZ	A,770000	;CLEAR EXTRA BITS
	HLLM	A,CHNTAB+0	;SAVE SECTION NUMBER FETCHED FROM

	SETZM	CHNCHR+0	;SEPARATE WITH SLASH

	MOVEI	A,INDMAX	;MAX INDIRECT CHAIN LENGTH
	MOVEM	A,INDCNT	;STORE COUNT-DOWN VALUE

	MOVE	A,XEA		;RESTORE A
	LDB	C,[POINT 1,A,1]	;GET CONTEXT FOR IFW EA CALC
	MOVEM	C,EACCXT	;SAVE EACALC CONTEXT

	MOVE	F,GOODF		;MAKE SURE WE HAVE A GOOD F
	TLNN	F,(KLXTST)	;IS THIS AN EXTENDED ADDR TEST?
	SETZM	XEA		;NO, SET SECTION ZERO

LOCL00:	TLO	C,(LOCREF)	;SET LOCAL REFERENCE FLAG
	LDB	A,[POINT 4,B,17] ;GET INDEX FIELD
	MOVEM	A,X		;SAVE IN X

	LDB	A,[POINT 1,B,13] ;GET INDIRECT BIT
	MOVEM	A,I		;SAVE IN I

	HRRE	A,B		;SIGN EXTEND 18 BIT Y FIELD
	MOVEM	A,Y		;SAVE IN Y

	SKIPN	A,X		;READY ADDR, SKIP IF NON-ZERO NDX
	JRST	LOCL03		;ELSE NO INDEXING

	MOVE	B,EXECAC(A)	;READ EXEC INDEX REGISTER
	MOVEM	B,X		;X NOW HAS C(X)

	AOS	A,CHNPTR	;GET NEXT CHAIN TABLE ADDR
	MOVEM	B,CHNTAB(A)	;SAVE FETCHED WD IN TABLE
	SETOM	CHNCHR(A)	;SEPARATE WITH PLUS SIGN

	LDB	A,[POINT 12,XEA,17] ;GET EA SECTION NUMBER
	JUMPE	A,LOCL02	;SECTION 0 FORCES LOCAL REFERENCE

	HLRZ	A,X		;GET LH(X)
	JUMPG	A,GLBL02	;POSITIVE LH(X) IS GLOBAL REFERENCE

LOCL02:	HRRZ	A,X		;GET 18-BIT INDEX REG VALUE
	ADD	A,Y		;CALC X+Y
	SKIPA			;SKIP OVER NO INDEXING ENTRY

LOCL03:	MOVE	A,Y		;GET DISPLACEMENT
	HRRM	A,XEA		;SAVE 18-BIT ADDR (WRAP-AROUND)

ICHECK:	SKIPN	I		;SKIP IF INDIRECTION
	JRST	EADONE		;ELSE DONE, GO CLEANUP

	SOSGE	INDCNT		;CHECK INDIRECT LEVEL

	FATALE	<INDIRECT CHAIN TOO LONG> ;MORE THAN INDMAX

	LDB	A,[POINT 30,XEA,35] ;GET 30 BIT ADDRESS
	GO	XXREAD		;DO SPECIAL CONTEXT READ

	AOS	A,CHNPTR	;GET NEXT CHAIN TABLE ADDR
	MOVEM	B,CHNTAB(A)	;SAVE FETCHED WD IN TABLE
	SETZM	CHNCHR(A)	;SEPARATE WITH SLASH

	LDB	A,[POINT 12,XEA,17] ;GET SECTION FROM EA
	JUMPE	A,LOCL00	;LOCAL IF SECTION 0

	LDB	A,[POINT 1,B,1]	;GET INDIRECT BIT
	MOVEM	A,I		;SAVE IN I

	JUMPGE	B,GLBL00	;GLOBAL IF B0 CLEAR

	SKIPN	I		;SEE IF PGFAIL
	JRST	LOCL00		;B(01)=10 MEANS LOCAL REFERENCE

	FATALE	<IMPROPER INDIRECT WORD> ;B(01)=11 MEANS PAGE-FAIL-TRAP

GLBL00:	TLZ	C,(LOCREF)	;NOTE GLOBAL ADDRESS

	LDB	A,[POINT 4,B,5]	;GET INDEX REG FIELD
	MOVEM	A,X		;SAVE IN X

	LDB	A,[POINT 30,B,35] ;GET DISPLACEMENT (Y FIELD)
	MOVEM	A,Y		;SAVE IN Y

	SKIPN	A,X		;READY ADDR, CHECK FOR ZERO
	JRST	GLBL03		;NO INDEXING

	MOVE	B,EXECAC(A)	;READ EXEC INDEX REGISTER
	AOS	A,CHNPTR	;GET NEXT CHAIN TABLE ADDR
	MOVEM	B,CHNTAB(A)	;SAVE FETCHED WD IN TABLE
	SETOM	CHNCHR(A)	;SEPARATE WITH PLUS SIGN

	MOVEM	B,X		;X NOW HAS C(X)

GLBL02:	LDB	A,[POINT 30,X,35] ;GET 30 BIT INDEX REG VALUE
	ADD	A,Y		;CALC X+Y
	SKIPA			;SKIP OVER NO INDEXING ENTRY

GLBL03:	MOVE	A,Y		;GET DISPLACEMENT
	DPB	A,[POINT 30,XEA,35] ;SAVE 30 BIT GLOBAL EA
	JRST	ICHECK		;GO CHECK INDIRECT BIT

EADONE:	LDB	A,[POINT 30,XEA,35] ;GET EA TO A
	TLNE	C,(LOCREF)	;SKIP IF GLOBAL
	TLO	A,(LOCREF)	;ELSE SET LOCAL

	GET	C		;RESTORE C
	GET	B		;RESTORE B

	SETZM	LOCGBL		;ASSUME GLOBAL
	TLNE	A,(LOCREF)	;SKIP IF GLOBAL
	SETOM	LOCGBL		;ELSE NOTE LOCAL

	RTN			;RETURN+1

; **********************************************************************
;*XXREAD - SPECIAL CXREAD FOR SETTING UP MAPPINGS
;*
;*	ENTER W/ ADR IN A, CONTEXT IN C (C=0 => CURRENT), EXIT W/RESULT IN B
;*	 THIS ROUTINE WORKS LIKE CXREAD, BUT ALSO SETS UP ADDR MODE CHAINS IN
;*	 DIFFERENT SECTIONS
; **********************************************************************

XXREAD:	SKIPN	SETFLG		;ARE WE SETTING UP ADDRESSING?
	PJRST	CXREAD		;NO, DO NORMAL CXREAD

	PUT	A		;SAVE ADDRESS

	TLNE	A,(7740B17)	;SKIP IF VALID SECTION NUMBER
	FATALE	<INVALID SECTION NUMBER>

	TLZE	A,(37B17)	;CLR SECTION AND SKIP IF ZERO
	JRST	XXR2		;ELSE WE NEED TO WRITE BACK TO DIFF SEC

	SKIPE	EACCXT		;CHECK EACALC CXT
	SKIPN	PCU		;AND PREV CXT USER FOR BOTH SET
	SKIPA			;NOT BOTH SET, WRITE BACK TO SAME SEC
	JRST	XXR2		;BOTH, WRITE TO DIFF SECTION

	GO	EMAP		;MAP EXEC VIRTUAL TO PHYSICAL ADDRESS
	FATALE	<INVALID MAPPING>

	MOVE	B,(A)		;OK TO DO IF SECT-0
	GET	A		;RESTORE ADDR
	RTN			;DONE

XXR2:	GO	EMAP		;MAP EXEC VIRTUAL TO PHYSICAL ADDRESS
	FATALE	<INVALID MAPPING>

	MOVE	B,(A)		;READ FROM SECTION-0

	PUT	C		;SAVE C
	PUT	B		;SAVE B

	MOVE	B,-2(P)		;GET GOOD ADDR
	TLZ	B,(777740B17)	;CLEAR HI ORDER BITS
	LSH	B,-9		;ALIGN PAG NUMBER
	LSHC	B,-9		;GET PAGE TO C
	LSH	C,-^D27		;RJ IN C
	MOVSI	T0,-NPAGES	;NUMBER PAGES TO LOOK AT

FFFF1:	SKIPN	PUSE+P1PN(T0)	;CHECK FOR BUSY
	JRST	FFFF2		;FREE!

	AOBJN	T0,FFFF1	;KEEP TRYING TILL DONE

	FATALE	<CAN'T FIND A FREE PAGE>

FFFF2:	HRRZI	A,P1PN(T0)	;USE FIRST FREE PAGE
	LSH	A,9		;MAKE CORE ADDRESS

	MOVE	T3,EACCXT	;MAP USER OR EXEC?
	SKIPN	PCU		;SKIP IF PREVIOUS WAS USER
	SETZ	T3,		;ELSE USE EXEC

	GO	PMAPRT		;GO MAKE A PAGE MAP ENTRY

	MOVE	A,-2(P)		;GET ADDR
	MOVE	B,0(P)		;GET DATA
	MOVE	C,EACCXT	;GET CONTEXT
	GO	CXWRIT		;SEE THAT DATA IS WRITTEN CORRECTLY

	GET	B		;RESTORE DATA
	GET	C		;RESTORE C
	GET	A		;RESTORE A
	RTN			;DONE

; **********************************************************************
;*CXREAD - CONTEXT READ...
;*
;*	ENTER W/ ADR IN A, CONTEXT IN C (C=0 => CURRENT), EXIT W/RESULT IN B
; **********************************************************************

CXREAD:	TLNE	A,(7740B17)	;INSURE VALID EA (SEC.LE.37)
	FATALE	<PAGEFAIL-SECTION.GT.37>

	SKIPE	C		;SKIP IF CURRENT CONTEXT
	PJRST	PRVCXT		;NO, DO PREVIOUS CONTEXT FETCH

; ************************************************
;EXREAD - EXECUTIVE READ REFERENCE
; ************************************************

EXREAD:	TDNE	A,[36,,777760]	;SKIP IF AC REFERENCE
	JRST	CURMEM		;NO, MEMORY READ

; ************************************************
;CURACS - EXECUTIVE AC REFERENCE
; ************************************************

CURACS:	MOVE	B,EXECAC(A)	;USE AS INDEX INTO EXEC AC TABLE
	RTN			;DONE

; ************************************************
;CURMEM - EXECUTIVE MEMORY REFERENCE
; ************************************************

CURMEM:	PUT	A		;SAVE ADDRESS

	GO	EMAP		;MAP VIRT TO PHYS
	FATALE	<INVALID MAPPING>

	MOVE	B,(A)		;READ FROM 'EXEC' MEMORY
	GET	A		;RESTORE ADDRESS
	RTN			;DONE

; ************************************************
;PRVCXT - USER READ REFERENCE
; ************************************************

PRVCXT:	TDNE	A,[36,,777760]	;AC REFERENCE?
	PJRST	PRVMEM		;NO, MEM REF
	PJRST	PREVAC		;GET PREVIOUS CONTEXT AC

; ************************************************
;CXWRIT - CONTEXT WRITE
; ************************************************

CXWRIT:	TLNE	A,(7740B17)	;INSURE VALID EA
	FATALE	<PAGEFAIL-SECTION.GT.37>

	SKIPE	C		;SKIP IF CURRENT CONTEXT
	PJRST	PRVCWR		;NO, PREVIOUS

; ************************************************
;EXWRIT - EXECUTIVE WRITE REFERENCE
; ************************************************

EXWRIT:	TDNE	A,[36,,777760]	;SKIP IF AC REFERENCE
	JRST	CURMWR		;NO, MEM WRITE

; ************************************************
;CRACWR - EXECUTIVE AC WRITE REFERENCE
; ************************************************

CRACWR:	MOVEM	B,EXECAC(A)	;INDEX INTO EXEC AC STASH
	RTN			;DONE

; ************************************************
;CURMWR - EXECUTIVE MEMORY WRITE REFERENCE
; ************************************************

CURMWR:	PUT	A		;SAVE ADDRESS

	GO	EMAP		;MAP VIRT TO PHYS
	FATALE	<INVALID MAPPING>

	MOVEM	B,(A)		;WRITE TO 'EXEC' MEMORY
	GET	A		;RESTORE ADDRESS
	RTN			;DONE

; ************************************************
;PRVCWR - PREVIOUS CONTEXT WRITE REFERENCE
; ************************************************

PRVCWR:	TDNN	A,[36,,777760]	;AC REF?
	PJRST	PACWR		;YES, PREVIOUS AC WRITE

; ************************************************
;PMWR - PREVIOUS MEMORY WRITE REFERENCE
; ************************************************

PMWR:	SKIPN	PCU		;SKIP IF PREVIOUS CXT USER
	JRST	EXWRIT		;ELSE DO EXEC REFERENCE

	PUT	A		;SAVE ADDR

	GO	UMAP		;MAP VIRT TO PHYSICAL
	FATALE	<INVALID MAPPING>

	MOVEM	B,(A)		;WRITE TO MEMORY
	GET	A		;RESTORE A
	RTN			;DONE

; ************************************************
;PACWR - PREVIOUS AC WRITE REFERENCE
; ************************************************

PACWR:	TDNE	A,[36,,777760]	;AC REF?
	FATALE	<ILLEGAL AC NUMBER>

	MOVEM	B,PACBLK(A)	;WRITE TO AC BLK
	RTN			;DONE

; ************************************************
;PREVAC - PREVIOUS AC READ REFERENCE
; ************************************************

PREVAC:	TDNE	A,[36,,777760]	;AC REF?
	FATALE	<ILLEGAL AC NUMBER>

	MOVE	B,PACBLK(A)	;READ FROM AC BLK
	RTN

; ************************************************
;PRVMEM - PREVIOUS MEMORY READ REFERENCE
; ************************************************

PRVMEM:	SKIPN	PCU		;SKIP IF PREVIOUS WAS USER
	JRST	EXREAD		;ELSE DO EXEC CONTEXT READ

	PUT	A		;SAVE ADDR

	GO	UMAP		;MAKE PHYSICAL ADDRESS
	FATALE	<INVALID MAPPING ENCOUNTERED>

	MOVE	B,(A)		;READ FROM 'USER' MEMORY
	GET	A		;RESTORE ADR
	RTN			;DONE

; **********************************************************************
;*KLPSET - KL PAGING INITIALIZATION ROUTINE
;*
;*	THIS ROUTINE INITIALIZES PAGING. ALL PAGE TABLES ARE CLEARED
;*	 ALSO ALL MICROCODE VERSION DEPENDENT LOCATIONS (EPT,UPT) ARE ACCESSED
;*	 THRU INDIRECT POINTERS SETUP HERE.
; **********************************************************************

KLPSET:	CONO	PAG,0		;INSURE PAGING IS OFF

; ************************************************
;CLR SOME UPT LOCS
; ************************************************

	SETZM	UPT+500		;CLR PAGEFAIL LOCS
	MOVE	A,[UPT+500,,UPT+501] ;BLT PTR
	BLT	A,UPT+503	;CLR UPT+500 TO UPT+503

	SETZM	UPT+424		;CLR 1ST WORD
	MOVE	A,[UPT+424,,UPT+425] ;BLT PTR
	BLT	A,427		;CLR MUUO BLK

; ************************************************
;SETUP INDIRECTS FOR KLA/KLB/KLL/KLX DIFFERENCES
; ************************************************

	MOVEI	A,UPT+500	;ADDR OF PAGEFAIL WORD
	MOVE	F,GOODF		;INSURE GOOD F
	TLNN	F,(KL10X)	;SINGLE SECTION KL?
	ADDI	A,1		;Y, BUMP ADDR OF PAGE FAIL STUFF

	MOVEM	A,PFWP		;SET PAGE FAIL WORD POINTER
	ADDI	A,1		;POINT TO PG FAIL OLD PC
	MOVEM	A,PFXJP		;SAVE XJRSTF PTR

	TLNE	F,(KLXTST)	;IS THIS EXTENDED HDW+SW?
	ADDI	A,1		;BUMP OVER FLAG WD
	MOVEM	A,PFOPP		;SET IT

	ADDI	A,1		;POINT TO PG FAIL NEW PC
	MOVEM	A,PFNPP		;SET IT

	MOVEI	A,UPT+424	;GET ADDR OF MUUO OPCODE
	TLNN	F,(KLAKLB)	;KLA OR KLB?
	ADDI	A,1		;N, ADJUST ADDR
	MOVEM	A,MCODP		;SAVE ADDR

	ADDI	A,1		;GET ADDR OF MUUO-OLD PC
	MOVEM	A,MOPP		;SAVE IT

	ADDI	A,1		;GET ADDR OF MUUO-EA
	MOVEM	A,MADP		;SAVE MUUO EA

	MOVEI	A,UPT+540	;POINT TO SECTION POINTERS
	TLNE	F,(KLAKLB)	;KLA OR KLB?
	MOVEI	A,UPT+440	;Y, DIFFERENT PLACE
	MOVEM	A,USECP		;SAVE USER SECT ADDR

	MOVEI	A,EPT+540	;POINT TO SECTION POINTERS
	TLNE	F,(KLAKLB)	;KLA OR KLB?
	MOVEI	A,EPT+440	;Y, DIFFERENT PLACE
	MOVEM	A,ESECP		;SAVE EXEC SECT PTR

; ************************************************
;CLEAR OUT ALL THE PAGE TABLES.
; ************************************************

	GO	CLRPGS		;CLEAR THE PAGE TABLES

; ************************************************
;INITIALIZE CST AND MAP ALL USED SECTION 0 PAGES TO THEMSELVES
; ************************************************

	MOVSI	A,770000	;WORD FOR EVERY CST ENTRY
	MOVSI	C,(ACCESS)	;LEFT HALF FOR PAGE TABLE ENTRIES
	MOVSI	B,-1000		;NUMBER OF PAGES TO SETUP

; ************************************************
;SETUP PAGE TABLE ENTRIES
; ************************************************

PTLUP:	MOVEM	A,CST(B)	;INITIALIZE A CST ENTRY

;	HRRM B,PUSE(B)		;SET PUSE TABLE TOO
;	HRRM B,MAP0(B)		;INITIALIZE EXEC SEC 0 PAGE TABLE ENTRY
;	HLLM C,MAP0(B)		;AND ITS LEFT HALF

	AOBJN	B,PTLUP		;LOOP UNTIL ALL ENTRIES MADE.

	GO	CLRPGS		;CLEAR PAGING TABLES

; ************************************************
;SET UP CST MASK, DATA, AND BASE REGISTERS
; ************************************************

	DATAI	PAG,A		;GET AC BLOCK INFO.
	TLZ	A,(7B8)		;CLEAR AC BLOCK NUMBER.
	TLO	A,(<REVBLK>B8)	;SET CURRENT AC BLOCK TO RESERVED ONE.
	MOVEM	A,RESDAT	;SAVE WORD FOR ACCESSING RESERVED AC BLK

	TDZ	A,[7B8+17777]	;CLEAR AC BLOCK AND UBR FIELD
	TDO	A,[<MYACS>B8+UPTPN] ;SET UP DATAO PAGE WORD
	MOVEM	A,UPWD		;REMEMBER NEW DATA

	DATAO	PAG,RESDAT	;TELL HARDWARE TO USE RESERVED BLK

	HRROI	CSTMSK,-1	;PUT ALL 1'S IN CST MASK WORD
	MOVEI	CSTDAT,0	;PUT 0 IN CST DATA WORD

	SETZ	SPTBR,		;NO SPT (ALL PTRS IMMEDIATE)

	MOVEI	CBR,CST		;PUT CST ADDRESS IN CST BASE REGISTER

	DATAO	PAG,UPWD	;GET BACK TO OUR AC'S AND SET UPT

; ************************************************
;INITIALIZE MUUO HANDLER
; ************************************************

	MOVEI	A,MUUOH		;GET ADDRESS OF MUUO HANDLER
	MOVEM	A,UUONPC	;STORE IT WHERE COMPUTER WANTS IT.

	MOVE	A,[UUONPC,,UUONPC+1]
	BLT	A,UUONPC+7	;ONE OF 8 LOCATIONS ARE FETCHED

; ************************************************
;SET UP PAGE FAULT HANDLER ADDRESS
; ************************************************

	XMOVEI	A,PFH		;GET ADDRESS OF PAGE FAULT HANDLER
	MOVEM	A,@PFNPP	;STORE IT WHERE MACHINE WANTS IT.
	RTN			;DONE


; **********************************************************************
;*CLRPGS - CLEAR PAGING TABLES
; **********************************************************************

CLRPGS:	PUT	A
	PUT	B		;SAVE SOME AC'S

	SETZM	MAP0
	MOVE	A,[MAP0,,MAP0+1]
	BLT	A,<MAP1+NPAGES_9>-1	;CLEAR THE PAGE TABLES.

	SETZM	PUSE		;CLEAR 1ST WD
	MOVE	A,[PUSE,,PUSE+1] ;READY BLT PTR
	BLT	A,PUSE+777	;CLEAR OUT PAGE USE TABLE

; ************************************************
;CLOSE ALL SECTIONS BY REMOVING ALL POINTERS TO PAGE TABLES.
; ************************************************

	HRRZ	A,ESECP		;GET 0,,SEC0
	SETZM	(A)		;CLEAR SECTION 0 PTR

	HRLS	A		;GET SEC0,SEC0
	ADDI	A,1		;GET SEC0,SEC1
	BLT	A,36(A)		;TILL END

	HRRZ	A,USECP		;GET 0,,SEC0
	SETZM	(A)		;CLEAR SECTION 0

	HRLS	A		;GET SEC0,SEC0
	ADDI	A,1		;GET SEC0,SEC1
	BLT	A,36(A)		;TILL END

	GET	B		;RESTORE SOME AC'S
	GET	A
	RTN			;DONE

PFERR:	MOVE	0,@PFWP		;GET PAGE FAIL WORD
	MOVEM	0,SAVPFW	;SAVE FOR PGM TO USE

	MOVE	0,@PFOPP	;GET PC OF PF
	MOVEM	0,SAVPFS	;SAVE FOR PGM TO USE

	GET	0		;RESTORE AC 0
	MOVE	P,XXP		;RESTORE P

	SETOM	PFIGNR		;NOTE CASE FAILED
	SETOM	ERRFLG		;AND NOTE ERROR

	SKIPE	PFHSPC		;ANY SPECIAL ROUTINE?
	JRST	@PFHSPC		;GO TO IT

	JRST	S0FIX1		;GO DO ERROR RTN TO PGM

MUUOH2:	MOVEM	P,XXP		;SAVE P
	MOVE	P,EMER.P	;USE EMERGENCY P

	PUT	A		;DON'T CLOBBER ANY AC'S
	PUT	B

	MOVE	B,MCODP		;POINT TO OPCODE
	HRLI	B,111100	;MAKE BYTE PTR
	LDB	A,B		;GET THE OPCODE
	GET	B		;RESTORE B

	CAIE	A,<GOEXEC>_-^D27	;DO WE RECOGNIZE IT ??
	JRST	BADUUO		;NO, BAD

	MOVE	A,@MCODP	;GET THE FLAGS FROM WHENCE WE CAME
	TLZ	A,(USRBIT)	;TURN OFF USER MODE
	MOVEM	A,@MCODP	;AND REPLACE

	GET	A		;RESTORE AC
	MOVE	P,XXP		;RESTORE P
	XJRSTF	@MCODP		;RETURN TO PGM IN EXEC MODE

; **********************************************************************
;*BADUUO - HERE FOR UNRECOGNIZED UUO
; **********************************************************************
								SALL
BADUUO:	ERROR1	13,0,0,BAD MUUO,,BADUO1
	FATAL

BADUO1:	PMSGF	< TEST PC = >
	MOVE	TESTPC
	PNTOCF

	PMSGF	<^ MUUO = >
	MOVE	@MCODP
	PNTHWF

	PMSG	<, MUUO PC = >
	MOVE	@MOPP
	PNTHWF

	PCRLF
	RTN

; **********************************************************************
;*DOPXCT - ROUTINE TO DO PXCT
;*
;*	THIS IS THE ROUTINE THAT ACTUALLY SETS UP FOR THE PXCT INSTR. IT
;*	 MAPS IN ITSELF, AS WELL AS THE ACTUAL PXCT INSTR. ALSO, VARIOUS
;*	 AC TRANSACTIONS ARE PERFORMED.  RETURN AFTER PXCT INSTR IS TO 'S0FIX'.
; **********************************************************************
								LALL
	.PGE PXDO		;PAGE ALIGN
								SALL
DOPXCT:	SETZM	ERRFLG		;CLEAR ERROR

	HRR	A,CCS		;CURRENT CONTEXT SECTION
	MOVEI	B,VPXPN		;GET PXCT TEST PAGE NUMBER
	ROT	B,-9		;LEFT JUSTIFY
	ROTC	A,^D18		;MAKE ADDR OF PXCT INSTR
	MOVEM	A,PXCTAD	;SAVE ADDR

	MOVE	A,PCS		;SETUP PCS IN XJRSTF FLAG WORD
	HRRM	A,PXCTGO	;NEEDED FOR MICROCODE VER. 214

	MOVEI	A,PX		;PHYS ADDR
	HRR	B,CCS		;CURRENT CONTEXT SECTION
	MOVEI	C,VPXPN		;VIRT PAG NUM
	SETZ	T3,		;EXEC ADDR SPACE

	GO	PMAPRT		;SETUP PAGE MAP FOR PXCT PAGE

	SETZM	PFIGNR		;INIT IGNORE CASE FLAG
	MOVEI	A,.		;ADDRESS OF THIS PAGE
	SETZ	B,		;SECTION ZERO MAPPING
	MOVEI	C,<._-9>	;THIS PAGE NUMBER
	SETZ	T3,		;EXEC CONTEXT

	GO	PMAPRT		;MAP THIS PAGE

	DATAO	PAG,USRACB	;SET TO ACCESS PREVIOUS AC BLK

	MOVE	0,[PACBLK+1,,1]
	BLT	0,17		;LOAD 1 TO 17
	MOVE	0,PACBLK	;LOAD 0

	DATAO	PAG,CURACB	;SET TO EXEC AC BLK

	MOVEM	0,SAVACS+0	;SAVE 0
	MOVE	0,[1,,SAVACS+1]
	BLT	0,SAVACS+17	;SAVE THE ACS

	MOVE	0,[EXECAC+1,,1]
	BLT	0,17		;RESTORE AC'S
	MOVE	0,EXECAC	;RESTORE AC-0, TOO

	AOS	GCASEN		;INCR NUMBER OF CASES TRIED

	CONO	PAG,TRAPF+KLPAGF ;TURN ON PAGING
	XJRSTF	PXCTGO		;GO TO PXCT TEST

; ************************************************
;S0PFIN - RETURN TO SECTION ZERO AFTER EXECUTING PXCT
; ************************************************

S0PFIN:	CONO	PAG,0		;TURN OFF PAGING
	SETOM	PFFLAG		;NOTE WE HAD THIS PF

; ************************************************
;S0FIX - SECTION ZERO FIXUP ROUTINE, RETURN FROM EXECUTING PXCT
; ************************************************

S0FIX:	CONO	PAG,0		;TURN OFF PAGING

S0FIX1:	DATAO	PAG,USRACB	;ACCESS PREVIOUS AC BLK

	MOVEM	0,PACBLK	;SAVE 0
	MOVE	0,[1,,PACBLK+1]
	BLT	0,PACBLK+17	;SAVE 1 TO 17

	DATAO	PAG,CURACB	;RESET AC BLK NUMBERS

	MOVEM	0,EXECAC	;SAVE AC-0
	MOVE	0,[1,,EXECAC+1]
	BLT	0,EXECAC+17	;STORE ALL AC'S

	MOVE	0,[SAVACS+1,,1]
	BLT	0,17		;RESTORE ACS
	MOVE	0,SAVACS+0	;RESTORE 0 ALSO

	SKIPE	PFFLAG		;SPECIAL RETURN?
	RTN			;YES, EXPECTED PF RETURN

	SKIPE	PFIGNR		;SKIP IF CASE DIDN'T PF
	RTNSKP			;ERROR RETURN
	RTN			;ELSE GOOD RTN

PFHCNI:	0			;HOLDS CONI PAG, RESULT
PFHDTI:	0			;HOLDS DATAI PAG, RESULT
MUOCNI:	0			;HOLDS CONI PAG, RESULT
MUODTI:	0			;HOLDS DATAI PAG, RESULT

; **********************************************************************
;*MUUOH - MUUO HANDLER
; **********************************************************************

MUUOH:	CONI	PAG,MUOCNI	;SAVE CONI PAG, INFO
	CONO	PAG,0		;PAGING OFF

	DATAI	PAG,MUODTI	;SAVE DATAI PAG, INFO

	DATAO	PAG,CURACB	;INSURE CORRECT AC BLK, ETC
	JRST	MUUOH2		;GO TO REST OF MUUO HANDLER

; **********************************************************************
;*PFH - PAGE FAULT HANDLER
; **********************************************************************

PFH:	CONI	PAG,PFHCNI	;SAVE CURRENT INFO
	DATAI	PAG,PFHDTI

	CONO	PAG,0		;TURN OFF PAGING
	DATAO	PAG,CURACB	;INSURE CORRECT AC BLK, ETC

	MOVEM	P,XXP		;SAVE PF P
	MOVE	P,EMER.P	;USE EMERGENCY COPY OF P

	PUT	0		;SAVE AC-0

	HRRZ	0,@PFOPP	;GET PC OF ERROR
	CAIN	0,VPX+1		;SEE IF PXCT INSTR
	JRST	PFERR		;PAGE FAULT IS ERROR

	ERROR1	13,0,0,BAD PAGE FAIL,,PFH1
	FATAL
								SALL
PFH1:	PMSGF	<TEST PC = >
	MOVE	TESTPC
	PNTOCF

	PMSGF	<^ PFW = >
	MOVE	@PFWP
	PNTHWF

	PMSGF	<, PFPC = >
	MOVE	@PFOPP
	PNTHWF

	PCRLF

	GO	PXDISP		;SHOW WHAT CASE FAILED

	RTN

; **********************************************************************
;*PMAPRT - PAGE MAP ROUTINE
;*
;*	ENTER WITH PHYSICAL ADDR OF PHSICAL PAGE TO BE MAPPED IN A
;*	 VIRTUAL SECTION IN B, VIRTUAL PAGE NUMBER IN C,
;*	 AND CONTEXT (0=EXEC) IN T3
;*	ALL ACS ARE PRESERVED, AND MOST ARE USED.
; **********************************************************************

PMAPRT:	GO	SAV15		;SAVE 15 REGS
	PUT	C		;SAVE EXTRA COPY OF C,B,A
	PUT	B
	PUT	A

	MOVE	T2,A
	LSH	T2,-9		;GET PHYSICAL PAGE NUMBER BEING UNMAPPED
	SKIPN	A,PUSE(T2)	;PICK UP THE PAGE THAT WAS LAST HERE
	JRST	NREMOB		;IT WAS NEVER MAPPED, SO DON'T UNMAP IT

	MOVE	D,ESECP		;ASSUME EXEC MAPPING
	TLZE	A,(1B17)
	MOVE	D,USECP		;NO, USER MAPPING

	LSHC	A,-9		;SEPARATE SEC AND PAGE NUMBER OF OLD MAPPING.
	LSH	B,-^D27		;SECT IN A, PAGE IN B
	CAMN	D,ESECP		;SKIP IF NOT EXEC MAPPING
	JUMPE	A,NREMOB	;DON'T UNMAP EXEC SEC-0 PAGES

	ADD	D,A		;CREATE ADDRESS OF PAGE TABLE POINTER.
	MOVE	A,(D)		;PICK UP THE STARTING ADDR OF THE PG TBL
	LSH	A,9		;CHANGE TO CORE ADDRESS.
	ADD	A,B		;CREATE ADDRESS OF PAGE TABLE ENTRY.
	SETZM	(A)		;CLEAR OUT THE OLD ENTRY.

	MOVE	T4,PUSE(T2)	;PICK UP THE OLD MAPPING INFO.
	TRZ	T4,777		;KEEP ONLY THE USER BIT AND SECTION NUM

	MOVSI	E,-NPAGES	;READY TO LOOK FOR OTHER MAPPINGS
LK1:	MOVE	F,PUSE(E)	;PICK UP A MAPPING.
	TRZ	F,777		;CLEAR PAGE NUMBER.
	CAME	F,T4		;IS THIS A MAPPING IN THE SAME SECTION ?
	JRST	NOQ		;THIS ONE ISN'T THE SAME SECTION.

	CAIE	T2,(E)		;SAME ENTRY?
	JRST	NREMOB		;NO, SO SEC STILL IN USE

NOQ:	AOBJN	E,LK1		;KEEP LOOKING.

	SETZM	(D)		;NO OTHER PAGE USING THIS SECTION

NREMOB:	MOVE	T1,-1(P)	;RESTORE SECTION NUMBER
	CAIN	T3,0		;SKIP IF USER MAPPING
	ADD	T1,ESECP	;ADD IN ADDR OF EXEC SEC PTR

	CAIE	T3,0
	ADD	T1,USECP	;ADD IN ADDR OF USER SEC PTR

	MOVE	T1,(T1)		;GET ENTRY
	JUMPN	T1,GOTONE	;THIS SECTION ALREADY HAS A PAGE TABLE

	MOVSI	T2,-NPAGES	;IT DOESN'T, SO LOOK FOR A FREE MAP.
	MOVEI	T4,MAP1PN	;T4 HOLDS THE GOAL PAGE MAP PAGE NUMBER

CHKM1:	MOVSI	A,-40		;NUMBER OF SECTIONS TO CHECK.

CHKM3:	HRRZ	B,A		;GET INDEX INTO TABLE
	ADD	B,ESECP		;ADD IN ADDR OF EXEC SEC PTR

	HRRZ	B,(B)		;PICK UP A PAGE TABLE PAGE NUM.
	HRRZ	C,A		;GET INDEX INTO TABLE
	ADD	C,USECP		;ADD IN ADDR OF USER SEC PTR

	HRRZ	C,(C)		;GET USER ENTRY
	CAME	B,T4
	CAMN	C,T4
	JRST	CHKM2		;PAGE TABLE BUSY IF MATCH

	AOBJN	A,CHKM3		;CHK ALL PTRS TO INSURE TABLE IS FREE

	MOVE	T1,T4		;THIS TABLE IS A GOOD ONE. USE IT.
	JRST	GOTONE

CHKM2:	ADDI	T4,1		;TRY THE NEXT PAGE TABLE.

	AOBJN	T2,CHKM1	;LOOP TILL DONE

	FATALE	<TOO MANY PAGE TABLES IN USE>

; ************************************************
;GET READY TO MAP IN THE PAGE NOW.
; ************************************************

GOTONE:	SKIPE	T3		;SKIP IF CURRENT (EXEC)
	SKIPN	PCU		;SKIP IF PREVIOUS + USER
	TDZA	T3,T3		;CLEAR T3 AND SKIP ALWAYS
	MOVSI	T3,1		;PUT 1 IN LH(T3)

	MOVE	A,(P)		;RESTORE ADDR OF PHYS PAGE
	MOVE	B,-1(P)		;RESTORE SECTION NUMBER
	MOVE	C,-2(P)		;RESTORE VIRTUAL PAGE NUMBER

	SKIPE	T3		;USER?
	ADD	B,USECP		;ADD IN USER SEC PTR ADDR

	SKIPN	T3		;EXEC?
	ADD	B,ESECP		;ADD IN EXEC SEC PTR ADDR

	HRLI	T1,(ACCESS)	;GET BITS
	MOVEM	T1,(B)		;SETUP PTR TO PAGE TABLE

	MOVSI	D,770000	;READY CST ENTRY
	MOVEM	D,CST(T1)	;NOTE THAT PAGE TABLE IS IN CORE
	MOVEM	D,CST+0		;ALSO PAGE ZERO IN CORE

	LSH	T1,9		;MAKE PAGE TABLE CORE ADDRESS.
	ADD	T1,C		;T1 POINTS TO SPECIFIC PAGE TABLE WORD.

	LSH	A,-9		;MAKE PAGE TABLE CORE ADDR
	HRLI	A,(ACCESS)	;SETUP, WITH ACCESS
	MOVEM	A,(T1)		;UPDATE THE APPROPRIATE PAGE TABLE.

	GET	A		;RESTORE A,B,C
	GET	B
	GET	C

	LSH	A,-9		;MAKE PAGE NUMBER FROM ADDRESS
	LSH	B,9		;ALIGN
	MOVEM	T3,PUSE(A)	;STORE USER OR EXEC BIT IN PUSE TABLE.
	MOVEM	D,CST(A)	;NOTE THAT PHYSICAL PAGE IS IN CORE

	IORM	B,PUSE(A)	;STORE VIRTUAL SECTION NUMBER.
	IORM	C,PUSE(A)	;AND VIRTUAL PAGE NUMBER.

	GO	RES15		;GO RESTORE REGISTERS
	RTN			;DON'T CHG TO PJRST

; **********************************************************************
;*FATALP - HERE ON FATAL PGM ERROR TO PRINT PC AND MSG
; **********************************************************************

FATALP:	HRRZ	$SVUUO
	MOVEM	FATALA		;SAVE ARG

	ERROR1	13,0,0,FATAL PROGRAM ERROR,,FATAL1
	FATAL
								SALL
FATAL1:	PMSGF	<TEST PC = >
	MOVE	TESTPC
	PNTOCF

	PMSGF	<^ ERROR PC = >
	HRRZ	$SVUPC		;GET PC
	PNTOCF			;SHOW IT

	PMSGF	<, >

	MOVE	FATALA		;GET ARG
	PNTALF			;PRINT REASON

	PCRLF
	RTN

; **********************************************************************
;*SAV15 - SAVE AC-0 TO AC-16 ON STACK
; **********************************************************************

SAV15:	ADJSP	P,^D14		;MAKE ROOM FOR 14 ACS
	PUT	-^D14(P)	;PUT RTN ADDR AT END OF STK

	DMOVEM	0,-^D15(P)	;SAVE 0,1
	DMOVEM	2,-^D13(P)	;SAVE 2,3
	DMOVEM	4,-^D11(P)	;SAVE 4,5
	DMOVEM	6,-9(P)		;SAVE 6,7
	DMOVEM	10,-7(P)	;SAVE 10,11
	DMOVEM	12,-5(P)	;SAVE 12,13
	DMOVEM	14,-3(P)	;SAVE 14,15
	MOVEM	16,-1(P)	;PUT 16 ON STACK
	RTN			;DONE

; **********************************************************************
;*RES15 - RECOVER AC-0 TO AC-16 FROM STACK
; **********************************************************************

RES15:	MOVE	16,-1(P)	;RESTORE 16
	DMOVE	14,-3(P)	;GET 14,15
	DMOVE	12,-5(P)	;GET 12,13
	DMOVE	10,-7(P)	;GET 10,11
	DMOVE	6,-9(P)		;GET 6,7
	DMOVE	4,-^D11(P)	;GET 4,5
	DMOVE	2,-^D13(P)	;GET 2,3
	DMOVE	0,-^D15(P)	;GET 0,1

	GET	-^D15(P)	;MOVE RTN ADDR
	ADJSP	P,-^D14		;FIX STK PTR
	RTN			;DONE

; **********************************************************************
;*PXDISP - PXCT PARAMETER DISPLAY ROUTINE
;*
;*	THIS ROUTINE IS USED TO DISPLAY THE CURRENT TEST CONDITIONS.
;*	AFTER DISPLAYING COMMON PARAMETERS, A SPECIAL DISPATCH IS MADE TO
;*	 SHOW INDIVIDUAL PARAMETERS (SUCH AS THE AC FOR STACK INSTRS).
; **********************************************************************

PXDISP:	SETOM	ERRFLG		;NOTE WE HAD AN ERROR
	AOS	ERRTLS		;COUNT NUMBER OF ERRORS

	PUT	0		;SAVE 0
	SKIPN	PFIGNR		;WAS PAGE FAULT CAUSE OF ERROR?
	JRST	PXDSP2		;NO

	SETZM	PFIGNR		;REMEMBER WE ALREADY SHOWED THE ERR

	PMSG	<PAGE FAIL WORD = >
	MOVE	SAVPFW		;TYPE PAGE FAIL WORD
	PNTHW

	PMSG	<, PC = >
	MOVE	SAVPFS		;TYPE PAGE FAIL SECTION
	PNTHW
	PCRL

PXDSP2:	PMSG	<PXCT-N]PCU]CCS]PCS]CASE]EXPECTED EA RESULT^>

	MOVE	PXCTN		;GET PXCT 'N'
	PNTOCS			;PRINT IT
	PNTCI	11

	MOVE	PCU		;PRINT PCU BIT
	PNTOCS
	PNTCI	11

	MOVE	CCS		;PRINT CCS
	PNTOCS
	PNTCI	11

	MOVE	PCS		;PRINT PCS
	PNTOCS
	PNTCI	11

	HRRZ	CASE		;PRINT CASE NUMBER
	PNTOCS
	PNTCI	11

	MOVE	PXDEA		;GET EA
	TLZ	770000		;CLEAR ANY HI ORDER BITS
	PNTHWF			;PRINT IT

	SKIPE	LOCGBL		;NOTE LOCAL OR GLOBAL
	PMSG	<GLOBAL^>
	SKIPN	LOCGBL
	PMSG	<LOCAL^>

	SKIPE	PCSSUB		;SKIP IF SUB NOT MADE
	PMSG	<NOTE: PCS SUBSTITUTED INTO EA BEFORE DATA REF^>

	GET	0		;RESTORE WORK AC
	MOVE	TN,SAVETN	;INSURE GOOD TEST COUNTER
	GO	XDISP(TN)	;DO SPECIAL PER TEST ROUTINE

DIECHK:	SKIPE	ERRDIE		;SEE IF SUPPOSED TO DIE
	FATAL			;YES, DO IT
	RTN			;NO, DONE

; ************************************************
;ADRCHN - SHOW ADDRESS CHAIN
; ************************************************

ADRCHN:	PUT	0		;SAVE 0
	PUT	A		;SAVE A

	SETZ	A,		;INIT CHN COUNTER TO BEGINNING OF TABLE
	PMSG	<ADDR CHN=>
	JRST	ADRCH2		;DON'T PRINT A COMMA AT THE BEGINNING

ADRLOP:	SKIPN	CHNCHR(A)
	PMSG	</ >		;SEPARATE WITH SLASH
	SKIPE	CHNCHR(A)	;SKIP IF SLASH CHAR
	PMSG	<+ >		;SEPARATE WITH PLUS SIGN

ADRCH2:	MOVE	0,CHNTAB(A)	;GET ELEMENT OF TABLE
	PNTHW			;PR IT

	CAMGE	A,CHNPTR	;SEE IF AT LAST ENTRY
	AOJA	A,ADRLOP	;NO, DO NEXT

	PCRL
	GET	A		;RESTORE A
	GET	0		;RESTORE 0
	RTN			;DONE

; **********************************************************************
;*SETCXT - SETUP PREVIOUS-CONTEXT-USER BIT AND
;*	PREVIOUS-CONTEXT-SECTION FIELD
; **********************************************************************

SETCXT:	IDIVI	A,NSECS
	MOVE	B,SECTAB(B)
	MOVEM	B,PCS		;GET A SECTION NUMBER FOR PREV CXT SEC

	SETZ	B,		;CLEAR B
	LSHC	A,-1		;MOVE ONE BIT TO B
	ROT	B,1		;RJ
	MOVEM	B,PCU		;SAVE USER/EXEC FLAG

	PUT	A		;SAVE A
	DATAI	PAG,A		;GET PAG INFO
	MOVEI	C,MYACS(B)	;GET RIGHT AC BLK NUMBER (USER OR EXEC)
	DPB	C,[PACB,,A]	;PUT IN A

	MOVE	C,PCS		;GET PREV CXT SECT
	DPB	C,[PCSHW,,A]	;SET PREV CXT SECT IN HW

	MOVEI	C,MYACS		;EXEC AC BLK NO
	DPB	C,[CACB,,A]	;PUT IN A

	TLZ	A,(1B2)		;NO LOAD UBR
	TDO	A,[1B1!1B18+UPTPN] ;LD AC BLKS, NO STOR ACCT AND UPT PAGE
	MOVEM	A,CURACB	;REMEMBER CORRECT CONTEXT

	MOVEI	C,USRACS	;USER AC BLK NO
	DPB	C,[CACB,,A]	;PUT IN A
	MOVEM	A,USRACB	;SAVE USR AC BLK DATAO PAG WD
	DATAO	PAG,CURACB	;SET PREVIOUS BLK NO

	GET	A		;RESTORE A
	JSP	C,.+1		;GET FLAGS TO C
	DPB	B,[350100,,C]	;SET B6 (PCU) ACCORDINGLY

	HRRI	C,[RTN]		;ADDR OF A RETURN INSTR
	HLLZM	C,PXCTGO	;SAVE FLAGS FOR PXCT INSTR

	JRSTF	@C		;SET PREV CXT BIT

; ************************************************
;MOVDSP - SPECIAL DISPLAY ROUTINE FOR MOVE
; ************************************************

MOVDSP:	PMSG	<(MOVE) >
	PJRST	ADRCHN		;GO PRINT ADDRESS CHAIN

; ************************************************
;BLTDSP - SPECIAL DISPLAY ROUTINE FOR BLT
; ************************************************

BLTDSP:	PUT	0		;SAVE 0
	PMSG	<(BLT) AC=>
	MOVE	BLTAC
	PNTHW			;PRINT BLTAC
	PCRL
	GET	0
	RTN

; ************************************************
;XBLDSP - SPECIAL DISPLAY ROUTINE FOR XBLT
; ************************************************

XBLDSP:	PUT	0		;SAVE 0

	PMSG	<AC1=>
	MOVE	XBLAC1		;GET XBLT AC1
	PNTHW

	PMSG	<AC2=>
	MOVE	XBLAC2		;AC2
	PNTHW

	PMSG	<AC3=>
	MOVE	XBLAC3		;AC3
	PNTHW
	PCRL

	GET	0
	RTN			;DONE

; ************************************************
;PUSDSP - SPECIAL DISPLAY ROUTINE FOR PUSH
; ************************************************

PUSDSP:	GO	ADRCHN		;SHOW ADR JUNK

	PUT	0
	PMSG	<OLDSP=>
	MOVE	OLDSP
	PNTHW

	PMSG	<NEWSP=>
	MOVE	NEWSP
	PNTHW
	PCRL

	GET	0
	RTN			;DONE

; ************************************************
;LDBDSP - SPECIAL DISPLAY ROUTINE FOR LDB
; ************************************************

LDBDSP:	GO	ADRCHN		;SHOW ADR CHN USED

	PUT	0
	PMSG	<BP=>
	MOVE	BP
	PNTHW
	PCRL

	GET	0
	RTN			;DONE

; **********************************************************************
;*CASECK - CHECK FOR SECTION-0 AND GLOBAL ADDRESSING CASE
;*
;*	THIS ROUTINE ELIMINATES SOME ILLEGAL CASES FROM THE TEST.
; **********************************************************************

CASECK:	LDB	B,[POINT 12,A,17] ;GET SECTION NUMBER FROM A
	JUMPN	B,CPOPJ1	;OK-SKP RETURN IF NON-ZERO

	MOVE	B,TMOD		;GET ADDR MODE CASE
	SKIPN	LGCASE(B)	;SKIP IF LOCAL/GLOBAL CASE
	RTN			;ELSE ERROR-NO SKP RETURN

	JRST	CPOPJ1		;OK-SKP RETURN

; **********************************************************************
;*UMAP - DO USER MAP OF VIRTUAL TO PHYSICAL, CHECKING ACCESS
; **********************************************************************

UMAP:	PUT	C		;SAVE WORK ACS
	MOVE	C,USECP		;GET ADDR OF SEC-0 PTR FOR USER ADDR
	JRST	COMMAP		;JOIN COMMON MAP ROUTINE

; **********************************************************************
;*EMAP - DO EXECUTIVE MAP OF VIRTUAL TO PHYSICAL, CHECKING ACCESS
; **********************************************************************

EMAP:	PUT	C		;SAVE WORK ACS
	MOVE	C,ESECP		;GET ADDR OF SEC-0 PTR FOR EXEC ADDR

COMMAP:	PUT	B
	LDB	B,[POINT 12,A,17] ;GET SECTION NUMBER
	CAILE	B,MAXSEC	;VALIED SECTION NUMBER?
	JRST	EMAPRR		;LOSE

	ADD	C,B		;GET ADDR OF CORRECT SECTION PTR
	MOVE	C,(C)		;GET SECTION PTR
	LDB	B,[POINT 9,C,8]	;GET ACCESS BITS
	CAIE	B,124		;AS EXPECTED?
	JRST	EMAPRR		;LOSE

	LDB	B,[POINT 9,C,35] ;GET PAGE NUMBER OF PAGE TABLE
	LSH	B,^D9		;MAKE MEM ADDR
	LDB	C,[POINT 9,A,26] ;GET PAGE NUMBER FROM ADDR
	ADD	C,B		;GET ADDR OF ENTRY
	MOVE	C,(C)		;GET PAGE TABLE ENTRY
	LDB	B,[POINT 9,C,8]	;GET ACCESS BITS
	CAIE	B,124		;AS EXPECTED?
	JRST	EMAPRR		;LOSE

	LDB	B,[POINT 9,C,35] ;GET PAGE NUMBER FROM ENTRY
	LSH	B,^D9		;MAKE MEM ADDR
	LDB	C,[POINT 9,A,35] ;GET WORD ADDR FROM ADDR
	ADD	C,B		;GET PHYSICAL ADDR OF LOCATION REQUESTED
	MOVE	A,C		;GET INTO A

	GET	B		;RESTORE WORK ACS
	GET	C
	RTNSKP			;DONE OK

; ************************************************
;HERE TO LOSE ON VIRT TO PHYS TRANSLATION.
; ************************************************

EMAPRR:	GET	B		;RESTORE WORK ACS
	GET	C
	RTN			;ERROR RETURN

; **********************************************************************
;*AMAP - MAP IN ADDR MODE TABLE
; **********************************************************************

AMAP:	PUT	A		;SAVE A,B,C,T3
	PUT	B
	PUT	C
	PUT	T3

	MOVEI	A,AMODTB	;PHYS ADDR
	SETZ	B,		;SECTION ZERO
	MOVEI	C,AMODPN	;VIRT PAGE NUM
	SETZ	T3,		;EXEC CXT

	GO	PMAPRT		;GO MAP IN ADDR MODE PAGE

	GET	T3		;RESTORE T3,C,B,A
	GET	C
	GET	B
	GET	A
	RTN			;DONE

; **********************************************************************
;*RANDOM - GENERATE PSEUDO-RANDOM NUMBERS
; **********************************************************************

RANDOM:	PUT	1		;SAVE WORK AC

	MOVE	0,RANDBS	;GET SEED
	MUL	0,RNDXXA	;RANDOM MULTIPLIER
	MOVE	0,1		;GET LO ORDER RESULT
	ADD	0,RNDXXC	;RANDOM CONSTANT
	MOVEM	0,RANDBS	;SAVE NEXT SEED

	GET	1		;RESTORE WORK AC
	RTN			;DONE

RNDXXA:	27320,,163055		;MUL CONSTANT
RNDXXC:	154145,,427233		;ADD CONSTANT

SUBTTL	STORAGE SPECIFIC TO THE PXCT TEST

PGMNAM:	ASCIZ\
DECSYSTEM KL10 PXCT DIAGNOSTIC [DFKEC]
\

; **********************************************************************
;*TEST DISPATCH AREA. PUT A 'RTN' HERE TO SKIP A TEST.
; **********************************************************************

TSTTAB:	JRST	%MOVE
	RTN			;JRST %BLT
	JRST	%XBLT
	JRST	%PUSH
	RTN			;JRST %LDB

TTABSZ=.-TSTTAB

%MOVE:	MOVEM	P,TESTP		;SAVE TEST P
	JRST	.MOVE

%BLT:	MOVEM	P,TESTP
	JRST	.BLT

%XBLT:	MOVEM	P,TESTP
	JRST	.XBLT

%PUSH:	MOVEM	P,TESTP
	JRST	.PUSH

%LDB:	MOVEM	P,TESTP
	JRST	.LDB

XDISP:	PJRST	MOVDSP		;SPECIAL DISPLAY ROUTINES
	PJRST	BLTDSP
	PJRST	XBLDSP
	PJRST	PUSDSP
	PJRST	LDBDSP

; **********************************************************************
;*THESE PTRS HOLD THE ADDRESS OF THE PTRS THAT ARE DIFFERENT IN DIFF
;* 	VERSIONS OF THE MICROCODE (MUUO/PGFAIL/SECTION PTRS).
; **********************************************************************

ESECP:	0			;HOLDS ADDR OF EXEC SECTION POINTERS
USECP:	0			;HOLDS ADDR OF USER SECTION POINTERS
MCODP:	0			;HOLDS ADDR OF MUUO OPCODE POINTER
MOPP:	0			;HLDS ADDR OF MUUO OLD-PC PTR
MADP:	0			;HOLDS ADDR OF MUUO EA PTR
PFWP:	0			;HOLDS ADDR OF PG FAIL WD PTR
PFXJP:	0			;EXTENDED XJRSTF PTR (FLAG WD)
PFOPP:	0			;HOLD ADR OF PG FAIL OLD-PC PTR
PFNPP:	0			;HOLDS ADR OF PG FAIL NEW-PC PTR
ERRFLG:	0			;-1 MEANS ERR OCCURED

; **********************************************************************
;*PXCTGO,PXCTAD - FLAGS AND ADDR OF A PXCT INSTR FOR XJRSTF
; **********************************************************************

PXCTGO:	0			;FLAGS
PXCTAD:	0			;A(PXCTBP)

;FROM HERE DOWN, MISC LOCATIONS, DESCRIBED INDIVIDUALLY
; **********************************************************************

FATAL0:	0			;HOLD 0 DURING FATAL ERROR
FATALA:	0			;HOLD ARGUMENT

SECTAB:	0			;DIFFERENT SECTIONS TO USE FOR TEST
	1
	2
	37
NSECS==.-SECTAB

BLTNTB:	1			;SRC
	4			;DST
	5			;SRC,DST
	14			;EA,DST
	15			;EA,SRC,DST
BLNTLN==.-BLTNTB		;LENGTH OF TABLE

XBLNTB:	2			;SRC
	1			;DST
	3			;SRC,DST
XBLNTL==.-XBLNTB

XBLTAB:	2			;POS LEN 2
	1			;POS LEN 1
	0			;ZERO LEN, NO MOVE
	-1			;NEG LEN 1
	-2			;NEG LEN 2
XBLTBL==.-XBLTAB

LBLNTB:	1			;DATA
	3			;BP-EA,DATA
	7			;BP,BP-EA,DATA
	17			;EA,BP,BP-EA,DATA
LBLNTL==.-LBLNTB

CCS:	PCSECT			;NON-ZERO SECTION NUMBER FOR PXCT INSTR
PCS:	0			;HOLDS PCS SECTION
BPSEC:	0			;BYTE PTR SECTION
BLEASC:	0			;HOLDS SECTION FOR BLT EA

BLSTOP:	G	0,20
	G	0,0
	G	0,VD1+1
	G	0,VD1+1

BLT1:	0			;HOLDS 1ST WD MOVED BY BLT
BLT2:	0			;HOLDS 2ND WD MOVED BY BLT
BLTYPE:	0			;HOLDS TYPE OF BLT BEING TESTED

BLACWD:	VS1,,17
	VS1,,-1
	17,,VD1
	-1,,VD1

BLTAC:	0			;HOLDS BLT'S AC CONTENTS
PFHACS:	BLOCK	2		;HOLDS A,B DURING PGFAIL HANDLE
PFHAC2:	BLOCK	2		;HOLDS B,C

CASE:	0			;CURRENT CASE COUNT
GCASEN:	0			;GRAND TOTAL CASE COUNTER

BPMOD:	0			;HOLDS ADDR MODE OF BYTE PTR
TMOD:	0			;GETS CURRENT ADDR MODE BEING TESTED
PXCTN:	0			;'N' IN 'PXCT N,FOO' GOES HERE

UPWD:	0			;FOR DATAO PAG,UPWD

PFFLAG:	0			;SET BY SPECIAL ENTRY POINT
PFHSPC:	0			;HOLDS ADR OF SPECIAL PF HANDLER
UUOSPF:	0			;HOLDS PC FLGS

UUPSPC:	0			;SPECIAL MUUO RET ADR
ALLOW1:	0			;-1 TO ALLOW 1 UNRECOGNIZED MUUO

XEA:	0			;GETS ENTIRE EFFECTIVE ADDRESS
X:	0			;GETS X FIELD DURING EA CALC
Y:	0			;GETS Y FIELD
I:	0			;GETS I FIELD

INDCNT:	0			;INDIRECT LEVEL COUNT-DOWN

PDATA:	0			;DATA FOR XFER TO/FROM PREV-AC-BLK
PRINS:	0			;HOLDS XFER INSTRUCTION
GOODF:	0			;HOLDS A GOOD COPY OF THE FLAGS

SAVETN:	0			;HOLD TN DURING TEST

SAVPFW:	0			;HOLDS PAGE FAIL WORD
SAVPFS:	0			;HOLDS PAGE FAIL SECTION

TESTP:	0			;HOLDS P DURING TEST.
GOODP:	0			;HOLDS A COPY OF VALID STK PTR

PRFLG:	0			;NOTES READ OR WRITE

CURNTA:	0			;HOLDS A DURING PREV CONTEXT REFS

SVAC2:	0			;SAVE EXTRA COPY OF XBLT'S AC2
SVAC3:	0			;SAVE EXTRA COPY OF XBLT'S AC3

USRACB:	0			;HOLDS DATAO WD FOR USER BLK

CURACB:	0			;CURRENT/PREVIOUS AC BLK FOR DATAO PAG

; **********************************************************************
;*EMER.P - THIS LOCATION HOLDS A STK PTR THAT WILL WORK WITHOUT DESTROYING
;*	THE REST OF THE STACK, AND WITHOUT KNOWING THE REAL STK PTRS' VALUE.
; **********************************************************************

EMER.P:	PLIST+150-PLISTE,,PLIST+150 

XXP:	0			;HOLDS P DURING PF HANDLE

PFIGNR:	0			;-1 MEANS CASE FAILED
ERRDIE:	0			;-1 MEANS GO TO DDT ON FAILURE

SAVACS:	BLOCK	^D16		;EXEC AC'S SAVED HERE
EXECAC:	BLOCK	^D16		;EXEC AC'S SAVED HERE
PACBLK:	BLOCK	^D16		;PREVIOUS AC BLK HERE

APRIDE:	0			;APRID DATA GOES HERE...

SETFLG:	0			;-1 WHEN SETTING UP ADDR CHAINS

RESDAT:	0			;GETS RESERVED DATA

PCU:	0			;USER (NOT EXEC) FLAG

DISFLG:	0			;WHETHER OR NOT TO PRINT A HEADING

XBSRCS:	0			;XBLT SRC SECTION
XBDSTS:	0			;XBLT DST SECTION
XBLAC1:	0			;XBLT LEN
XBLAC2:	0			;XBLT SRC ADR
XBLAC3:	0			;XBLT DST ADR

SRCPG1:	0			;HOLDS SRC PAGE 1 PAGE NUMBER
DSTPG1:	0			;HOLDS DST PAGE 1 NUMBER

SRCSEC:	0			;SRC SECTION
DSTSEC:	0			;DST SECTION

SRCADD:	0			;SOURCE ADDRESS
DSTADD:	0			;DST ADDRESS

EACCXT:	0			;HOLDS EACALC CONTEXT

SRCCXT:	0			;HOLDS SRC CXT
DSTCXT:	0			;HOLD DST CXT

OLDSRC:	0			;HOLDS CONTENTS OF SRC LOC
OLDDST:	0			;HOLDS CONTENTS OF DST LOC

OLDSP:	0			;HOLDS OLD VALUE OF AC BEFORE PUSH
NEWSP:	0			;HOLDS NEW VALUE FOR AC AFTER PUSH

LOCGBL:	0			;HOLDS LOCAL/GLOBAL OF INSTR'S EA

BPEA:	0			;BYTE PTR'S EA
BPCXT:	0			;BYTE PTR'S CONTEXT
BP:	0			;HOLDS A COPY OF THE PTR TO DATA
BPBYTE:	0			;HOLDS BYTE DATA
BPLG:	0			;BP'S LOCAL/GLOBAL FLAG

PXDEA:	0			;PLACE FOR EA FOR PXDISP TO READ IT

CHNPTR:	0			;PTR INTO CHNTAB
CHNTAB:	BLOCK	20		;RESERVE ROOM FOR ADDR CHAIN WDS
CHNCHR:	BLOCK	20		;RESERVE ROOM FOR SEPARATOR CHARACTER

; ************************************************
;BE SURE TO PUT ALL LITERALS HERE, SO NEXT LIT STATEMENT CAN PUT ALL
; ADDR MODE LITERALS ON SAME PAGE AS AMODTB.
; ************************************************

	LIT

; ************************************************
;PAGE STUFF - LEAVE ROOM FOR EACH PHYS PAGE
; ************************************************
								LALL
	.PGE PUSE
	.PGE UPT
	.PGE CST
								SALL
; **********************************************************************
;*TO TRACE, PUT A HALT INSTRUCTION IN PXCTBP. WHEN KL HALTS, TYPE:
;*	>. LP
;*	LP Y OR N ? - Y		;ANSWER Y TO TURN ON LPT
;*	>. FX0
;*	>. FX11
;*	>. FX12
;*	>. RP PL,ALL		;THIS WILL TRACE ALL UCODE STEPS
;*	>. ^C^C		 	;TO STOP, TYPE CTRL-C WHEN PC CHANGES
;*	>. LP
;*	LP Y OR N ? - N		;ANSWER N TO TURN OFF LPT
; **********************************************************************

; **********************************************************************
;*PXCTBP,PXCTIN - ACTUAL PXCT GOES HERE
; **********************************************************************
								LALL
	.PGE PX			;VIRTUAL PAGE IS PHYS PAGE +1
								SALL
PXCTBP:	JFCL			;HALT GOES HERE TO TRACE
PXCTIN:	PXCT	0,VPXEA		;EXECUTE THE INSTR IN PXCTEA
PXGOBK:	XJRSTF	VRET		;GO TO SECTION-0 ROUTINE
PXRET:	0			;FLAGS
PXRET2:	G	0,S0FIX		;ADDR OF SECTION ZERO ROUTINE
PXCTEA:	0			;INSTR TO BE PXCT'D GOES HERE
PEA:	0			;HOLDS INSTR'S EA

								LALL
	.PGE VPX		;VIRTUAL ADDR FOR PXCT
								SALL
VPXBP:	0			;THIS PAGE MAPS TO PREVIOUS PAGE
VPXIN:	0
VPXGO:	0
VRET:	0
VRET2:	0
VPXEA:	0
VEA:	0
								LALL
	.PGE VQ			;VIRTUAL ADDR FOR Q

	.PGE PHQ		;PHYSICAL PAGE FOR Q
PQ:	0			;DATA GOES HERE

	.PGE BMOD		;BYTE PTRS HERE
								SALL

BMODTB:	POINT	7,VS1+333,20	;LOCAL
	0
	060640,,0		;GLOBAL
	VS1+333
BMODLN==.-BMODTB		;LENGTH
								LALL
	.PGE AMOD		;PUT EA CHAINS IN DIFF SECTION
								SALL
; **********************************************************************
;*AMODTB - ADDRESSING MODE TABLE
;*
;*	HERE IS THE TABLE OF ALL THE ADDRESSING MODES USED.
; **********************************************************************

AMODTB:	Z	A,VQ
	Z	A,VQ-10(B)	;-10(B) IS BECAUSE B WILL CONTAIN '10'
	Z	A,@[L VQ]
	Z	A,@[L VQ-10(B)]
	Z	A,@[L VQ]-10(B)
	Z	A,@[L @[L VQ]]
	Z	A,@[L @[G 0,VQ]]
	Z	A,@[L @[G 0,VQ-10(B)]]
	Z	A,@[G 0,VQ]
	Z	A,@[G 0,VQ-10(B)]
	Z	A,@[G 0,@[L VQ]]
	Z	A,@[G 3,@[L VQ]]
	Z	A,@[G 0,@[L VQ]-10(B)]
	Z	A,@[G 36,@[G 3,VQ]]
AMODLN==.-AMODTB
	BLOCK	10		;LEAVE EXTRA ROOM

; **********************************************************************
;*LGCASE - HERE IS THE TABLE STATING WHETHER OR NOT THE ADDRESS GOES
;*	GLOBAL IN THE AMODTB TABLE.
;*	THIS IS A PARALLEL TABLE, AND SHOULD BE UPDATED TOO.
; **********************************************************************

LGCASE:	REPEAT	6,<-1>		;-1 MEANS LOCAL/GLOBAL
	REPEAT	^D8,<0>		;0 MEANS GLOBAL ONLY

	IFN	<.-LGCASE-AMODLN>,<PRINTX LCGASE AND AMODTB NOT SAME LENGTH>

	LIT			;PUT ADDRESS CHAIN LITERALS IN SAME PAGE

; **********************************************************************
;*CASTAB - HERE IS THE TABLE CONTAINING THE NUMBER OF CASES TO TRY FOR
;*	EACH INSTRUCTION.
; **********************************************************************

CASTAB:	2*NSECS*2*AMODLN			;CASES FOR MOVE
	NSECS*NSECS*2*2*2*BLNTLN		;CASES FOR BLT
	NSECS*NSECS*NSECS*XBLTBL*2*2*2*XBLNTL	;CASES FOR XBLT
	2*NSECS*2*AMODLN			;CASES FOR PUSH
	NSECS*NSECS*2*AMODLN*BMODLN		;CASES FOR LDB

; ************************************************
;*PAGE STORAGE
; ************************************************
								LALL
	.PGE MAP0
	.PGE MAP1
	.PGE MAP2
	.PGE MAP3
	.PGE MAP4
	.PGE MAP5
	.PGE MAP6
	.PGE MAP7
	.PGE MAPX

	.PGE P1
	.PGE P2
	.PGE P3
	.PGE P4
	.PGE P5
	.PGE P6
	.PGE P7
	.PGE VD1		;VIRTUAL DESTINATION PAGE 1
	.PGE PD1		;PHYS DEST PAGE 1
	.PGE VS1		;VIRTUAL SRC PAGE 1
BPDATA==.

	.PGE PS1		;PHYS SRC 1
	.PGE VD2		;VIRT DST 2
	.PGE PD2		;PHYS DST 2
	.PGE VS2		;VIRT SRC 2
	.PGE PS2		;PHYS SRC 2
	.PGE FOO		;FOR STUFF THAT IS DEFINED AFTER HERE...
								SALL
 