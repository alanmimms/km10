SUBTTL	ARITHMETIC/RANDOM/INTERRUPT/MEMORY RELIABILITY TEST

;SIMULATOR -DDT- INITIALIZATION SEQUENCE

SIMDDT:	JRST	SIMPNT			;GO TO SIMULATOR

;INITIALIZING AND CONTROL SEQUENCE

SFSRT1:	SETZM	$ONETM
	JRST	BEGIN

START:	SKIPE	$ONETM
	JRST	.+3
	SETZM	ERRTLS			;CLEAR ALL TOTALS
	GO	CLRERR			;CLEAR MEMORY TOTALS
	SETZM	TICKS
	SETZM	TSTIMR#
	SETZM	TIMCNT#
	SETOM	PVPAGI			;PREVENT PAGE INHIBIT
	SETOM	MAPNEW
	PGMINT				;INITIALIZE SUBROUTINES
	MOVE	[JRST START]
	MOVEM	$ITRX1			;RESTART ON FATAL ERRORS
	SETOM	CLKON#
	SKIPE	USER
	JRST	STARTB
	MOVEI	1,^D60
	SKIPE	CYCL60
	MOVEI	1,^D50
	MOVEM	1,HERTZ#
	SETZM	CLKON
	SWITCH
	TRNE	INHCLK			;INHIBIT ELEVEN CLOCK ?
	JRST	.+4			;YES
	SETZM	TLAST#
	SETOB	CLKON
	CLOKOP				;HAVE ELEVEN KEEP TRACK OF TIME
	GO	CSYNC			;SYNC THE CLOCK
	MOVE	[CONSO TIM,TIMDON]
	MOVEI	1,0
	GO	TIMER			;GET CLOCK TIME IN MILLISECONDS
STARTB:	SETZM	ONCFLG#
	SETOM	DISPAT#
	SETZM	REPT#
	SKIPN	USER
	JRST	.+3
	CALL	0,[SIXBIT/TIMER/]	;USER RANDOM BASE
	MOVEM	0,RANDBS		;SETUP RANDOM BASE
	SWITCH
	TRNN	RANBAS			;SPECIFY RANDOM NUMBER BASE ?
	JRST	STARTA
	PNTMSF	[ASCIZ/
SPECIFY RANDOM NUMBER BASE - /]
	TTIOCT				;INPUT OCTAL NUMBER
	JRST	.-3			;ERROR
	MOVEM	0,RANDBS

STARTA:	SETOM	SIMFLG#			;SETUP CONTROL FLAGS
	SETOM	NEWFLG#
	SWITCH
	TRNE	INHNEW			;INHIBIT NEW INST'S ?
	SETZM	NEWFLG			;YES
	TRNE	FAST			;INHIBIT SIMULATION ?
	SETZM	SIMFLG			;YES
	MOVEI	1,^D10
	TRNE	SNGFL			;SINGLE FAST LOOP ?
	MOVEI	1,1			;YES
	MOVEM	1,FLCNT#
	MOVE	RA,RANDBS
	SETOM	.FIXF#			;SET TEST CONTROL FLAGS TO RUN ALL
	SETOM	.FLTF#
	SETOM	.BYTF#
	SETOM	.FASTF#
	SETOM	.SLOWF#
	SETOM	.DFLTF#
	SETOM	.RANF#
	SETZM	CKOUTF#
	MOVEI	1,6
	MOVEM	1,RTIME#
	SWITCH				;SETUP TEST CONTROL FLAGS
	TRNE	INHFXD
	SETZM	.FIXF			;FIXED POINT INHIBITED
	SKIPE	USER			;EXC MODE ?
	SKIPN	MONTYP			;TOPS10 ?
	SETZM	.FLTF			;FLOATING POINT INHIBITED
	TRNE	INHFP
	SETZM	.FLTF			;FLOATING POINT INHIBITED
	TRNE	INHBYT
	SETZM	.BYTF			;BYTE'S INHIBITED
	TRNE	INHDFP
	SETZM	.DFLTF			;DOUBLE FLOATING INHIBITED
	TRNE	SLOW
	SETZM	.FASTF			;SIMULATION COMPARISON ONLY
	TRNE	INHRAN
	SETZM	.RANF			;RANDOM INSTRUCTION INHIBITED
	TRNE	FAST
	SETZM	.SLOWF			;INSTRUCTION RESULT COMPARE ONLY
	TLNN	RELIAB			;RELIABILITY MODE ?
	SETZM	RTIME			;NO, FAST CYCLE OPERATION
	JRST	BEGFX

PGMNAM:	ASCIZ %
PDP-10 KL10 ARITHMETIC/RANDOM/INTERRUPT/MEMORY RELIABILITY TEST (DFKDA)
%

;END OF TEST, GENERATE NEW RANDOM BASE NUMBER

TSTEND:	MOVS	10,RANDBS
	MULI	10,6065
	DIV	10,[377777,,777741]
	SKIPN	11			;IF ZERO, MAKE RANDOM BASE = 1
	MOVEI	11,1
	MOVEM	11,RANDBS
	JRST	BEGEND
;TESTING SEQUENCE
;FIXED POINT ARITHMETIC OPERATIONS

BEGFX:	SUBTST
	JSR	TSTIME
	MOVEI	ACSP,ACS		;SETUP SIMULATED AC POINTER
	SETZM	CNTL
	SKIPN	.FIXF
	JRST	BEGFP			;DON'T TEST FIXED
	SKIPN	.FASTF
	JRST	FXS			;FIXED POINT, SLOW ONLY

;FIXED POINT FAST
;COMPARE RESULTS OF MUL,DIV,ADD REMAINDER WITH ORIGINAL

FXF:	SUBTST
	MOVEI	LOP,^D20
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
FXF1:	JSR	FSTMDI
	CAI	FIXEDI+4(CNTR)		;FIXED POINT INTERGERS
	JSR	FSTMD
	CAI	FIXED+2(CNTR)		;FIXED POINT
	SOJG	LOP,FXF1

;FIXED POINT SLOW
;COMPARE MACHINE RESULTS AGAINST SIMULATION

FXS:	SUBTST
	SKIPN	.SLOWF
	JRST	BEGFP			;DON'T RUN
	MOVEI	LOP,^D10
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
FXS1:	JSR	MD
	CAI	FIXEDI+10(CNTR)		;FIXED POINT INTERGERS
	JSR	MD
	CAI	FIXED+10(CNTR)		;FIXED POINT
	SOJG	LOP,FXS1
;TESTING SEQUENCE
;FLOATING POINT ARITHMETIC OPERATIONS
BEGFP:	SUBTST
	JSR	TSTIME
	SKIPN	.FLTF
	JRST	BEGBYT			;DON'T TEST FLOATING
	SKIPN	.FASTF
	JRST	FPS			;FLOATING POINT, SLOW ONLY

;FLOATING POINT FAST
;COMPARE RESULTS OF DIV THEN MUL
FPF:	SUBTST
	MOVEI	LOP,^D20
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
	JSR	FSTFP			;FLOATING POINT
	CAI	FPMD+4(CNTR)
	SOJG	LOP,.-2

;FLOATING POINT SLOW
;COMPARE MACHINE RESULTS AGAINST SIMULATION
FPS:	SUBTST
	SKIPN	.SLOWF
	JRST	BEGBYT
	MOVEI	LOP,^D10
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
FPS1:	MOVSI	CNTL,FP
	JSR	MD			;FLOATING POINT ADD/SUB
	CAI	FPAS+10(CNTR)
	JSR	MD			;FLOATING POINT SUB/MUL
	CAI	FPSM+10(CNTR)
	JSR	MD			;FLOATING POINT MUL/DIV
	CAI	FPMD+10(CNTR)
	JSR	MD			;DFN/UFA
	CAI	MISCFP+10(CNTR)
	MOVSI	CNTL,FP!FPI
	JSR	MD			;FLOATING POINT IMMEDIATE
	CAI	FPIMMD+10(CNTR)
	MOVSI	CNTL,FP!FPL
	JSR	MD			;THE L MODE
	CAI	FPLONG+10(CNTR)
	SOJG	LOP,FPS1
;BYTE INSTRUCTION, COMPARE WITH SIMULATION
BEGBYT:	SUBTST
	JSR	TSTIME
	SKIPN	.BYTF
	JRST	BEGDFP			;DON'T TEST BYTE
	MOVSI	CNTL,BYT
	MOVEI	LOP,^D5
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
	JSR	BYTE			;SIM AND CHECK BYTES
	CAI	BYTES+5(CNTR)
	SOJG	LOP,.-2

;TESTING SEQUENCE
;DOUBLE FLOATING POINT
BEGDFP:	SUBTST
	JSR	TSTIME
	SKIPN	.DFLTF
	JRST	BEGRAND			;DON'T TEST DOUBLE FLOATING
	SKIPN	.FASTF
	JRST	DFPS			;DOUBLE FLOATING, SLOW ONLY

;DOUBLE FLOATING POINT FAST
;COMPARE RESULTS OF ADD/SUB AND MUL/DIV
DFPF:	SUBTST
	MOVSI	CNTL,DFP
	MOVEI	LOP,^D10
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
	JSR	FSTFP
	CAI	DFPAS+4(CNTR)		;DOUBLE FLOATING POINT
	SOJG	LOP,.-2

;DOUBLE FLOATING POINT SLOW
;COMPARE MACHINE RESULTS AGAINST SIMULATION
DFPS:	SUBTST
	MOVSI	CNTL,DFP
	SKIPN	.SLOWF
	JRST	BEGRAND
	MOVEI	LOP,^D10
	ASH	LOP,@RTIME		;SETUP RUNNING TIME
DFPS1:	JSR	MD
	CAI	DFPAS+10(CNTR)		;DOUBLE FLOATING POINT
	SOJG	LOP,DFPS1
	JRST	BEGRAND

;TEST OF IMUL AND IDIV
;DIVIDE THEN MULTIPLY AND ADD REMAINDER

FSTMDI:	0
	MOVE	IT,@.-1			;POINT TO INST
	HRROI	CNTR,-4
FSMDI1:	JSR	RANNOV			;RANDOM, OV NOT POSSIBLE
	SETZM	CNTL
	JSR	DOINS			;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG			;IF JUMP PROG LOST
	JFCL	10,FSMDI2		;OV SET, DIVIDE ERROR
	XCT	@IT			;MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JFCL	10,FSMDI2		;MUL OR DIV ERROR
	ADD	AC,DIVAC+1
	CAME	AC,RA			;LOOK FOR ORIG
FSMDI2:	JSR	FSTER			;ERROR
	AOJL	CNTR,FSMDI1		;NEXT PAIR
	JRST	@FSTMDI			;EXIT

;TEST OF MUL AND DIV
;DIVIDE THEN MULTIPLY AND ADD REMAINDER

FSTMD:	0
	MOVE	IT,@.-1			;POINT TO INST
	HRROI	CNTR,-2
FSTMD1:	JSR	RANNOV			;RANDOM, OV NOT POSSIBLE
	SETZM	CNTL
	JSR	DOINS			;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG			;IF JUMP PROG LOST
	JFCL	10,FSTMD2		;OV SET, DIVIDE ERROR
	JRST	2,@[XWD 0,.+1]		;CLEAR FLAGS
	XCT	@IT			;MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JSP	.+1
	MOVEM	SECFLG#
	JFCL	10,FSTMD2		;MUL OR DIV ERROR
	JFCL	17,.+1
	ADD	AC+1,DIVAC+1
	JFCL	2,CRYFIX		;THE CRY 1 FLAG
	JFCL	4,CRY0FX
	CAMN	AC,RA
	CAME	AC+1,RA+1
FSTMD2:	JSR	FSTER			;MUL OR DIV ERROR
	AOJL	CNTR,FSTMD1		;NEXT PAIR
	JRST	@FSTMD			;EXIT

CRYFIX:	TLC	AC+1,400000
	AOJA	AC,FSTMD2-3

CRY0FX:	TLC	AC+1,400000
	SOJA	AC,FSTMD2-2
;TEST OF FLOATING POINT
;FP DIV THEN FP MUL

FSTFP:	0
	MOVE	IT,@.-1			;POINT TO A FP INSTRUCTION
	HRROI	CNTR,-4			;4 ITEMS
FSTFP1:	JSR	RANORM			;NORMALIZED RANDOM NUMBERS
	JSR	DOINS			;XCT INST, RECORD FLAGS
	MOVEM	FLAGS,FSTFLG#
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG			;IF JUMP PROG LOST
	JSR	DOINS			;DO A FMP
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	CAME	AC,RA
	JRST	FSTFP3			;POSSIBLE ERROR
FSTFP2:	AOJL	CNTR,FSTFP1		;NEXT PAIR
	JRST	@FSTFP			;EXIT

FSTFP3:	MOVEM	FLAGS,SECFLG		;SAVE SECOND FLAGS
	MOVE	FLAGS,FSTFLG
	MOVE	AC			;RESULT NOT EQUAL TO ORIGINAL
	SUBI	1			;IF LARGER OR SMALLER
	CAMN	RA			;COMPARE IT
	JRST	FSTFP2			;OK
	SUBI	1
	CAMN	RA
	JRST	FSTFP2			;OK
	ADDI	3
	CAMN	RA
	JRST	FSTFP2			;OK
	ADDI	1
	CAME	RA
FSTFP4:	JSR	FSTER			;ERROR, FIND WHAT FAILED
	JRST	FSTFP2			;OK
;TEST OF BYTE INSTRUCTIONS
;COMPARE MACHINE RESULTS WITH SIMULATION

	PMASK:770000,,0			;POINTER MASK
	PFIELD:440000,,0		;POINTER FIELD
	SMASK:7700,,0			;SIZE MASK
	SFIELD:4400,,0			;SIZE FIELD


BYTE:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-5			;5 ITEMS
BYTE1:	JSR	RANDOM			;GENERATE RANDOM NUMBERS

	AND	AC+2,PMASK		;MASK OUT THE POINTER FIELD
	CAMLE	AC+2,PFIELD		;TEST FOR GREATER THAN 44
	HRLZI	RA+2,PFIELD		;ADJUST THE WORD		
	MOVE	AC+2,RA+2		;RESTORE AC+2
	AND	AC+2,SMASK		;MASK OUT THE SIZE FIELD
	CAMLE	AC+2,SFIELD		;TEST FOR GREATER THAN 44
	SUB	RA+2,SFIELD		;ADJUST THE WORD		
	MOVE	AC+2,RA+2		;RESTORE AC+2

	LSH	RA+2,-^D30		;MAKE A BYTE
	LSH	AC+2,-^D24		;POINTER
	ANDI	AC+2,77			;IF THE POINTER (RIGHT HALF)
	TRNN	CNTR,2
	CAMG	AC+2,RA+2		;WILL BE INCREMENTED
	TRO	AC+2,10000		;POINT TO AC
	TRO	RA+2,100		;IF NO INCREMENT
	ROT	RA+2,^D30		;POINT TO AC+1
	ROT	AC+2,^D24
	ADDB	AC+2,RA+2		;THE POINTER IN RA+2, AC+2

	JSR	SIMIT			;SIMULATE
	JSR	DOIT			;XCT
	AOJL	CNTR,BYTE1		;ITERATE
	JRST	@BYTE			;EXIT

;PERFORM THE MACHINE INSTRUCTION

DOINS:	0
	JRST	2,@[XWD 0,.+1]		;CLEAR FLAGS
DOINS1:	XCT	@IT
	JSP	.+1			;SAVE FLAGS
	SKIPE	CKOUTF			;CHECKOUT ?
	TLZ	0,400!200		;YES, CLEAR TN0,TN1
	HLLM	FLAGS			;IN FLAG REGISTR
	JRST	@DOINS

;TEST INSTRUCTION BY COMPARING MACHINE RESULTS
;WITH SIMULATION RESULTS

MD:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-10		;GROUPS OF 8
MD1:	TLNN	CNTL,DFP!FP		;DOUBLE FLOAT OR FLOAT FLAG SET ?
	JRST	MD2			;NO
	SKIPE	KLFLG			;KL10 ?
	JRST	.+3			;YES, NORMALIZED RANDOM
	SKIPN	CKOUTF			;CHECKOUT ?
	JRST	MD2			;NO
	JSR	RANORM			;YES, GENERATE NORMALIZED RANDOM
	JRST	MD2+1
MD2:	JSR	RANDOM			;GENERATE RANDOM NUMBERS
	HLLZS	CNTL			;CLEAR CONTROL SWITCHES
	JSR	SIMIT			;SIMULATE INSTRUCTION
	JSR	DOIT			;XCT INSTRUCTION
	AOJL	CNTR,MD1		;ITERATE
	JRST	@MD			;EXIT

;SIMULATE THE INSTRUCTION

SIMIT:	0
	SAVEM	RA,1
	SINST	@IT			;SIMULATE, RESULTS IN ACS
	JRST	@SIMIT

GG:	PNTMSF	[ASCIZ/
INTERNAL PROGRAM PROBLEM, SUGGEST RELOAD, RESTART !
/]
	ERRHLT
	JRST	BEGIN
;COMPARE MACHINE RESULTS AGAINST SIMULATOR

CHECK:	0
	HLR	FLAGS,PCSAV#
	TLZ	FLAGS,USERF!LIP		;CLEAR MISC
	MOVS	FLAGS
	CAME	FLAGS			;COMPARE FLAGS
	HRRI	CNTL,FLAGS
	SKIPE	KLFLG
	JRST	KLCHK
CHECK3:	CAME	AC+3,4(ACSP)		;COMPARE AC+3
	HRRI	CNTL,AC+3
	CAME	AC+2,3(ACSP)		;COMPARE AC+2
	HRRI	CNTL,AC+2
	TLNE	CNTL,DFP		;DOUBLE FLOATING POINT
	JRST	CHECK2			;YES, CHECK RESULT LS +-1
	CAME	AC+1,2(ACSP)		;COMPARE AC+1
	HRRI	CNTL,AC+1
CHECK1:	CAME	AC,1(ACSP)		;COMPARE AC
	HRRI	CNTL,AC
	JRST	@CHECK

KLCHK:	TLNN	CNTL,FP!FPL		;FLOATING POINT ?
	JRST	CHECK3			;NO

	CAME	AC+3,4(ACSP)		;COMPARE AC+3
	JRST	KLCHK1
KLCHKA:	CAME	AC+2,3(ACSP)		;COMPARE AC+2
	JRST	KLCHK2
KLCHKB:	CAME	AC+1,2(ACSP)		;COMPARE AC+1
	JRST	KLCHK3
KLCHKC:	CAME	AC,1(ACSP)		;COMPARE AC
	JRST	KLCHK4
KLCHKD:	JRST	@CHECK
KLCHK1:	MOVE	0,AC+3			;COMPARE AC+3 PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,4(ACSP)
	JRST	KLCHKA
	ADDI	0,2
	CAMN	0,4(ACSP)
	JRST	KLCHKA
	HRRI	CNTL,AC+3
	JRST	@CHECK

KLCHK2:	MOVE	0,AC+2			;COMPARE AC+2 PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,3(ACSP)
	JRST	KLCHKB
	ADDI	0,2
	CAMN	0,3(ACSP)
	JRST	KLCHKB
	HRRI	CNTL,AC+2
	JRST	@CHECK

KLCHK3:	MOVE	0,AC+1			;COMPARE AC+1 PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,2(ACSP)
	JRST	KLCHKC
	ADDI	0,2
	CAMN	0,2(ACSP)
	JRST	KLCHKC
	TLNN	CNTL,FPL
	HRRI	CNTL,AC+1
	JRST	@CHECK

KLCHK4:	MOVE	0,AC			;COMPARE AC PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,1(ACSP)
	JRST	KLCHKD
	ADDI	0,2
	CAMN	0,1(ACSP)
	JRST	KLCHKD
	HRRI	CNTL,AC
	JRST	@CHECK
;PERFORM THE INSTRUCTION

DOIT:	0
	JSR	DOINS			;XCT THE INSTRUCTION
	TLNN	CNTL,ER			;BYPASS IF ERROR
	JSR	CHECK			;CHECK FOR VALID DATA
	TRNN	CNTL,-1
	JRST	@DOIT			;EXIT, NO ERRORS
	SKIPN	USER
	SKIPE	KLFLG
	JRST	.+2
	DATAO	PI,(CNTL)		;LOAD MI WITH FAILURE
DOIT1:	TLOE	CNTL,ER			;SET ERROR FLAG
	JRST	DOIT4			;SEE IF PRINT ALL ERRORS
	PNTMSG	[ASCIZ/
**********
SIMULATION COMPARISION FAILURE
/]
	JSR	TTLPNT
	JSR	RESULT			;PRINT MACHINE RESULTS
	JSR	PNTSIM			;PRINT SIMULATION

DOIT2:	MOVEM	0,SAC0
	TTALTM				;ALTMODE CHECK
	SKIPA				;NONE
	JRST	DDTEX+1			;YES, GO TO DDT
	MOVE	0,SAC0
	MOVEM	CNTL,SAVCNT#		;SAVE CNTL
	TRZ	CNTL,-1			;CLEAR RIGHT HALF
	JSR	CHECK
	MOVE	AC,RA
	MOVE	AC+1,RA+1
	MOVE	AC+2,RA+2
	MOVE	AC+3,RA+3
	SWITCH				;READ SWITCHES
	TLNE	ERSTOP			;HALT AND SAVE AC'S?
	JSR	GOING			;YES
	TLNE	LOOPER			;PROCEED SWITCH SET?
	JRST	.+4			;NO
	JSR	DOIT3			;YES, GO RING BELL
	TLZ	CNTL,ER			;CLEAR ER FLAG
	JRST	@DOIT			;AND CONT WITH PROG
	TRNE	CNTL,-1			;HAD AN ERROR?
	JSR	DOIT3			;YES, GO RING BELL
	MOVE	CNTL,SAVCNT		;RESTORE CNTL
	JRST	DOIT+1			;CYCLE ERROR

;DETERMINE IF FIRST OR SECOND OPERATION CAUSED FAILURE

FSTER:	0
	SETZM	FAIL1#
	SUBI	CNTR,1			;POINT TO FIRST INSTRUCTION
	JSR	SIMIT			;SIMULATE
	MOVE	AC,DIVAC		;RESTORE FIRST RESULTS.
	MOVE	AC+1,DIVAC+1
	MOVE	AC+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	TRZ	CNTL,-1
	JSR	CHECK			;CHECK SIM VS ACTUAL
	TRNN	CNTL,-1
	AOJA	CNTR,FSTER2		;LOOKS LIKE SECOND OP FAILED

FSTER1:	PNTMSG	[ASCIZ/
**********
INSTRUCTION COMPARISION FAILURE
/]
	JSR	TTLPNT
	JSR	RESULTS			;FIRST OP FAILED, PRINT RESULTS
	SAVEM	RA,1
	JSR	PNTSIM			;PRINT SIMULATION
	TLO	CNTL,ER			;SET ER FLAG
	JSR	DOIT			;SCOPE LOOP
	SKIPN	FAIL1			;FIRST OP FAILURE ?
	AOJGE	CNTR,GG			;YES, INC CNTR; IF JUMP PROG LOST
	JRST	@FSTER			;EXIT

FSTER2:	SETOM	FAIL1
	MOVE	RA,DIVAC
	MOVE	RA+1,DIVAC+1
	MOVE	RA+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	MOVE	AC,MULAC
	MOVE	AC+1,MULAC+1
	MOVE	AC+2,MULAC+2
	MOVE	AC+3,MULAC+3
	JSR	SIMIT			;SIMULATE SECOND OP
	HLL	FLAGS,SECFLG		;GET FLAGS FROM SECOND OP
	JSR	CHECK			;CHECK SIM VS ACTUAL
	TRNE	CNTL,-1			;DID SECOND FAIL ?
	JRST	FSTER1			;YES, PRINT RESULTS
	JRST	@FSTER			;NO, SIM SAYS BOTH OK...CONTINUE
;UUO ROUTINES
;SIMULATE SINGLE INSTRUCTION, NO PRINTOUT

SIMNST:	SETOM	MASK			;INHIBIT PRINTOUT
	MOVE	[XWD 1,SAVAC+1]
	BLT	SAVAC+17
	HRRZ	$SVUUO
	MOVEM	INPC			;SETUP PC
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN			;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2			;SET FOR FIRST INSTR
	GO	SENTRY			;GO TO SIMULATOR
	MOVE	PC
	TLZ	400!200			;CLEAR TN0,TN1
	JSP	1,.+1			;GET ACTUAL FLAGS
	TLNN	1,USERF			;USER MODE ?
	TLZ	AROV			;NO,CLEAR OV FLAG
	MOVEM	PCSAV#			;SAVE PC FLAGS
	MOVS	[XWD 1,SAVAC+1]
	BLT	17
	JRST	UUOEXT			;EXIT UUO

;SIMULATE SINGLE INSTRUCTION, PRINT STATES

SIMMT:	SETZM	MASK			;ALLOW PRINTOUT
	JRST	SIMNST+1		;REST SAME AS ABOVE

CHECK2:	SKIPE	KLFLG			;KL10 ?
	JRST	.+3			;YES
	SKIPN	CKOUTF			;CHECKOUT ?
	JRST	CHECK1-2		;NO
	MOVE	0,AC+1
	CAMN	0,2(ACSP)		;CHECK DBL FP LS +-1
	JRST	CHECK1
	SUBI	0,1
	CAMN	0,2(ACSP)
	JRST	CHECK1
	ADDI	0,2
	CAMN	0,2(ACSP)
	JRST	CHECK1
	JRST	CHECK1-1
;PRINT PROGRAM TITLE AND PASS COUNT

TTLPNT:	0
	SKIPN	ERRFST#
	PNTNM
	SETOM	ERRFST
	AOS	ERRTLS			;INCREMENT ERROR TOTALS
	SKIPE	USER			;USER MODE ?
	JRST	TLPNT1-1
	MOVE	0,CONSW
	TRNE	INHCLK			;CLOCK INHIBITED ?
	JRST	TLPNT1			;YES
	JSR	RUNTIM
TLPNT1:	PNTMSG	[ASCIZ/
BASE RANDOM NUMBER = /]
	MOVE	0,RANDBS
	PNTHW				;PRINT RANDOM NUMBER BASE
	MOVE	PASCNT
	CAMN	PSCTR1#
	JRST	TLPNT2
	PNTMSG	[ASCIZ/
TEST PASS COUNT = /]
	MOVE	PASCNT
	MOVEM	PSCTR1
	PNTDEC
TLPNT2:	PCRL
	JRST	@TTLPNT

DOIT3:	0
	TLNN	DING			;RING BELL ON ERROR ?
	JRST	@DOIT3			;NO
	MOVEI	BELL
	PNTAF				;RING TTY BELL
	JRST	@DOIT3

;CHECK PRINT ALL ERRORS SWITCH

DOIT4:	SWITCH
	TLNN	PALERS			;PRINT ALL ERRORS ?
	JRST	DOIT2			;NO, DON'T PRINT...NOT FIRST
	JRST	DOIT1+2

;RANDOM NUMBER GENERATION
;FOUR RANDOM IN AC,AC+1,AC+2,AC+3
;A COPY ALSO IN RA,RA+1,RA+2,RA+3

RANDOM:	0
	SWITCH
	TLNE	RSTART!TOTALS
	JSR	PNTTOT
	MOVE	AC,RA
	ADD	AC,[543217335216]
	ROT	AC,-1
	EQVB	AC,RA			;RANDOM 1
	MOVS	AC+1,RA
	ADD	AC+1,[165742176525]
	ROT	AC+1,-1
	EQVB	AC+1,RA+1		;RANDOM 2
	MOVS	AC+2,RA+1
	ADD	AC+2,[147532173543]
	ROT	AC+2,-1
	EQVB	AC+2,RA+2		;RANDOM 3
	MOVS	AC+3,RA+2
	ADD	AC+3,[731341527517]
	ROT	AC+3,-1
	EQVB	AC+3,RA+3		;RANDOM 4
	JRST	@RANDOM

;RANDOM NUMBER GENERATION
;OVERFLOW NOT POSSIBLE FOR DIVIDE

RANNOV:	0
	JSR	RANDOM
	MOVM	AC+2
	MOVMM	RA,TEMP#
	CAMN	TEMP
	JRST	RANNOV+1		;DIVISOR=HI DIVIDEND
	CAML	TEMP
	JRST	.+3
	EXCH	AC,AC+2			;DIVISOR SMALLER, EXCHANGE
	EXCH	RA,RA+2			;TO MAKE LARGER
	JUMPE	RA+2,RANNOV+1
	TRNN	AC+2,-1
	JRST	RANNOV+1		;REJECT IF 0 FOR IDIV1
	TLZ	AC+1,400000
	TLNE	AC,400000
	TLO	AC+1,400000
	MOVEM	AC+1,RA+1
	JRST	@RANNOV

;RANDOM NUMBER GENERATION
;NORMALIZED RANDOM FOR FLOATING POINT

RANORM:	0
	JSR	RANDOM
	NORM	RA+3,AC+3
	NORM	RA+2,AC+2
	TLNN	CNTL,FPI		;FLOATING POINT IMMEDIATE ?
	JRST	.+4
	TLNN	AC+2,000777		;ANY FRACTIONAL PART ?
	TLO	AC+2,400		;NO, MAKE ONE
	MOVSS	RA+2,AC+2		;PUT SIGNIFICANT PART IN LOWER 18
	NORM	RA+1,AC+1
	NORM	RA,AC
	JRST	@RANORM
;SIMULATE AND PRINT THE INSTRUCTION

PNTSIM:	0
	SAVEM	RA,1
	SMT	@IT			;SIMULATE AND PRINT
	JRST	@PNTSIM

;PRINT FAST TEST FAILURE RESULTS

RESULT:	0
	SETOM	PNTSPC			;SET TO SPACE AFTER OCTALS
	PNTMSG	[ASCIZ/
FLAGS FROM MACH & SIMULATE   /]
	MOVE	FLAGS
	PNTHW
RSLTS1:	MOVEI	[ASCIZ/
MACHINE RESULTS IN AC,AC+1,E   /]
	TLNE	CNTL,BYT		;BYTE ERROR
	MOVEI	[ASCIZ/
MACHINE RESULTS IN AC,POINTER,E   /]
	PNTAL
	HLRZ	AC			;PRINT MACHINE AC
	PNT6
	SETZM	PNTSPC
	HRRZ	AC
	PNT6
	PNTCI	","
	SETOM	PNTSPC
	TLNE	CNTL,BYT
	EXCH	AC+1,AC+2
	HLRZ	AC+1			;PRINT AC+1
	PNT6
	SETZM	PNTSPC
	HRRZ	AC+1
	PNT6
	PNTCI	","
	SETOM	PNTSPC
	HLRZ	AC+2			;PRINT AC+2, (E)
	PNT6
	SETZM	PNTSPC
	HRRZ	AC+2
	PNT6
	SETOM	PNTSPC
	PCRL
	JRST	@RESULT

;THE INSTRUCTIONS TESTED

;INTERGER FIXED POINT
FIXEDI:	IDIV	AC,AC+2
	IMUL	AC,AC+2
	IDIVI	AC,(AC+2)
	IMULI	AC,(AC+2)
	IDIVM	AC,AC+2
	IMULM	AC,AC+2
	IDIVB	AC,AC+2
	IMULB	AC,AC+2

;MULTIPLY AND DIVIDE
FIXED:	DIV	AC,AC+2
	MUL	AC,AC+2
	DIVI	AC,(AC+2)
	MULI	AC,(AC+2)
	MULM	AC,AC+2
	DIVM	AC,AC+2
	MULB	AC,AC+2
	DIVB	AC,AC+2

;FLOATING POINT: ADD, SUBTRACT
FPAS:	FAD	AC,AC+2
	FSB	AC,AC+2
	FADR	AC,AC+2
	FSBR	AC,AC+2
	FADM	AC,AC+2
	FADB	AC,AC+2
	FADRM	AC,AC+2
	FADRB	AC,AC+2

;FLOATING POINT: SUBTRACT, MULTIPLY
FPSM:	FSBM	AC,AC+2
	FSBB	AC,AC+2
	FSBRM	AC,AC+2
	FSBRB	AC,AC+2
	FMPM	AC,AC+2
	FMPB	AC,AC+2
	FMPRM	AC,AC+2
	FMPRB	AC,AC+2

;FLOATING POINT: MULTIPLY, DIVIDE
FPMD:	FMP	AC,AC+2
	FDV	AC,AC+2
	FMPR	AC,AC+2
	FDVR	AC,AC+2
	FDVM	AC,AC+2
	FDVB	AC,AC+2
	FDVRM	AC,AC+2
	FDVRB	AC,AC+2
;FLOATING POINT: MISCELLANEOUS
MISCFP:	UFA	AC,AC+2
	DFN	AC,AC+2
	UFA	AC,AC+2
	DFN	AC,AC+2
	UFA	AC,AC+2
	DFN	AC,AC+2
	UFA	AC,AC+2
	DFN	AC,AC+2

;FLOATING POINT: IMMEDIATE
FPIMMD:	FADRI	AC,(AC+2)
	FSBRI	AC,(AC+2)
	FMPRI	AC,(AC+2)
	FDVRI	AC,(AC+2)
	FADRI	AC,(AC+2)
	FSBRI	AC,(AC+2)
	FMPRI	AC,(AC+2)
	FDVRI	AC,(AC+2)

;FLOATING POINT: LONG MODE
FPLONG:	FADL	AC,AC+2
	FSBL	AC,AC+2
	FMPL	AC,AC+2
	FDVL	AC,AC+2
	FMPL	AC,AC+2
	FDVL	AC,AC+2
	FADL	AC,AC+2
	FSBL	AC,AC+2

;BYTES
BYTES:	IBP	AC+2
	ILDB	AC,AC+2
	IDPB	AC,AC+2
	LDB	AC,AC+2
	DPB	AC,AC+2

;DOUBLE FLOATING POINT: ADD, SUBTRACT
DFPAS:	DFSB	AC,AC+2
	DFAD	AC,AC+2

;DOUBLE FLOATING POINT: MULTIPLY, DIVIDE
DFPMD:	DFMP	AC,AC+2
	DFDV	AC,AC+2

;FLOATING POINT: MISCELLANEOUS
FPMISC:	FLTR	AC,AC+2
	FIX	AC,AC+2
	FIXR	AC,AC+2
	FLTR	AC,AC+2
SUBTTL	RANDOM DIAGNOSTIC SECTION

BEGRAND:SKIPN	.RANF
	JRST	BEGINT			;RANDOM INSTRUCTION INHIBITED
	SETZM	ERRCNT#			;ERROR COUNT
	SETZM	RLOOPC#
	MOVE	RANDBS
	MOVEM	K1#
CONTNU:	MOVE	10,FLCNT
	MOVEM	10,K2#			;ITR COUNT
	SETZM	PRNT#			;PRINT FLAG
	SETZ	12,0
CONTN1:	MOVS	10,K1			;RESTART TO CONTINUE RANDOM NUMBERS
	MULI	10,6065		
	DIV	10,[XWD 377777,777741]
	MOVEM	11,K1
	MOVEM	11,0(12)
	AOS	12,12
	CAIE	12,10
	JRST	CONTN1
	HRRI	12,RAND			;STOR NUM IN RAND TO RAND+7 AND AC 0-7
	HRLI	12,0
	BLT	12,RAND+7
VIT:	SETZ	12,0			;TEST FOR VALID INST
	MOVE	11,@12
	AND	11,[XWD 770000,0]
	ROT	11,6
	SKIPN	KLFLG			;KL10 ?
	JRST	.+3			;NO
	CAIGE	11,20			;KL, LESS THAN OP CODE 200 ?
	JRST	XKL10			;YES, SPECIAL KL INSTRUCTIONS
	CAIGE	11,11			;LESS THAN 110
	JRST	XCONVT			;YES, MAKE NEW INST
	CAIGE	11,13			;LESS THAN 130
	JRST	NWINST			;YES, MAKE NEW KI INSTRUCTIONS
	CAIGE	11,14			;LESS THAN 140
	JRST	BYTTST			;YES GO CHECK FOR POSSIBLE BYTE OR FSC
	CAIN	11,26			;CHECK FOR PUSH,POP
	JRST	XIMUL			;GO MAKE NEW INST (IMUL)
	CAIN	11,25			;CHECK FOR JMP INST
	JRST	ECHTST			;GO CHECK FOR POSSIBLE EXCH
	LSH	11,-3
	CAIN	11,3			;CHECK FOR SKIPS & JMPS
	JRST	XFSBR			;GO MAKE NEW INST(FSBR)
	CAIN	11,6			;CHECK FOR TST INST
	JRST	TSTTST			;GO CHECK FOR LAST INST IN GROUP
	CAIN	11,7			;CHECK FOR IOT
	JRST	XFMPR			;GO MAKE NEW INST(FMPR)
	CAIE	11,2			;CHECK FOR JFFO
	JRST	MASKX			;NO
	JSR	ARANGE			;YES, POSSIBLE
	CAIN	13,243
	JRST	XIMUL			;GO MAKE NEW INST (IMUL)
	CAIN	13,247			;MAP INSTRUCTION
	JRST	XIMUL			;MAKE IMUL
	JRST	MASKX			;GO MASKX OUT UNWANTED BITS
ARANGE: 0				;GET OPERATION CODE OF OPERAND
	MOVE	13,@12
	AND	13,[XWD 777000,0]
	ROT	13,9
	JRST	@ARANGE

BYTTST:	JSR	ARANGE
	CAILE	13,132			;CHECK FOR FSC OR BYTE
	JRST	XASHC			;NO,MAKE NEW INST (ASHC)
	JRST	MASKX			;YES,GO MASKX OUT UNWANTED BITS

ECHTST:	JSR	ARANGE			;GO GET OP CODE
	CAIE	13,250			;POSSIBLE EXCHANGE INST
	JRST	XIMUL			;NO,MAKE NEW INST (IMUL)
	JRST	MASKX			;YES,GO MASKX OUT UNWANTED BITS

TSTTST:	CAILE	12,4			;POSSIBLE TST INST IF NOT LAST IN GROUP
	JRST	XFDVR			;NO,GO MAKE NEW INST (FDVR)
	JRST	MASKX			;YES,GO MASKX OUT UNWANTED BITS

VITEXT:	AOS	12
	MOVEM	11,INSBLK-1(12)		;STOR VALID INST IN INSBLK TO INS BLK+7
	CAIN	12,7
	JRST	SLO			;GO SET UP SLOW LOOP
	JRST	VIT+1			;GO TEST MORE

XKL10:	CAIGE	13,120			;0 TO 117 - MAKE DIV
	JRST	XDVR
	CAIG	13,122			;DMOVE, DMOVN, FIX - OK
	JRST	MASKX
	CAIN	13,123			;123 - MAKE MUL
	JRST	XMPR
	CAIGE	13,130			;DMOVEM, DMOVNM, FIXR, FLTR - OK
	JRST	MASKX
	CAIGE	13,140			;130-137, MAKE DIV
	JRST	XDVR
	CAIGE	13,150			;140-147, MAKE MUL
	JRST	XMPR
	CAIGE	13,160			;150-157, MAKE SUB
	JRST	XSBR
	CAIGE	13,170			;160-167, MAKE ADD
	JRST	XADD
	JRST	XASHC			;170-177, MAKE ASHC
MMASKX:	0				;MAKE NEW INST
	MOVE	11,@12
	TLZ	11,777000
	XCT	@MMASKX
	JRST	MASKX+1

XROTC:	JSR	MMASKX
	ADD	11,[XWD 245000,0]	;MAKE IT A ROTC

XIMUL:	JSR	MMASKX
	ADD	11,[XWD 220000,0]	;MAKE IT A IMUL

XFDVR:	SKIPE	KLFLG
	JRST	XDVR
	JSR	MMASKX			;MAKE IT A FDVR
	ADD	11,[XWD 174000,0]

XDVR:	JSR	MMASKX
	ADD	11,[234000,,0]		;MAKE IT A DIV

XMPR:	JSR	MMASKX
	ADD	11,[224000,,0]		;MAKE IT A MUL

XSBR:	JSR	MMASKX
	ADD	11,[274000,,0]		;MAKE IT A SUB

XADD:	JSR	MMASKX
	ADD	11,[244000,,0]		;MAKE IT A ADD
XFMPR:	SKIPE	KLFLG
	JRST	XMPR
	JSR	MMASKX
	ADD	11,[XWD 164000,0]	;MAKE IT A FMPR

XFSBR:	SKIPE	KLFLG
	JRST	XSBR
	JSR	MMASKX
	ADD	11,[XWD 154000,0]	;MAKE IT A FSBR

XASHC:	JSR	MMASKX
	ADD	11,[XWD 244000,0]	;MAKE IT A ASHC

XDFAD:	JSR	MMASKX
	ADD	11,[XWD	110000,0]	;MAKE DFAD

XDFSB:	JSR	MMASKX
	ADD	11,[XWD 111000,0]	;MAKE DFSB

XDFMP:	JSR	MMASKX
	ADD	11,[XWD 112000,0]	;MAKE DFMP

XDFDV:	JSR	MMASKX
	ADD	11,[XWD 113000,0]	;MAKE DFDV

MASKX:	MOVE	11,@12			;MASK OUT INDEX REG & HIGH ORDER E FIELD
	AND	11,[XWD 777340,7]
	JRST	VITEXT

XCONVT:	SKIPN	KLFLG
	SKIPN	NEWFLG			;MAKE NEW INST'S
	JRST	XROTC			;NO
	CAIGE	11,02
	JRST	XDFAD			;0-17 MAKE DFAD
	CAIGE	11,04
	JRST	XDFSB			;20-37 MAKE DFSB
	CAIGE	11,06
	JRST	XDFMP			;40-57 MAKE DFMP
	CAIGE	11,10
	JRST	XDFDV			;60-77 MAKE DFDV
	JRST	XROTC			;100-107 MAKE ROTC
NWINST:	SKIPN	NEWFLG			;MAKE NEW INST'S
	JRST	XROTC			;NO
	JSR	ARANGE
	CAIG	13,113
	JRST	MASKX			;DOUBLE FP
	CAIGE	13,120
	JRST	XDFDV			;MAKE NEW INST (DFDV)
	CAIG	13,122
	JRST	MASKX			;DOUBLE MOVES
	CAIN	13,123
	JRST	XDFDV			;MAKE NEW INST (DFDV)
	JRST	MASKX			;DBL MOVES MEM, FIX, FLT

SLO:	JSR	TSTIME
	MOVE	10,INSBLK		;GO STORE INSTRUCTIONS
	MOVEM	10,CORIN1		;IN CORE LOOP
	MOVE	10,INSBLK+1
	MOVEM	10,CORIN2
	MOVE	10,INSBLK+2
	MOVEM	10,CORIN3
	MOVE	10,INSBLK+3
	MOVEM	10,CORIN4
	MOVE	10,INSBLK+4
	MOVEM	10,CORIN5
	MOVE	10,INSBLK+5
	MOVEM	10,CORIN6
	SETZM	SVINPC#			;CLEAR SVINPC FOR ERROR
SLO1:	MOVEM	0,SAC0
	TTALTM				;ALTMODE CHECK
	SKIPA				;NONE
	JRST	DDTEX+1			;YES, GO TO DDT
	MOVE	0,SAC0
	SETZM	COREXF			;CLEAR FLAG FOR SIMULATION
	MOVSI	10,RAND
	BLT	10,7			;SETUP AC OPERANDS
	MOVE	10,[RAND,,ACS]
	BLT	10,ACS+7		;SETUP SIMULATOR OPERANDS
	SETZB	10,ACS+10		;AC10 IS 0 IN BOTH
	JRSTF	@.+1			;CLEAR FLAGS
		.+1
CORLOP:	SETZM	NOSKPF			;CLEAR NO SKIP FLAG
CORIN1:	0				;1ST INSTRUCTION
	SETOM	NOSKPF			;NO SKIP
	JSR	COREX			;GO TO SIMULATION
CORIN2:	0				;2ND INST
	SETOM	NOSKPF
	JSR	COREX
CORIN3:	0				;3RD INST
	SETOM	NOSKPF
	JSR	COREX
CORIN4:	0				;4TH INST
	SETOM	NOSKPF
	JSR	COREX
CORIN5:	0				;5TH INST
	SETOM	NOSKPF
	JSR	COREX
CORIN6:	0				;6TH INST
	SETOM	NOSKPF
	JSR	COREX
	JRST	.+3
COREXF:	0				;SIMULATION FLAG
NOSKPF:	0				;NO SKIP FLAG
	SKIPGE	K2			;PREVIOUS FAILURE, BUT NONE THIS TIME ?
	JRST	CORER1			;YES
	MOVEI	10,ANSBLK
	BLT	10,ANSBLK+7		;SAVE ANSWERS
	MOVE	10,FLCNT
	MOVEM	10,K2			;SETUP FAST LOOP COUNT
	SETZM	COREXF			;CLEAR SIMULATION FLAG

	MOVEM	0,SAC0
	TTALTM				;ALTMODE CHECK
	SKIPA				;NONE
	JRST	DDTEX+1			;YES, GO TO DDT
	MOVE	0,SAC0
	JSR	TSTIME

FASTLP:	MOVE	10,[INSBLK,,11]
	BLT	10,17			;LOAD FAST LOOP INSTRUCTIONS
	MOVSI	10,RAND
	BLT	10,7			;LOAD OPERANDS
	SETZM	10
;EXECUTE FAST LOOP

EXFAST:	MOVE	17,[JRST CHEC]		;SETUP EXIT INST
	JRSTF	@.+1			;CLEAR FLAGS
		.+1
	JRST	11			;GO TO FAST LOOP
CHEC:	MOVEM	0,ANSSV0#
	MOVE	P,PLIST
	MOVEI	$PSHER
	PUT	0
	MOVE	0,ANSSV0
	CAME	0,ANSBLK		;CHECK FAST LOOP AND SLOW LOOP ANS
	JSR	ERRX
	CAME	1,ANSBLK+1
	JSR	ERRX
	CAME	2,ANSBLK+2
	JSR	ERRX
	CAME	3,ANSBLK+3
	JSR	ERRX
	CAME	4,ANSBLK+4
	JSR	ERRX
	CAME	5,ANSBLK+5
	JSR	ERRX
	CAME	6,ANSBLK+6
	JSR	ERRX
	CAME	7,ANSBLK+7
	JSR	ERRX
CHEC1:	SKIPGE	K2			;FAILURE ?
	JRST	FSTER1			;YES
	SOSE	K2			;REPEAT FAST LOOP ?
	JRST	FASTLP			;YES

CHEC2:	SWITCH
	TLNE	RSTART!TOTALS
	JSR	PNTTOT			;GO PRINT TOTALS
	AOS	16,RLOOPC
	TLNE	RELIAB
	JRST	.+4
	TRNE	16,3
	JRST	CONTNU
	JRST	BEGINT
	TRNE	16,37
	JRST	CONTNU
	JRST	BEGINT

FSTLP1:	SWITCH
	TLNN	LOOPER			;STAY IN ERROR LOOP
	JRST	CHEC2			;NO
	JRST	FASTLP			;YES, REPEAT FAILING LOOP
COREX:	0
	MOVEM	10,SAC10#
	MOVE	10,COREX		;GET CALL PC
	SUBI	10,3			;-3, POINTS TO INST
	MOVEM	10,INPC			;SAVE AS SIM PC
	ADDI	10,3
	SKIPN	NOSKPF			;DID INST SKIP ?
	ADDI	10,3			;YES, SET RETURN TO SKIP NEXT INST
	MOVEM	10,COREX
	SETZM	NOSKPF
	MOVE	10,SAC10
	SKIPN	SIMFLG			;SIMULATE INSTRUCTION ?
	JRST	@COREX			;NO

COREX1:	SETOM	COREXF
	MOVE	10,[ACS,,SIMBLK]
	BLT	10,SIMBLK+10		;SAVE ORIG SIM AC'S FOR ERROR
	SETOM	MASK
	JSR	SIMI			;SIMULATE INSTRUCTION
	CAME	0,ACS+0			;COMPARE AC RESULTS & SIM RESULTS
	JSR	ERRX			;ERROR
	CAME	1,ACS+1
	JSR	ERRX
	CAME	2,ACS+2
	JSR	ERRX
	CAME	3,ACS+3
	JSR	ERRX
	CAME	4,ACS+4
	JSR	ERRX
	CAME	5,ACS+5
	JSR	ERRX
	CAME	6,ACS+6
	JSR	ERRX
	CAME	7,ACS+7
	JSR	ERRX
	MOVE	10,SAC10
	JRST	@COREX			;EXIT

CORER1:	SWITCH
	TLNN	LOOPER			;LOOP ON ERROR ?
	JRST	CHEC2			;NO
	JRST	SLO1			;YES, STAY IN SLOW LOOP
;ERROR ROUTINES
ERRX:	0
	MOVEM	0,SAV0#
	SWITCH
	MOVEM	0,10
	MOVE	0,SAV0
	SKIPE	PRNT			;FIRST OUTPUT
	TLNE	10,PALERS		;PRINT ALL ERRORS ?
	JSR	OUT			;GO OUTPUT

ERRX1:	AOS	ERRCNT
	AOS	ERRTLS
	SWITCH
	TLNE	ERSTOP			;HALT ON ERROR ?
	JSR	GOING			;YES
	TLNE	0,LOOPER		;LOOP ON ERROR ?
	SETOM	K2			;YES, MAKES LOOP EFF FOREVER
	SKIPN	USER
	SKIPE	KLFLG
	JRST	.+2
	DATAO	PI,ERRCNT		;DISPLAY
	TLNN	DING			;RING TTY BELL ?
	JRST	.+3			;NO
	MOVEI	BELL			;YES
	PNTAF
ERRX2:	SKIPE	COREXF			;IN SIMULATION ?
	JRST	CORER1			;YES
	JRST	FSTER1			;NO
;HALT AND SAVE AC'S

GOING:	0
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	CONO	PI,PIOFF
	MOVEM	0,$ACC0
	HALT	BEGIN			;%%% FOR NOW

OUT:	0
	SETZM	EXIT1#			;CLEAR EXIT FLAG
	MOVEI	10,FSTANS		;SAVE FAST LOOP ANSWERS
	BLT	10,FSTANS+7
	MOVEI	0,7			;INIT INST CNT,
	MOVEM	0,INTCNT#
	MOVEM	0,ACCNT#		;AND AC CNT
	PNTNM
	PNTMSG	[ASCIZ/
**********/]
	SKIPE	USER
	JRST	OUTX-1
	MOVE	0,CONSW
	TRNE	INHCLK
	JRST	OUTX
	JSR	RUNTIM			;PRINT RUN TIME
OUTX:	PNTMSG	0,[ASCIZ/
RANDOM INSTRUCTION FAILURE
    INST GROUP        OPERANDS           /]
	MOVEI	[ASCIZ/SLOW ANS          SIM ANS/]
	SKIPN	COREXF
	MOVEI	[ASCIZ/FAST ANS          SLOW ANS/]
	PNTAL				;PRINT HEADER
	SETZM	PNTSPC

OUT1:	MOVE	10,INTCNT
	SOJE	10,LOOP			;MONITOR CNT
	MOVEM	10,INTCNT
	SETCA	10,0
	ANDI	10,7
	PCRL
	SETZM	PNTSPC
	MOVEI	0,1			;PRINT FIRST DIGIT
	PNT1				;OF INST GROUP AND,
	MOVE	0,10
	PNT1				;2ND DIGIT
	JSR	SLSHSP			;PRINT / SPACE 
	MOVE	0,INSBLK-1(10)
	PNTHW				;PRINT INST

OUT2:	JSR	ACPNT1			;PRINT AC
	MOVE	0,RAND(10)
	PNTHW				;PRINT OPERANDS
	JSR	ACPNT1			;PRINT AC
	MOVE	0,FSTANS(10)		;PRINT FAST ANS/SIM - SLOW ANS
	PNTHW				;PRINT AC
	JSR	ACPNT1			;PRINT AC NUMBER
	MOVE	0,ACS(10)
	SKIPN	COREXF
	MOVE	0,ANSBLK(10)
	PNTHW				;PRINT SLOW ANS/SIM - SIM ANS
	SOSLE	ACCNT
	JRST	OUT1

OUT3:	SKIPE	EXIT1
	JRST	OUT4
	PNTMSG	[ASCIZ /
                  / ]			;PRINT MARGIN
	SETOM	EXIT1
	JRST	OUT2
OUT4:	SETOM	PRNT
	PCRL
	PNTMSG	[ASCIZ/
BASE RANDOM NUMBER = /]
	MOVE	RANDBS
	PNTHW				;PRINT RANDOM BASE
	PCRL
OUT5:	SKIPN	SIMFLG			;SIMULATION INHIBITED ?
	JRST	@OUT			;YES
	SKIPN	COREXF			;SLOW LOOP FAILURE ?
	JRST	SIMFST			;NO
	PNTMSG	[ASCIZ/
INSTRUCTION SIMULATION - CORE LOOP INST # /]
	HRRZ	INPC			;COMPUTE INST NUMBER
	SUBI	CORIN1
	IDIVI	3
	ADDI	1
	PNT1				;PRINT
	PNTMSG	[ASCIZ/
----------
/]
	MOVS	10,[ACS,,SIMBLK]
	BLT	10,ACS+10		;RESTORE SIM OPERANDS
	JRST	SIMIP			;SIM & PRINT INSTRUCTION

SLSHSP:	0				;PRINT / SPACE  
	PNTMSG	[ASCIZ X/ X]
	JRST	@SLSHSP

ACPNT1:	0				;PRINT SPACE
	MOVEI	0,SPACE
	PNTA
	MOVE	10,ACCNT		;GET AC NUMBER
	SETCA	10,0
	ANDI	10,7
	MOVE	0,10
	SETZM	PNTSPC
	PNT1				;PRINT IT
	JSR	SLSHSP
	JRST	@ACPNT1

LOOP:	PCRL
	MOVEI	0,17			;PRINT 17
	SETZM	PNTSPC
	PNT2
	JSR	SLSHSP
	PNTMSG	[ASCIZ/   EXIT       /]	;PRINT EXIT
	JRST	OUT2
PNTTOT:	0
	SKIPE	USER
	JRST	.+3
	TRNE	INHCLK			;NO TIME IF CLOCK INHIBITED
	JRST	.+2
	JSR	RUNTIM			;PRINT RUN TIME
	PNTMSG	[ASCIZ/
TOTAL ERRORS = /]
	MOVE	ERRTLS
	PNTDEC				;PRINT TOTAL ERRORS
	PNTMSG	[ASCIZ/
BASE RANDOM NUMBER = /]
	MOVE	0,RANDBS
	PNTHW				;PRINT RANDOM BASE
	PCRL
	SWITCH
	TLNN	RSTART			;RESTART PROGRAM ?
	JRST	@PNTTOT			;NO, CONTINUE
	JRST	SFSTRT			;YES, RESTART AS STAND-ALONE

TSTIMU:	SETZM	0
	CALLI	27			;GET USER RUN TIME
	IDIVI	^D1000			;CHANGE TO SECONDS
	JRST	TSTIMD

;TEST RUN TIME SUBROUTINE
;PRINTS TIME AT 15 MINUTE INTERVALS OR WHEN REQUESTED

TSTIME:	0
	SKIPE	USER
	JRST	@TSTIME
	SKIPN	CLKON
	JRST	@TSTIME
	PUT	0
	PUT	1
	GO	TIMUPD			;UPDATE TIME
	SUB	TSTIMR
	MOVE	1,HERTZ
	CAIE	1,^D60			;60 HZ. ?
	JRST	TSTIMB			;NO, 50
	CAIGE	^D<60*30*30>
	JRST	TSTIMF			;NOT QUARTER HOUR YET
TSTIMC:	SETOM	TIMFRC
	JSR	TSTIMA			;GO PRINT TIME
TSTIMF:	GET	1
	GET	0
	JRST	@TSTIME
RUNTIM:
TSTIMA:	0
	SKIPN	CLKON
	JRST	@TSTIMA
	SKIPE	PNTFLG			;INTERRUPTED OUT OF PRINT ROUTINE
	JRST	@TSTIMA			;YES, DO NEXT CLOCK
	PUT	0
	PUT	1
	PNTMSF	[ASCIZ/
RUN TIME = /]
	SKIPE	USER
	JRST	TSTIMU			;USER RUN TIME
	GO	TIMUPD			;UPDATE TIME
	SKIPE	TIMFRC#			;REQUESTED TIME, IF SO DON'T
	GO	TIMQHR			;UPDATE QUARTER HOUR COMPARE
	IDIV	HERTZ			;CONVERT TO SECONDS
TSTIMD:	IDIVI	^D<60*60>		;CONVERT TO HOURS
	MOVEM	1,TIMAC1#		;SAVE MIN:SEC
	PNTDCF				;PRINT HOURS
	MOVEI	[ASCIZ/:/]
	PNTAF
	MOVE	0,TIMAC1		;RETURN MIN:SEC
	IDIVI	^D60			;CONVERT TO MINUTES
	MOVEM	1,TIMAC1		;SAVE :SEC
	PNTDCF				;PRINT MINUTES
	MOVEI	[ASCIZ/:/]
	PNTAF
	MOVE	0,TIMAC1		;RETURN :SEC
	PNTDCF				;PRINT SECONDS
	PCRLF
	SETZM	TIMFRC
	GET	1
	GET	0
	JRST	@TSTIMA

TSTIMB:	CAIGE	^D<60*30*25>		;50 HZ QUARTER HOUR
	JRST	TSTIMF			;NO
	JRST	TSTIMC

TIMQHR:	PUT	0
	MOVEI	0,^D<60*30*30>		;60 HZ
	SKIPE	CYCL60
	MOVEI	0,^D<60*30*25>		;50 HZ
	ADDM	0,TSTIMR		;UPDATE QUARTER HOUR COMPARE
	GET	0
	RTN
TIMUPD:	MOVEI	1
	CLOKOP				;GET -11 TIME
	MOVEM	TTHIS#			;SAVE AS THIS TIME
	SUB	TLAST#			;SUB TIME AT LAST READ
	ADDM	TICKS			;ADD INTERVAL TO TOTAL TIME
	MOVE	TTHIS
	MOVEM	TLAST			;UPDATE LAST READ TIME
	MOVE	TICKS
	RTN

;SIMULATE INSTRUCTION

SIMI:	0
	MOVEM	0,SAVAC
	MOVE	[1,,SAVAC+1]
	BLT	SAVAC+17		;SAVE AC'S
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN			;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2			;SET FOR FIRST INST
	MOVE	P,PLIST
	MOVEI	$PSHER
	PUSH	P,0
	GO	SENTRY			;GO TO SIMULATOR

	MOVS	[1,,SAVAC+1]
	BLT	17			;RESTORE AC'S
	MOVE	0,SAVAC
	JRST	@SIMI

;SIMULATE INSTRUCTION, PRINT

SIMIP:	SETZM	MASK			;ALLOW PRINTOUT
	JSR	SIMI			;GO SIMULATE
	PCRL
	JRST	@OUT

MULAC:	BLOCK	4
DIVAC:	BLOCK	4
RAND:	BLOCK	10
INSBLK:	BLOCK	10
ANSBLK:	BLOCK	10
FSTANS:	BLOCK	10
SAVAC:	BLOCK	20
SIMBLK:	BLOCK	^D10
;SIMULATE AND PRINT ALL INSTRUCTIONS
;FAST LOOP RELIABILITY/SPEED FAILURE

SIMFST:	PNTMSG	[ASCIZ/
INSTRUCTION SIMULATION - FAST LOOP FAILURE
----------
/]
	SETZM	MASK
	MOVE	[1,,SAVAC+1]
	BLT	SAVAC+17		;SAVE AC'S
	MOVE	[INSBLK,,ACS+11]
	BLT	ACS+17			;SETUP INSTRUCTIONS
	MOVE	[RAND,,ACS]
	BLT	ACS+7
	SETZM	ACS+10			;SETUP OPEARANDS
	MOVEI	11
SIMFS1:	MOVEM	INPC			;SET INPC TO FIRST INSTRUCTION
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN			;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2			;SET FOR FIRST INST
	MOVE	P,PLIST
	MOVEI	$PSHER
	PUSH	P,0
	GO	SENTRY			;GO TO SIMULATOR

	HRRZ	PC
	CAIE	17			;COMPLETED SIM ?
	JRST	SIMFS1			;NO
	MOVS	[1,,SAVAC+1]
	BLT	17			;RESTORE AC'S
	PCRL
	JRST	@OUT
SUBTTL	INTERRUPT RELIABILITY MAIN DISPATCHING

BEGINT:	SKIPE	USER
	JRST	BEGMEM			;CAN'T RUN INTERRUPT IN USER MODE
	SUBTST
	JSR	TSTIME
	SETZM	MAPNEW
	MAPMEM				;REMAP MEMORY  - 0 TO 256K
	MOVSI	(JFCL)			;NO-OP ERMORE
	MOVEM	ERMORE
	SWITCH
	TRNN	INHADB			;WANT ADDRESS BREAK TEST
	GO	ADBRK
	SWITCH				;GET CONSOLE SWITCHES
	TRNN	INHII			;WANT INSTRUCTION INT. TEST
	GO	INTXCT			;YES
	SWITCH
	TRNN	INHMI			;WANT BASIC METER TEST
	GO	MTRTST
	SWITCH
	TRNN	INHBLT			;WANT BLT TEST
	GO	BLTTST
	SWITCH
	TRNN	INHPAR			;WANT PARITY TEST
	GO	PARTST
	SWITCH
	TRNN	INHNXM			;WANT NON-EX-MEM TEST
	GO	NXMTST
	SWITCH
	TLNE	TOTALS			;WANT SYSTAT
	GO	SYSTAT			;YES
	JRST	BEGMEM			;TO NEXT TEST
SUBTTL	BASIC METER TEST

;INHIBIT VIA CONSOLE SWITCH 23 ON A 1
	T=SIXBTZ BASIC METER TEST
	A=0
	C=0

MTRTST:	SUBTST
	CLRBTH
	MOVE	[PUSHJ P,STATUS]
	MOVEM	ERMORE			;MORE INFO TYPE OUT
	MOVE	4,[JSR ATRP]		;GOOD METER TRAP
	MOVEM	4,514			;SET METER INTERRUPT
	MOVE	5,[JSR BTRP]		;INCORRECT METER TRAP
	GO	RANCHN			;INIT RANDOM CHANNEL
	MOVEM	4,CLKCHN		;SAVE METER ASSIGNMENT
MTRLOP:	MOVNI	15,^D200000
	SETZM	CLKFOO
	CONO	PI,12377		;CLEAR AND ENABLE PI SYSTEM
	CONO	TIM,TIMON!TIMCDON!3203
	CONO	MTR,(4)			;ENABLE METER ON CHANNEL IN 4
	MOVNI	15,^D200000
	AOJGE	15,.+2
	JRST	.-1			;WAIT FOR INTERRUPT A LONG TIME

MTRP1:	CONI	PI,PISTAT#		;SAVE PI STATUS
	CONI	APR,APRSTS#		;AND APR STATUS
	CLRBTH
	CONO	MTR,0
	SKIPE	CLKFOO#			;DID WE GET INTERRUPT FROM METER
	RTN				;RETURN

	ERROR1	(13,C,A,WAITED FOR COUNT OF 20K AOJGE'S^YET GOT NO METER INTERRUPT,CHECK BASIC METER DIAGNOSTIC)
	ERLP2	MTRLOP
	RTN				;EXIT TEST
ATRP:	0				;HERE IF METER INTERRUPT
	CONO	MTR,0			;CLEAR METER
	CLRBTH
	AOS	INTCNT-1(4)		;SAVE THIS CHANNELS INTERRUPT COUNT
	SETOM	CLKFOO			;TELL MAIN LOOP IT WAS THE METER
	JRST	MTRP1			;AND RETURN TO MAIN LOOP

BTRP:	0				;HERE IF ON WRONG CHANNEL
	CONI	PI,PISTAT#		;SAVE PI STATUS
	CONI	APR,APRSTS		;SAVE APR STATUS
	CONO	MTR,0
	CLRBTH
	SETZM	CLKFOO			;INFORM MAIN LOOP THIS WASN'T THE METER
	ERROR1	(13,C,A,GOT INTERRUPT ON WRONG CHANNEL,)
	ERLP2	MTRLOP
	CLRBTH
	RTN				;EXIT TEST
SUBTTL	ADDRESS BREAK TEST

;INHIBITTED VIA CONSOLE SWITCH 21 ON A 1
;RANDOMLY ADDRESS BREAK ON DATA FETCH
;USING DATAO PTR WITH ADDRESS BREAK AND DATA FETCH

	T=SIXBTZ ADDRESS BREAK TEST
	A=0				;NO ACTUAL DATA
	C=1				;BREAK ADDRESS

ADBRK:	SUBTST
	MOVEI	14,LOPCNT		;LOOP COUNT
	MOVE	[PUSHJ P,ADBDAT] ;SET UP FOR MORE INFO
	MOVEM	ERMORE
	CLRBTH
	MOVE	LPGFTR
	MOVEM	ABSPGF#			;SAVE NORMAL PAGE FAIL NEW PC
	MOVE	[ADBTST]		;SET UP BREAK TRAP
	MOVEM	LPGFTR			;INTO PAGE TRAP LOCATION
	SETZM	LEUPFW			;CLEAR TRAP WORD 
	GO	RANDM1			;GET NUMBER FOR ADDRESS BREAK
	ANDI	1,-1			;MAKE REASONABLE MEMORY ADDRESS
	CAILE	1,@MEMSIZ+1		;IF ADDRESS IS LESS THAN MEMSIZE IT'S OK
	AND	1,MEMSIZ+1		;INSURE NO NON-EX-MEM
	CAIGE	1,20			;MUST BE OUT OF FAST AC'S
	TRO	1,20			;IF ISN'T THEN ADJUST
	HRRZM	1,BRKADR		;SAVE BREAK ADDRESS
	HRLI	1,LDATAF		;ADDRESS BREAK - DATA FETCH - EXEC
	MOVE	2,[124124,,124124]
ADBIOT:	DATAO	APR,1			;SET UP BITS(CONSOLE SWITCHES)
ADBXX:	MOVE	2,@1			;CAUSE DATA FETCH
	JFCL
	ERROR1	(13,C,A,ADDRESS BREAK DID NOT OCCUR ON DATA FETCH,)
	ERLP2	ADBIOT
ADBRKX:	CLRBTH
	MOVE	ABSPGF
	MOVEM	LPGFTR			;RESORE NORMAL PAGE PAIL NEW PC
	LOPTST	ADBRK+3
	RTN				;EXIT TEST
	A=4				;ACTUAL DATA
	C=10				;TRAP NUMBER
ADBTST:	SETZ	11,			;CLEAR BREAK BITS
	DATAO	APR,11			;RESET IT SO WE CAN SEE IT
	MOVEI	10,230000
	HLRZ	4,LEUPFW
	TRZ	4,7000			;CLEAR ADR BREAK UNDEFINED BITS
	CAME	4,10
	ERROR1	(13,C,A,ADDRESS BREAK TRAP CODE IS INCORRECT,)
	ERLP2	ADBIOT

	A=11
	C=10

PAGCHK:	HRRZ	10,BRKADR
	HRRZ	11,LEUPFW		;GET STORED ADDRESS
	CAME	10,11			;THEY SHOULD BE THE SAME
	ERROR1	(13,C,A,INCORRECT VIRTUAL PAGE NUMBER STORED ON BREAK,)
	ERLP2	ADBIOT

	A=4
	C=[ADBXX]			;CORRECT AND ACTUAL DATA
	HRRZ	4,LPFWPC		;GET PC
	CAIE	4,ADBIOT+1		;CORRECT?
	ERROR1	(13,C,A,INCORRECT PC STORED ON ADDRESS BREAK,)
	ERLP2	ADBIOT
	CLRBTH
	AOS	BRKS			;KEEP TRACK OF SUCCESFUL BREAKS
	GO	DATBRK			;CHECK THAT DATA WASN'T STORED
	GO	BRKWRT			;CHECK BREAKS ON WRITES
	JRST	ADBRKX
DATBRK:	MOVE	3,@BRKADR		;GET THE DATA WE FIRST WANTED
	CAMN	2,[124124,,124124]	;IF THEY MATCH IT MIGHT BE OK!
	RTN				;SO IGNORE AND EXIT
	CAME	2,3			;ARE THEY EQUAL
	RTN				;NO ITS OK NOW(DATA FETCH DID NOT OCCUR)
	ERROR1	(13,C,A,ADD. BRK. ON DATA FETCH ALLOWED DATA TO BE FETCHED AND STORED,)
	ERLP2	ADBIOT
	CLRBTH
	RTN				;EXIT TEST

ADBDAT:	MOVEI	[ASCIZ/
ADDRESS OF DATA TRYING TO FETCH = /]
	PNTAL
	HRRZ	BRKADR
	PNT6
	MOVEI	[ASCIZ/
/]
	PNTAL
	RTN				;RETURN TO HANDLER

ADBDT1:	MOVEI	[ASCIZ/
TRYING TO WRITE A -1 INTO ADDRESS /]
	PNTAL
	MOVEI	AREA
	PNT6
	MOVEI	[ASCIZ/
/]
	PNTAL
	RTN	
	A=0				;NO ACTUAL DATA
	C=[AREA]			;DATA ADDRESS

BRKWRT:	SUBTST
	CLRBTH
	MOVE	[PUSHJ P,ADBDT1]
	MOVEM	ERMORE			;ADDITIONAL TYPEOUT
	MOVE	[WRTCHK]
	MOVEM	LPGFTR			;SET UP TRAP
	SETZM	LEUPFW
	SETZM	AREA			;CLEAR LOCATION TO WRITE TO
	SETO	10,			;WORD WE WILL TRY TO WRITE
	DATAO	APR,[LWRITE,,AREA#] ;SET UP WRITE TRAP
	MOVEM	10,AREA			;DO MEMORY WRITE TO CAUSE BREAK
	JFCL
	ERROR1	(13,C,A,ADDRESS BREAK DID NOT OCCUR ON DATA WRITE,)
	ERLP2	BRKWRT
	DATAO	APR,[0]			;CLEAR BREAK
	JRST	CPOPJX			;EXIT TEST

	A=AREA				;DATA STORED
	C=[0]

WRTCHK:	DATAO	APR,[AREA]		;CLEAR BREAK ENABLES
	SKIPE	AREA			;DID WRITE GET DONE?
	ERROR1	(13,C,A,ADDRESS BREAK OCCURED BUT DATA WAS WRITTEN INTO MEMORY)
	ERLP2	BRKWRT
	AOS	BRKS			;COUNT ADDRESS BREAKS
	JRST	CPOPJX

CPOPJX:	MOVSI	(JFCL)
	MOVEM	ERMORE
	RTN				;EXIT WITH ERMORE NO-OP'ED
SUBTTL	INSTRUCTION INTERRUPTION TEST
;INHIBIT VIA CONSOLE SWITCH 22 ON A 1

;THIS SUBROUTINE IS USED TO TEST THE INTERRUPTABILITY
;OF ALL CLASSES OF INSTRUCTIONS WITH THE EXCEPTION
;OF THE TWO PART INSTRUCTIONS (I.E. BLT BYTE ETC.)
;IT IS ENTERED WITH AC1 CONTAINING THE INSTRUCTION TO BE
;EXECUTED AND THE NUMBER OF TIMES TO TEST THE LOOP IN AC2.
;THE METER IS USED FOR CAUSING THE INTERRUPTS. AND IT RUNS 
;ON RANDOM CHANNELS

INTINS:	SUBTST
	MOVE	16,[PUSHJ P,TYPINS]	;SET UP ERMORE TRAP
	MOVEM	16,ERMORE
	SETZM	AOJFLG#
	CLRBTH
	MOVEM	1,INTBLK		;SET UP FOR BLT
	MOVE	1,[XWD INTBLK,INTBLK+1]	;BLT POINTER
	BLT	1,INTBLK+2000-1		;FILL LOOP ADDRESSES
	MOVE	4,[JSR INTTRP]		;GOOD TRAP
	MOVEM	4,514			;SET METER INTERRUPT
	MOVE	5,[JSR ERRTRP]		;BAD TRAP
	GO	RANCHN			;TURN ON A RANDOM CHANNEL(APR CLK)
	MOVEM	4,CLKCHN		;SAVE CURRENT ASSIGNMENT
INTXX:	CLRBTH
	CONO	TIM,TIMCLR!TIMON!TIMCDON!144
	CONO	PI,PION+CHNON+177	;TURN ON FULL PI SYSTEM
	CONO	MTR,(4)			;CAUSE INTERRUPT AFTER 100 MICRO-SEC
	JRST	INTBKA			;START INSTRUCTION LOOP
INTTRP:	0				;HERE IF PI REQUEST FROM ABOVE
	CONO	MTR,0
	HRRZ	3,.-1			;GET PC OF REQUEST
	CAILE	3,INTBLK+2000		;IS IT OUT OF ERROR HANDLER INSTRUCTION?
	JRST	NOGOOD			;YES IT WAS SO INS CAN NOT INT.
	ERLP2	INTXX
	CLRBTH
	CAIN	3,INTBLK+2000		;WAS IT THE AOJGE
	JRST	INTTRX			;YES
	AOS	INTCNT-1(4)		;KEEP TRACK OF THIS CHANNELS INTERRUPTS
	MOVSI	(JFCL)			;NO-OP ERMORE
	MOVEM	ERMORE
	AOS	INSCNT#			;KEEP TRACK OF TIMES HERE
	CLRBTH
	RTN	

INTTRX:	AOS	AOJGX#			;TELL HOW MANY TIMES WE GOT IT THERE.
	SETOM	AOJFLG#			;TELL MAIN CODE
	JRST	INTXX			;AND LOOP TEST
ERRTRP:	0				;HERE IF ON WRONG CHANNEL
	CONI	PI,PISTAT		;SAVE PI STATUS
	CONI	APR,APRSTS		;AND APR STATUS
	CONO	MTR,0
	MOVEI	[ASCIZ/
ERROR DURING INSTRUCTION INTERRUPTION TEST
RECIEVED INCORRECT INTERRUPT ON CHANNEL /]
	PNTAL
	MOVE	CLKCHN			;GET AND TYPE CLOCK CHANNEL
	PNT1
	GO	STATUS			;TYPE OUT PERTINANT DATA
	AOS	SPRCNT#			;BUMP SPURIOUS INTERRUPT COUNTER
	MOVEI	[ASCIZ/
ERROR COUNTED AS SPURIOUS AND WILL BE IGNORED

/]
	PNTAL
	SETZM	AOJFLG#
	JEN	@ERRTRP
INTBKA:	SKIPE	AOJFLG			;SKIP IF HERE BECAUSE OF SOJGE
	MOVEI	1,^D100			;LOOP 100 TIMES MAX.
	MOVE	[SOJGE	1,INTBLK]
	MOVEM	BUFEND-1
	MOVE	[JRST NOGOOD]
	MOVEM	BUFEND
	JRST	INTBLK

	T=SIXBTZ INSTRUCTION INTERRUPTION TEST (PART 1)
	A=0
	C=0
NOGOOD=.
ERRLOC:	CONO	MTR,0
	ERROR1	(13,C,A,INTERRUPT DID NOT OCCUR AFTER 200000 INSTRUCTIONS)
	ERLP2	INTXX
	CLRBTH
	RTN				;RETURN

TYPINS:	MOVEI	[ASCIZ/SEQUENCE STARTS AT:/]
	PNTAL
	MOVEI	INTBLK			;GET SEQUENCE START ADDRESS
	PNT6				;PRINT IT
	MOVEI	[ASCIZ/
ERROR INSTRUCTION:	/]
	PNTAL
	MOVE	0,INTBLK
	PNTHW				;GET AND TYPE ERROR DATA (INST)
	MOVEI	[ASCIZ/
INTERRUPT SHOULD HAVE OCCURED ON CHANNEL: /]
	PNTAL
	MOVE	CLKCHN
	PNT1				;GET AND PRINT CLOCK CHANNEL
	MOVEI	[ASCIZ/
/]
	PNTAL
	RTN				;RETURN TO SENDER

	XLIST
REPEAT	0,<
SUBTTL	IOT INTERRUPTION TEST (TTY)
;INHIBIT VIA CONSOLE SWITCH 23 ON A 1

;COME HERE TO TEST IOT INTERRUPTS ON THE CONSOLE TTY
;DONE VIA CONO TO THE TTY WITH THE TTO FLAG

	T=SIXBTZ TTY TEST - IO BUS INTERRUPTS
	A=0
	C=0

TTYTST:	MOVEI	14,LOPCNT		;LOOP COUNT
	MOVE	4,[JSR TTGOOD]		;GOOD TRAP
	MOVE	5,[JSR TTBAD]		;INCORRECT TRAP
	GO	RANCHN			;INIT RANDOM TRAPS
TTYLOP:	CLRBTH
	CONO	PI,2377			;ENABLE PI SYSTEM
	MOVE	16,[1,,-1]		;TIME OUT COUNT
	CONO	TTY,1B32(4)		;ENABLE TTY ON CHANNEL IN 4
	SOJGE	16,.			;WAIT FOR INTERRUPT
	ERROR1	(13,C,A,TTY DID NOT CAUSE INTERRUPT ON IO BUS,)
	ERLP2	TTYLOP
	CLRBTH
	RTN				;EXIT TEST

TTGOOD:	0				;FOR JSR
	AOS	INTCNT-1(4)		;BUMP INTERRUPT COUNT
	AOS	TTYCNT			;AND TTY COUNT
	CLRBTH
	LOPTST	TTYTST+1

TTBAD:	0				;FOR JSR
	CONI	APR,APRSTS		;SAVE APR STATUS
	CONI	PI,PISTAT		;AND PI STATUS
	MOVE	[PUSHJ P,STATUS]	;ENABLE ERMORE
	MOVEM	ERMORE
	ERROR1	(13,C,A,TTY CAUSED INTERRUPT ON INCORRECT CHANNEL,)
	ERLP2	TTYLOP
	MOVSI	(JFCL)			;NO-OP ERMORE
	MOVEM	ERMORE
	CLRBTH
	RTN				;FOR EXIT

>
	LIST
SUBTTL	PARITY INTERRUPT TEST
;INHIBIT VIA CONSOLE SWITCH 25 ON A 1

;COME HERE TO TEST PARITY ERROR INTERRUPTS ON RANDOM CHANNELS

	T=SIXBTZ PARITY INTERRUPT TEST
	A=PARWRD#
	C=PARDAT#

PARTST:	SUBTST
	MOVEI	14,LOPCNT		;LOOP COUNT
	SKIPN	CLKON
	JRST	.+4			;CLOCK INHIBITED
	GO	TIMUPD			;UPDATE TIME
	SETZB	TLAST			;SET LAST TIME=0, CAUSE CLK IS RESTARTED
	CLOKOP				;TURN OFF -11 CLOCK
PARTS1:	CLRBTH
	SETZM	PCSHFLG#
	MOVE	[PUSHJ P,STATUS]	;SETUP ERMORE
	MOVEM	ERMORE
	MOVE	4,[JSR GODPAR]
	MOVE	5,[JSR BADPAR]
	GO	RANCHN			;INIT RANDOM CHANNEL
PARLOP:	CLRBTH
	CONO	PI,2377			;ENABLE PARITY INTERRUPTS
	CONO	APR,LEPAER(4)		;ENABLE ERROR CHANNEL
	MOVE	[-1,,-1]		;PARITY WORD
	MOVEM	PARWRD			;SAVE IT
	MOVE	16,[77,,-1]		;TIME OUT COUNT FOR PARITY ERROR
	CONO	PI,LEVNPD!PIOFF		;ALLOW WRITE EVEN PARITY
	MOVEM	PARDAT			;STORE WORD TO READ
	CONO	PI,2377
	JRST	PARCSH			;WRITE-BACK CACHE IF ON
PARNOC:	MOVE	PARDAT			;CAUSE PARITY ERROR
	SOJGE	16,.			;WAIT FOR IT
PARCFL:	CONI	APR,APRSTS
	CONI	PI,PISTAT
	CLRBTH
	ERROR1	(13,C,A,NO PARITY ERROR ON READING EVEN PARITY,)
	ERLP2	PARLOP
	GO	PARCLK			;REENABLE CLOCK IF ALLOWED
	RTN				;RETURN IF PROCEED FROM ERROR
GODPAR:	0				;FOR JSR

	GO	PARCRS			;RESET CACHE IF ON

	AOS	PARGEN			;COUNT PROGRAM PARITY REQUESTS
	AOS	ERRCNT			;AND ERROR INTERRUPT COUNTER
	CLRBTH
	SETZM	PARDAT
	MOVSI	(JFCL)			;NO-OP ERMORE
	MOVEM	ERMORE
	SWITCH
	TLNE	RELIAB			;FAST CYCLE WANTED ?
	SOJGE	14,PARTS1		;LOOP TILL 14 = 0
	GO	PARCLK			;REENABLE CLOCK
	RTN

BADPAR:	0				;FOR JSR

	GO	PARCRS			;RESET CACHE IF ON

	AOS	SPRCNT			;COUNT SPURIOUS ERRORS
	CLRBTH
	ERROR1	(13,C,A,RECEIVED PARITY ERROR INTERRUPT ON WRONG CHANNEL,)
	ERLP2	PARLOP
	CLRBTH
	SETZM	PARDAT
	MOVSI	(JFCL)			;NO-OP ERMORE
	MOVEM	ERMORE
	GO	PARCLK			;REENABLE CLOCK
	RTN
PARCSH:	SETZM	PCSHFLG#
	CONI	PAG,0
	TRNE	0,LCASLO!LCASLD		;IS CACHE ON ?
	JRST	.+2			;YES
	JRST	PARNOC			;NO

	SETOM	PCSHFLG
	MOVE	0,[701540,,0]		;CACHE WRITE-BACK INVALIDATE
	MOVE	1,[CONSZ APR,LCASWB]	;CACHE SWEEP BUSY
	MOVE	2,[SOJN 4,1]		;WAIT FOR DONE OR PARITY INTERRUPT
	MOVE	3,[JRST	PARCFL]		;COMPLETED, NO PARITY INTERRUPT
	MOVEI	4,-1			;WAIT COUNT
	JRST	0			;START CACHE SWEEP

PARCRS:	SKIPN	PCSHFLG			;IS CACHE ON ?
	RTN				;NO

	CONO	PAG,LCASLO!LCASLD!LTRPEN
	RTN				;YES, REENABLE IT

PARCLK:	SKIPN	CLKON
	RTN				;CLOCK INHIBITED
	SETOM
	CLOKOP				;TURN -11 CLOCK BACK ON
	AOS	TICKS			;ACCOUNT FOR RESYNC
	RTN
SUBTTL	NON-EXISTENT-MEMORY TEST
;INHIBIT VIA CONSOLE SWITCH 26 ON A 1

;COME HERE TO TEST NON-EX-MEM

	T=SIXBTZ NON-EX-MEM TEST
	C=1
	A=0

NXMTST:	SUBTST
	MOVEI	14,LOPCNT		;LOOP COUNT
	CLRBTH
	MOVE	4,[JSR NXMTRP]		;CORRECT TRAP INSTRUCTION
	MOVE	5,[JSR NONXM]		;INCORRECT TRAP
	GO	RANCHN			;GO GET RANDOM CHANNEL
	GO	RANDM1			;AND RANDOM NON ZERO DATA
	ANDI	1,-1			;MAKE LEGAL MA
	MOVE	MEMSIZ+1		;GET MEMORY SIZE
	CAIL	0,777777		;256K MACHINE
	JRST	NXM256			;YES SO DONT DO NXMTST
	CAMLE	1,0			;BEYOND LAST MEMORY LOCATION
	JRST	.+3			;YES
	ADDI	1,1000			;MAKE NEW MA
	JRST	.-3			;TEST IT AGAIN
	MOVEM	4,ERRCHN#		;SAVE ERROR ASSIGNMENT
NOMEM1:	CLRBTH
	CWRTBI				;CACHE WRITEBACK & INVALIDATE
	CONO	APR,LCNXER(4)		;CLEAR NON-EX-MEM AND SET ERROR CHANNEL
	CONO	PI,2377			;PUT ON THE CHANNELS
	MOVE	16,[1,,-1]		;TIME OUT COUNT
	CAM	(1)			;CAUSE NON-EX-MEM
	SOJGE	16,.			;LOOP TILL IT COMES
	ERROR1	(13,C,A,EXPECTED NON-EX-MEM INTERRUPT DID NOT OCCUR,C=REF ADR)
	ERLP2	NOMEM1
	CLRBTH
	RTN				;EXIT TEST
;COME HERE ON NON-EX-MEM INTERRUPT

NXMTRP:	0				;FOR JSR
	CONSO	APR,LNXMER		;IS NXM FLOP SET?
	ERROR1	(13,C,A,GOT NON-EX-MEM INTERRUPT WITHOUT NXM FLOP SET,)
	ERLP2	NOMEM1
	AOS	TOTNXM			;BUMP NON-EX-EM COUNT
	AOS	ERRCNT			;AND ERROR INTERRUPT COUNTER
	CLRBTH
	LOPTST	NXMTST+3

;GRIEF IF HERE - WE GOT AN INTERRUPT ON THE WRONG CHANNEL

NONXM:	0				;FOR JSR
	CONI	APR,APRSTS		;GET AND SAVE
	CONI	PI,PISTAT		;APR AND PI STATUS
	MOVE	[PUSHJ P,STATUS]	;SET UP ERMORE
	MOVEM	ERMORE
	ERROR1	(13,C,A,GOT NON-EX-MEM INTERRUPT ON THE WRONG CHANNEL,)
	ERLP2	NOMEM1
	CLRBTH
	RTN				;EXIT TEST

;HERE IF WE HAVE A 256K MACHINE

NXM256:	SETOM	NXMFLG			;INFORM PROGRAM THIS TEST IS NOT BEING DONE
	RTN				;EXIT NXMTST
SUBTTL	BLOCK TRANSFER TEST

;COME HERE TO TEST BIG BLT'S
;INHIBIT VIA CONSOLE SWITCH 24 ON A 1

	T=SIXBTZ BLOCK TRANSFER TEST
	C=BUFF
	A=0				;FOR NOW!

BLTTST:	SUBTST
	CLRBTH
	MOVE	4,[JSR BLTTRP]
	MOVEM	4,514			;SET METER INTERRUPT
	MOVE	5,[JSR BLTBAD]
	GO	RANCHN			;INIT RANDOM CHANNEL
	MOVE	16,[BUFF,,BUFF+1]	;BLT FROM - TO
	MOVMEM	RANDBS,BUFF
	BLT	16,BUFF+2000		;FILL TRANSFER BUFFER
	MOVE	16,[BUFF1,,BUFF1+1]	;RECEIVING BUFFER
	SETZM	BUFF1
	BLT	16,BUFF1+2000		;CLEAR BUFFER
	MOVE	16,[BUFF,,BUFF1]	;BLT FROM - TO
	SETZM	BLTAC
	MOVEI	1,^D100
	CONI	PAG,0
	TRNE	0,600000		;IS THE CACHE ON ?
	MOVEI	1,^D50			;YES
	CONO	TIM,TIMCLR!TIMON!TIMCDON(1)
	CONO	MTR,(4)
	CONO	PI,2377			;ENABLE INTERRUPT SYSTEM
	BLT	16,BUFF1+2000		;DO BLT

DATTST:	CONO	MTR,0			;CLEAR METER
	SKIPN	BLTAC			;DID BLT GET INTERRUPTED ?
	JRST	BLTNOI			;NO
	MOVE	1,BUFF			;CORRECT DATA
	MOVEI	2,BUFF1			;ACTUAL DATA STORED
DATLOP:	CAME	1,@2			;COMPARE
	JRST	DATERR			;GOT AN ERROR
	ADDI	2,1
	CAIG	2,BUFF1+2000		;FINISHED TESTING
	JRST	DATLOP			;NO
	AOS	BLTCNT			;YES
	CLRBTH
	RTN				;EXIT TEST
;COME HERE ON DATA ERROR IN BLOCK TRANSFER TEST

DATERR:	MOVMEM	<[GO	DATMOR]>,ERMORE
	ERROR1	(13,C,A,DATA COMPARE ERROR IN BLT TEST,)
	ERLP2	BLTTST
	CLRBTH
	RTN				;RETURN TO CHECK SOME MORE

DATMOR:	HRRZ	12,BLTAC		;GET E OF BLT WHEN INTERRUPTED
	CAME	1,12			;DID FAILING DATA = BLTAC AT INTERRUPT
	JRST	DAT001			;NO
	JRST	BLTFAL
DAT001:	SUBI	12,1
	CAME	1,12			;CHECK NEAR IT
	JRST	DAT002
	JRST	BLTFAL
DAT002:	RTN				;COULD BE REAL DATA ERROR

BLTFAL:	MOVEI	[ASCIZ/
ADDRESS OF FAILING DATA IS EQUAL TO BLT TO ADDRESS OR BLT TO ADDRESS-1
AT INTERRUPT TIME. BLT IS NOT STORING THE CORRECT POINTER WHEN
INTERRUPTED.
FAILING ADDRESS: /]
	PNTAL
	MOVE	12
	PNTOCT
	PCRL
	RTN				;RETURN TO ERROR HANDLER

BLTNOI:	CONI	TIM,1			;READ METER
	CONI	APR,APRSTS
	CONI	PI,PISTAT
	CLRBTH
	ERROR1	(13,0,1,INTERRUPT DID NOT OCCUR DURING BLT,A = CONI TIM)
	ERLP2	BLTTST
	CLRBTH
	RTN
;COME HERE ON INTERRUPT FROM METER DURING BLT TEST

BLTTRP:	0				;FOR JSR
	CONO	MTR,0
	AOS	INTCNT-1(4)		;COUNT THIS INTERRUPT
	MOVEM	16,BLTAC#		;SAVE CONTENTS OF BLTAC
	CLRBTH
	JRST	@BLTTRP			;FINISH BLOCK TRANSFER

;COME HERE ON INCORRECT METER INTERRUPT
	A=0
	C=0

BLTBAD:	0				;FOR JSR
	CONO	MTR,0
	AOS	SPRCNT			;COUNT AS SPURIOUS INTERRUPT
	ERROR1	(13,C,A,SPURIOUS METER INTERRUPT OCCURED,RESTARTING TEST)
	CLRBTH
	JRST	BLTTST			;RESTART BLOCK TRANSFER TEST
SUBTTL	RANDOM CHANNEL GENERATOR

;THIS SUBROUTINE TO INIT THE METER ON SOME RANDOM CHANNEL AND TO
;RETURN TO ALL OTHER CHANNELS AS ERRORS.
;ROUTINE IS ENTERED WITH AC4 CONTAINING THE CORRECT TRAP ADDRESS
;AND AC5 CONTAINS THE ERROR TRAP ADDRESS.

RANCHN:	MOVEM	4,CORTRP#		;SAVE CORRECT TRAP ADDRESS
	MOVEM	5,BADTRP#		;AND BAD CHANNEL TRAP
	MOVE	4,RA2#			;GENERATE RANDOM NUMBER
	ADD	4,RANDBS		;ADD IN BASE
	ROT	4,-1
	EQVB	4,RA2
	ANDI	4,7			;MASK OUT ALL BUT ASSIGNMENT
	CAIGE	4,2			;MUST BE CHANNEL 2 OR BETTER
	MOVEI	4,2
	MOVEM	4,CLKCHN#		;SAVE CLOCK CHANNEL
	MOVEI	4,44
	MOVE	5,BADTRP		;GET TRAPS FOR WRONG CHANNEL
	MOVEM	5,(4)			;SET ALL CHANNELS TO BAD
	ADDI	4,2
	CAIGE	4,60
	JRST	.-3
	MOVE	5,CORTRP		;GET CORRECT TRAP
	MOVE	4,CLKCHN		;GET CHANNEL NUMBER
	ROT	4,1
	MOVEM	5,40(4)			;STORE INSTRUCTION
	ROT	4,-1
	RTN
SUBTTL	STATUS REPORTER

;REPORT THE STATUS OF THE APR AND PI
;CALLED VIA "ERMORE" ROUTINE IN THE ERROR HANDLER

STATUS:	MOVEI	[ASCIZ/
APR STATUS	PI STATUS
/]
	PNTAL
	MOVE	APRSTS			;GET AND TYPE APR STATUS
	PNTHW
	MOVE	PISTAT			;GET AND PRINT PI STATUS
	PNTHW
	MOVEI	[ASCIZ/
/]
	PNTAL
	RTN				;RETURN TO SENDER
SUBTTL	GETINS - GET RANDOM INSTRUCTION

;THIS SUBROUTINE RANDOMLY RETRIEVES AN INSTRUCTION FROM A TABLE
;AND STORES IT IN AN AC FOR THE "INTINS" TEST TO USE

INTXCT:	GO	GETNUM			;GET TABLE POINTER
	ANDI	1,177774		;INSURE IT'S DIVISIBLE BY 4
	CAIL	1,INSTAB
	JRST	.+3			;IS IT IN THE TABLE AREA?
	ADDI	1,100			;NO ADD 100
	JRST	.-3			;CHECK IT AGAIN
	CAIG	1,INSEND		;IS IT BEYOND THE TABLE'S END?
	JRST	.+3			;NO
	SUBI	1,100			;SUBTRACT 100 TILL IT IS
	JRST	.-3			;CHECK AGAIN
	MOVEM	1,INDEX#		;SAVE INDEX POINTER
	MOVE	1,(1)			;GET INSTRUCTION TO TEST
	MOVE	2,INDEX
	MOVE	2,1(2)			;AND NUMBER OF TIMES TO DO IT
	MOVE	16,INDEX		;GET INDEX POINTER
	AOS	2(16)			;COUNT TIMES TESTED THIS INSTRUCTION
	GO	INTINS			;AND GO DO TEST
	RTN				;RETURN TO MAIN DISPATCHING


GETNUM:	SETZB	0,1			;CLEAR WORK AREA
	SKIPE	ONCEH#			;BEEN HERE BEFORE
	MOVE	1,LSTNUM#		;GET LAST NUMBER
	ADDI	1,4			;BUMP POINTER
	MOVEM	1,LSTNUM#		;SAVE NEW POINTER
	CAIGE	1,INSEND-INSTAB+1	;OUT OF BOUNDS
	JRST	.+3			;OK
	SETZM	ONCEH#			;CLEAR FLAG
	JRST	GETNUM			;LOOP FOR NEW NUMBER
	SETOM	ONCEH#			;SET FLAG TO SKIP SETUP
	ADDI	1,INSTAB
	RTN				;RETURN
SUBTTL	RANDOM NUMBER GENERATORS

;THIS ROUTINE GENERATES SOME RANDOM NUMBER WHICH MAY BE ZERO

RANDM0:	MOVE	0,RA2#			;GENERATE RANDOM NUMBER
	ADD	0,RANDBS		;ADD IN BASE
	ROT	0,-1
	EQVB	0,RA2
	MOVEM	1			;STORE IN AC1
	RTN				;RETURN

;THIS SUBROUTINE GENERATES A RANDOM NUMBER WHICH MAY NOT BE ZERO

RANDM1:	MOVE	0,RA2			;GENERATE RANDOM NUMBER THAT IS NOT =0
	ADD	0,RANDBS		;ADD IN BASE
	ROT	0,-1
	EQVB	0,RA2
	JUMPE	0,RANDM1		;LOOP IF NUMBER =0
	MOVEM	1
	RTN				;RETURN
SUBTTL	METER SYNCHRONIZATION ROUTINE

;THIS ROUTINE IS USED TO DETERMINE HOW MANY AOJNS AND CONSOS
;ARE EXECUTED IN 1 MSEC.

CSYNC:	SKIPE	TIMCNT#			;DONE THIS BEFORE?
	RTN				;YES DONT DO IT AGAIN
	SWITCH
	TLNN	OPRSEL			;OPERATOR SELECT MODE ?
	JRST	CSYNC2			;NO, JUST GO THEN
	MOVEI	CNFDAT			;SET UP INITIAL SWITCH MESSAGE
	PNTAL
	TTALTM				;WAIT FOR ALTMODE(ESCAPE)
	JRST	.-1
CSYNC2:	CONO	MTR,0
	CONO	TIM,TIMCLR
	MOVEI	15,3			;LOOP COUNT
	SETZB	16,TIMCNT#
	HRLZI	1,400000
	MOVE	2,[CONSO TIM,TIMDON]
	MOVE	3,[AOJN 1,2]
	MOVE	4,[SOJLE 15,CSYNC1]
	MOVE	5,[CONO TIM,TIMON!TIMCDON!3203]
	MOVE	6,[CONSO TIM,TIMDON]
	MOVE	7,[SOJA 16,6]
	MOVE	10,[CONO TIM,TIMON!TIMCDON!3203]
	MOVE	11,[SOJA 16,2]
	CLRBTH
	CONO	TIM,TIMON!TIMCDON!3203
	JRST	2			;START TIMING LOOP

CSYNC1:	TLC	1,400000		;DELETE BIT 0
	IMULI	1,^D6
	IDIVI	1,3			;TO GET NUMBER IN 1 ITERATION
	IDIVI	1,^D100			;TO GET NUMBER IN MSECS.
	MOVEM	1,TIMCNT
	RTN				;EXIT SYNC ROUTINE
;WAIT ROUTINE
;ROUTINE IS ENTERED WITH AC0 CONTAINING THE NUMBER OF MSECS. TO STALL
;THIS ROUTINE IS DONE IN FAST MEMORY.

WAIT:	SKIPN				;ANY ARGUMENT?
	RTN				;NO 0. MSEC. WAIT
	CONO	PI,PIOFF
	IMUL	0,TIMCNT		;COUNTS IN 1 MS X NO. OF MSECS.
	EXCH	1,[CONSO TIM,400000]	;WAIT IT OUT
	EXCH	2,[SOJGE 1]		;LOOP TILL -1
	EXCH	3,[JRST WATRET]		;AND ESCAPE
	JRST	1
WATRET:	EXCH	1,@.-4
	EXCH	2,@.-4
	EXCH	3,@.-4			;RESTORE AC'S AND RETURN
	CONO	PI,PION
	RTN				;EXIT WAIT
SUBTTL	TIMER
;TIME ROUTINE

;THIS ROUTINE IS ENTERED WITH AC0 CONTAINING THE INSTRUCTION
;WHICH CHECKS THE EVENT TO BE TIMED (MUST BE A CONSO)
;AC1 CONTAINS A NUMBER (0-3) TO DETERMINE THE TIME TO BE RETURNED
;I.E. 0 FOR MSECS., 1 FOR 10THS OF MSECS., 2 FOR 100THS OF MSECS.
;AND 3 FOR 1000THS OF MSECS.


TIMER:	CAILE	1,3			;FACTOR UP TO 1000THS
	SETZ	1,			;IF GREATER THAN 3 ASSUME MSECS.
	MOVEM	1,10			;AND SAVE IT
	CAIN	1,1			;TENTHS
	MOVEI	10,^D10
	CAIN	1,2			;HUNDREDTHS
	MOVEI	10,^D100
	CAIN	1,3			;THOUSANDTHS
	MOVEI	10,^D1000
	SKIPGE	1,			;IS IT NEGATIVE
	SETZM	10			;YES
	MOVEM	0,11			;PUT CONSO INTO 11
	SETZ	0			;START WITH AC = 0
	MOVE	12,[AOJN 11]		;COUNT INSTR. IN 12
	MOVE	13,[JRST TEXIT]		;EXIT INSTRUCTION
	CLRBTH
	CONO	MTR,			;START THE CLOCK
	CONO	TIM,TIMON!TIMCDON!3203
	JRST	11			;ENTER LOOP

;COME HERE TO FIGURE THE TIME AND EXIT WITH AC0 AND AC1 CONTAINING THE
;ANSWER. WHICH IS READY TO BE PRINTED OR TESTED AND ALSO STORE THE ANSWER
;IN CLKTIC AND CLKTIC+1

TEXIT:	SKIPE	10			;DON'T MULTIPLY IF 10 = 0
	IMUL	0,10			;MULTIPLICATION FACTOR
	IDIV	0,TIMCNT
	MOVEM	0,CLKTIC
	MOVEM	1,CLKTIC+1		;SAVE TICK TIME
	RTN				;AC0 HAS THE TIME!
SUBTTL	PROGRAM STATUS (SYSTAT)

;CALLED VIA SETTING CONSOLE DATA SWITCH 2 TO A 1

SYSTAT:	CLRBTH
	SKIPN	NXMFLG			;NON EX MEM TESTING BEING DONE?
	JRST	SYS1			;YES
	MOVEI	[ASCIZ/
THIS IS A 256K MACHINE
NON-EXISTENT-MEMORY TESTING IS NOT BEING DONE
/]
	PNTAL
SYS1=.
SYS2:
SYS3:	MOVEI	[ASCIZ/
STATUS OF /]
	PNTAL
	MOVEI	PGMNAM			;GET PROGRAM NAME
	PNTAL
	MOVEI	[ASCIZ/
PROGRAM TOTALS
--------------

CHANNEL 1 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT
	PNTDEC
	MOVEI	[ASCIZ/
CHANNEL 2 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT+1
	PNTDEC
	MOVEI	[ASCIZ/
CHANNEL 3 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT+2
	PNTDEC
	MOVEI	[ASCIZ/
CHANNEL 4 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT+3
	PNTDEC
	MOVEI	[ASCIZ/
CHANNEL 5 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT+4
	PNTDEC
	MOVEI	[ASCIZ/
CHANNEL 6 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT+5
	PNTDEC
	MOVEI	[ASCIZ/
CHANNEL 7 INTERRUPTS:	/]
	PNTAL
	MOVE	INTCNT+6
	PNTDEC
	MOVEI	[ASCIZ/
ERROR PIA INTERRUPTS:	/]
	PNTAL
	MOVE	ERRCNT
	PNTDEC
	MOVEI	[ASCIZ/
PROGRAM GENERATED PARITY ERRORS: /]
	PNTAL
	MOVE	PARGEN
	PNTDEC
	MOVEI	[ASCIZ/
PROGRAM GENERATED NXM'S:	/]
	PNTAL
	MOVE	TOTNXM
	PNTDEC
	MOVEI	[ASCIZ/
TOTAL SPURIOUS INTERRUPTS:	/]
	PNTAL
	MOVE	SPRCNT
	PNTDEC
	MOVEI	[ASCIZ/
TOTAL NUMBER OF ADDRESS BREAKS:	/]
	PNTAL
	MOVE	BRKS
	PNTDEC
	MOVEI	[ASCIZ/
LAST BREAK ADDRESS ON ADBRK(DATA FETCH):  /]
	PNTAL
	MOVE	BRKADR
	PNT6
	MOVEI	[ASCIZ/
BREAK ADDRESS ON ADDRESS BREAK(DATA WRITE): /]
	PNTAL
	MOVEI	AREA
	PNT6
	MOVEI	[ASCIZ/
TOTAL BLT'S DONE IN BLTSTS:	/]
	PNTAL
	MOVE	BLTCNT
	PNTDEC
	MOVEI	[ASCIZ/

FINISHED
/]
	PNTAL
	RTN				;EXIT SYSTAT
SUBTTL	MAIN CODE RESERVED STORAGE

CNFDAT:	ASCIZ/
SW18 = SPECIFY RANDOM BASE NUMBER
SW19 = INHIBIT CLOCK INTERRUPT
SW20 = INHIBIT MEMORY TESTING
SW21 = INHIBIT ADDRESS BREAK
SW22 = INHIBIT INSTRUCTION INTERRUPT
SW23 = INHIBIT BASIC METER
SW24 = INHIBIT BLT
SW25 = INHIBIT PARITY
SW26 = INHIBIT NXM
SW27 = INHIBIT DOUBLE PRECISION INSTRUCTIONS
SW28 = INHIBIT DOUBLE FLOATING POINT
SW29 = INHIBIT FLOATING POINT
SW30 = INHIBIT BYTE
SW31 = INHIBIT FIXED POINT
SW32 = INHIBIT RANDOM RELIABILITY
SW33 = SINGLE FAST LOOP
SW34 = JUST SIMULATION COMPARISIONS
SW35 = JUST INSTRUCTION COMPARISIONS
PLEASE TYPE AN ALTMODE WHEN SWITCHES DESIRED ARE SET
/
;SYSTAT TABLE

CLKTIC:	0				;TIME BETWEEN CLOCK TICKS
	0
TOTNXM:	0				;TOTAL NON-EX-MEMS
NXMFLG:	0				;-1 IF 256K MACHINE
ERRCNT:	0				;TOTAL ERROR INTERRUPTS
ERRCHN:	0				;LAST ERROR PIA ASSIGNMENT
CLKCHN:	0				;LAST CLOCK PIA ASSIGNMENT
INSCNT:	0				;TOTAL INTERRUPTED INSTRUCTIONS
	0
INTCNT:	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 1
	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 2
	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 3
	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 4
	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 5
	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 6
	0				;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 7
	0
SPRCNT:	0				;TOTAL NUMBER OF SPURIOUS INTERRUPTS
CURENT:	0				;LAST INSTRUCTION TESTED
PARGEN:	0				;TOTAL PROGRAM GENERATED PARITY ERRORS
BRKS:	0				;TOTAL NUMBER OF ADDRESS BREAKS
BRKADR:	0				;LAST ADDRESS BREAK ADDRESS
TTYCNT:	0				;TOTAL NUMBER OF TTY INTERRUPTS
BLTCNT:	0				;TOTAL NUMBER OF BLT'S DONE
BLICNT:	0				;TOTAL NUMBER OF BLKI'S DONE
BLOCNT:	0				;TOTAL NUMBER OF BLKO'S DONE
SYNC:	0				;AOJGE'S IN 1 CLOCK TICK.
SUBTTL	INSTRUCTION TABLE FOR INTXCT

;HERE BEITH THE INSTRUCTION TABLE
;ALL NON SKIP INSTRUCTIONS AND 1 PART INSTRUCTIONS ARE STORED HERE
;EACH ENTRY INTO THE TABLE INCLUDES:
;	1.AN INSTRUCTION TO TEST
;	2.THE NUMBER OF TIMES TO TRY IT
;	3.A STORAGE WORD TO TELL HOW MANY TIMES THIS PARTICULAR
;	  INSTRUCTION WAS TESTED
;	4.A RESERVED STORAGE WORD

	LOC	<<.+4>&777774>
INSTAB:	FAD	10,MEMLOC#
	5
	0
	0
	FAD	10,MEMLOC
	5
	0
	0
	FADM	10,MEMLOC
	5
	0
	0
	FADB	10,MEMLOC
	5
	0
	0
	FADRI	10,MEMLOC
	5
	0
	0
	FADRM	10,MEMLOC
	5
	0
	0
	FADRB	10,MEMLOC
	5
	0
	0
	FSB	10,MEMLOC
	5
	0
	0
	FSB	10,MEMLOC
	5
	0
	0
	FSBM	10,MEMLOC
	5
	0
	0
	FSBB	10,MEMLOC
	5
	0
	0
	FSBR	10,MEMLOC
	5
	0
	0
	FSBRI	10,MEMLOC
	5
	0
	0
	FSBRM	10,MEMLOC
	5
	0
	0
	FSBRB	10,MEMLOC
	5
	0
	0	FMP	10,MEMLOC
	5
	0
	0
	FMP	10,MEMLOC
	5
	0
	0
	FMPM	10,MEMLOC
	5
	0
	0
	FMPB	10,MEMLOC
	5
	0
	0
	FMPR	10,MEMLOC
	5
	0
	0
	FMPRI	10,MEMLOC
	5
	0
	0
	FMPRM	10,MEMLOC
	5
	0
	0
	FMPRB	10,MEMLOC
	5
	0
	0
	MOVE	10,MEMLOC
	5
	0
	0
	MOVEI	10,MEMLOC
	5
	0
	0
	MOVEM	10,MEMLOC
	5
	0
	0
	MOVES	10,MEMLOC
	5
	0
	0
	MOVS	10,MEMLOC
	5
	0
	0	MOVSI	10,MEMLOC
	5
	0
	0
	MOVSM	10,MEMLOC
	5
	0
	0
	MOVSS	10,MEMLOC
	5
	0
	0
	MOVN	10,MEMLOC
	5
	0
	0
	MOVNI	10,MEMLOC
	5
	0
	0
	MOVNM	10,MEMLOC
	5
	0
	0
	MOVNS	10,MEMLOC
	5
	0
	0
	MOVM	10,MEMLOC
	5
	0
	0
	MOVMI	10,MEMLOC
	5
	0
	0
	MOVMM	10,MEMLOC
	5
	0
	0
	MOVMS	10,MEMLOC
	5
	0
	0
	IMUL	10,MEMLOC
	5
	0
	0
	IMULI	10,MEMLOC
	5
	0
	0
	IMULM	10,MEMLOC
	5
	0
	0
	IMULB	10,MEMLOC
	5
	0
	0
	MUL	10,MEMLOC
	5
	0
	0
	MULI	10,MEMLOC
	5
	0
	0
	MULM	10,MEMLOC
	5
	0
	0
	MULB	10,MEMLOC
	5
	0
	0
	IDIV	10,MEMLOC
	5
	0
	0
	IDIVI	10,MEMLOC
	5
	0
	0
	IDIVM	10,MEMLOC
	5
	0
	0
	IDIVB	10,MEMLOC
	5
	0
	0
	DIV	10,MEMLOC
	5
	0
	0
	DIVI	10,MEMLOC
	5
	0
	0
	DIVM	10,MEMLOC
	5
	0
	0
	DIVB	10,MEMLOC
	5
	0
	0
	ASH	10,MEMLOC
	5
	0
	0
	ROT	10,MEMLOC
	5
	0
	0
	LSH	10,MEMLOC
	5
	0
	0
	ASHC	10,MEMLOC
	5
	0
	0
	ROTC	10,MEMLOC
	5
	0
	0
	LSHC	10,MEMLOC
	5
	0
	0
	EXCH	10,MEMLOC
	5
	0
	0
	ADD	10,MEMLOC
	5
	0
	0
	ADDI	10,MEMLOC
	5
	0
	0
	ADDM	10,MEMLOC
	5
	0
	0
	ADDB	10,MEMLOC
	5
	0
	0
	SUB	10,MEMLOC
	5
	0
	0
	SUBI	10,MEMLOC
	5
	0
	0
	SUBM	10,MEMLOC
	5
	0
	0
	SUBB	10,MEMLOC
	5
	0
	0
	SETZ	10,MEMLOC
	5
	0
	0
	SETZI	10,MEMLOC
	5
	0
	0
	SETZM	10,MEMLOC
	5
	0
	0
	SETZB	10,MEMLOC
	5
	0
	0
	AND	10,MEMLOC
	5
	0
	0
	ANDI	10,MEMLOC
	5
	0
	0
	ANDM	10,MEMLOC
	5
	0
	0
	ANDB	10,MEMLOC
	5
	0
	0
	ANDCA	10,MEMLOC
	5
	0
	0
	ANDCAI	10,MEMLOC
	5
	0
	0
	ANDCAM	10,MEMLOC
	5
	0
	0
	ANDCAB	10,MEMLOC
	5
	0
	0
	SETM	10,MEMLOC
	5
	0
	0
	SETMI	10,MEMLOC
	5
	0
	0
	SETMM	10,MEMLOC
	5
	0
	0
	SETMB	10,MEMLOC
	5
	0
	0
	ANDCM	10,MEMLOC
	5
	0
	0
	ANDCMI	10,MEMLOC
	5
	0
	0
	ANDCMM	10,MEMLOC
	5
	0
	0
	ANDCMB	10,MEMLOC
	5
	0
	0
	SETA	10,MEMLOC
	5
	0
	0
	SETAI	10,MEMLOC
	5
	0
	0
	SETAM	10,MEMLOC
	5
	0
	0
	SETAB	10,MEMLOC
	5
	0
	0
	XOR	10,MEMLOC
	5
	0
	0
	XORI	10,MEMLOC
	5
	0
	0
	XORM	10,MEMLOC
	5
	0
	0
	XORB	10,MEMLOC
	5
	0
	0
	IOR	10,MEMLOC
	5
	0
	0
	IORI	10,MEMLOC
	5
	0
	0
	IORM	10,MEMLOC
	5
	0
	0
	IORB	10,MEMLOC
	5
	0
	0
	ANDCB	10,MEMLOC
	5
	0
	0
	ANDCBI	10,MEMLOC
	5
	0
	0
	ANDCBM	10,MEMLOC
	5
	0
	0
	ANDCBB	10,MEMLOC
	5
	0
	0
	EQV	10,MEMLOC
	5
	0
	0
	EQVI	10,MEMLOC
	5
	0
	0
	EQVM	10,MEMLOC
	5
	0
	0
	EQVB	10,MEMLOC
	5
	0
	0
	SETCA	10,MEMLOC
	5
	0
	0
	SETCAI	10,MEMLOC
	5
	0
	0
	SETCAM	10,MEMLOC
	5
	0
	0
	SETCAB	10,MEMLOC
	5
	0
	0
	ORCA	10,MEMLOC
	5
	0
	0
	ORCAI	10,MEMLOC
	5
	0
	0
	ORCAM	10,MEMLOC
	5
	0
	0
	ORCAB	10,MEMLOC
	5
	0
	0
	SETCM	10,MEMLOC
	5
	0
	0
	SETCMI	10,MEMLOC
	5
	0
	0
	SETCMM	10,MEMLOC
	5
	0
	0
	SETCMB	10,MEMLOC
	5
	0
	0
	ORCM	10,MEMLOC
	5
	0
	0
	ORCMI	10,MEMLOC
	5
	0
	0
	ORCMM	10,MEMLOC
	5
	0
	0
	ORCMB	10,MEMLOC
	5
	0
	0
	SETO	10,MEMLOC
	5
	0
	0
	SETOI	10,MEMLOC
	5
	0
	0
	SETOM	10,MEMLOC
	5
	0
	0
	SETOB	10,MEMLOC
	5
	0
	0
	HLL	10,MEMLOC
	5
	0
	0
	HLLI	10,MEMLOC
	5
	0
	0
	HLLM	10,MEMLOC
	5
	0
	0
	HLLS	10,MEMLOC
	5
	0
	0
	HRL	10,MEMLOC
	5
	0
	0
	HRLI	10,MEMLOC
	5
	0
	0
	HRLM	10,MEMLOC
	5
	0
	0
	HRLS	10,MEMLOC
	5
	0
	0
	HLLZ	10,MEMLOC
	5
	0
	0
	HLLZI	10,MEMLOC
	5
	0
	0
	HLLZM	10,MEMLOC
	5
	0
	0
	HLLZS	10,MEMLOC
	5
	0
	0
	HLLO	10,MEMLOC
	5
	0
	0
	HLLOI	10,MEMLOC
	5
	0
	0
	HLLOM	10,MEMLOC
	5
	0
	0
	HLLOS	10,MEMLOC
	5
	0
	0
	HRLO	10,MEMLOC
	5
	0
	0
	HRLOI	10,MEMLOC
	5
	0
	0
	HRLOM	10,MEMLOC
	5
	0
	0
	HRLOS	10,MEMLOC
	5
	0
	0
	HLLE	10,MEMLOC
	5
	0
	0
	HLLEI	10,MEMLOC
	5
	0
	0
	HLLEM	10,MEMLOC
	5
	0
	0
	HLLES	10,MEMLOC
	5
	0
	0
	HRLE	10,MEMLOC
	5
	0
	0
	HRLEI	10,MEMLOC
	5
	0
	0
	HRLEM	10,MEMLOC
	5
	0
	0
	HRLES	10,MEMLOC
	5
	0
	0
	HRR	10,MEMLOC
	5
	0
	0
	HRRI	10,MEMLOC
	5
	0
	0
	HRRM	10,MEMLOC
	5
	0
	0
	HRRS	10,MEMLOC
	5
	0
	0
	HLR	10,MEMLOC
	5
	0
	0
	HLRI	10,MEMLOC
	5
	0
	0
	HLRM	10,MEMLOC
	5
	0
	0
	HLRS	10,MEMLOC
	5
	0
	0
	HRRZ	10,MEMLOC
	5
	0
	0
	HRRZI	10,MEMLOC
	5
	0
	0
	HRRZM	10,MEMLOC
	5
	0
	0
	HRRZS	10,MEMLOC
	5
	0
	0
	HLRZ	10,MEMLOC
	5
	0
	0
	HLRZI	10,MEMLOC
	5
	0
	0
	HLRZM	10,MEMLOC
	5
	0
	0
	HLRZS	10,MEMLOC
	5
	0
	0
	HRRO	10,MEMLOC
	5
	0
	0
	HRROI	10,MEMLOC
	5
	0
	0
	HRROM	10,MEMLOC
	5
	0
	0
	HRROS	10,MEMLOC
	5
	0
	0
	HLRO	10,MEMLOC
	5
	0
	0
	HLROI	10,MEMLOC
	5
	0
	0
	HLROM	10,MEMLOC
	5
	0
	0
	HLROS	10,MEMLOC
	5
	0
	0
	HRRE	10,MEMLOC
	5
	0
	0
	HRREI	10,MEMLOC
	5
	0
	0
	HRREM	10,MEMLOC
	5
	0
	0
	HRRES	10,MEMLOC
	5
	0
	0
	HLRE	10,MEMLOC
	5
	0
	0
	HLREI	10,MEMLOC
	5
	0
	0
	HLREM	10,MEMLOC
	5
	0
	0
	HLRES	10,MEMLOC
	5
	0
	0
;IOT INSTRUCTIONS
IOTTAB:	CONO	410,MEMLOC
	5
	0
	0
	CONI	410,MEMLOC
	5
	0
	0
	DATAO	410,MEMLOC
	5
	0
	0
INSEND:	DATAI	410,MEMLOC
	5
	0
	0  