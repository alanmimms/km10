;*** 4 WORD LUUO BLOCK.
UUOCOD:	0				;HOLDS OPCODE, AC FIELD, PC FLAGS
UUOPC:	0				;HOLDS PC ADDRESS
UUOE:	0				;EFFECTIVE ADDRESS OF LUUO
ALOHA:	0				;ADDRESS OF LUUO HANDLER
;*** END OF 4 WORD LUUO BLOCK
OLDEPT:	0				;HOLDS SUBRTN'S EPT PAGE NUMBER
RESDAT:	0
UPWD:	0				;DO "CONO PAG,UPWD" AFTER CHANGING USER PAGE MAP.
EPWD:	0				;DO "CONO PAG,@EPWD" AFTER MAKING CHANGE TO MEMORY MAPS.
PFF:	0				;-1 TO ALLOW ONE PAGE FAULT.
PFHSPC:	0				;HOLDS ADDRESS OF SPECIAL PAGE FAULT HANDLER.
;*** BEGINNING OF TWO-WORD MUUO RETURN BLOCK.
UUOSPF:	0				;HOLDS PC FLAGS.
UUOSPC:	0				;HOLDS SPECIAL MUUO RETURN ADDRESS.
;*** END OF TWO-WORD MUUO RETURN BLOCK.

ALLOW1:	0				;-1 TO ALLOW 1 UNRECOGNIZED MUUO.
PGMNAM:	ASCIZ	/
DFKED - EXTENDED ADDRESSING TEST
/

START:	PGMINT				;INITIALIZE SUBROUTINE PACKAGE
	BLKI	APR,A			;SEE THAT PROPER MICROCODE LOADED + MODEL B MACHINE
	MOVE	B,A			;SAVE APRID
	AND	A,[600000,,40000]	;MASKED OUT BITS WANTED
	CAMN	A,[600000,,40000]	;RIGHT BITS?
	JRST	STA			;OK, NOW CHECK FOR VERSION LOADED
	MOVEI	[ASCIZ/
EITHER THIS IS A MODEL "A" MACHINE OR IMPROPER MICROCODE LOADED,
MICROCODE SHOULD BE "KLX.RAM" AND MODEL "B" MACHINE WITH EXTENDED ADDRESSING.
/]
	PNTALF
	MOVEI	[ASCIZ/
APRID=/]
	PNTALF
	MOVE	B			;PRINT CONTENTS OF APRID
	PNTHWF
	EOPUUO				;END OF PROGRAM UUO

STA:	HLRZ	A,B			;WE WANT TO CHECK THE VERSION LOADED
	TRZ	A,777000		;9 BITS ONLY
	CAIL	A,262			;LESS THAN 262
	SETOM	XBLTS0#			;262 ALLOWS XBLT IN SECTION 0
	CAIL	A,226			;LESS THAN 226?
	JRST	STARTA			;UCODE VERSION IS OK
	MOVEI	[ASCIZ/
THE KLX.RAM MICROCODE MUST BE VERSION 226 OR OVER !
/]
	PNTALF
	EOPUUO

STARTA:	MOVE	A,P			;SAVE STACK POINTER
	MOVEM	A,PTEMP#
	CONO	PI,PIOFF		;TURN OFF PI
	CONO	TIM,20000		;CLEAR DONE AND STOP TIMER.
	CONO	PI,PICLR		;CLEAR PI
	SETZM	PFF			;DON'T ALLOW PAGE FAULTS.
	SETZM	ALLOW1			;DON'T ALLOW ILLEGAL MUUOS
	DATAI	PAG,A
	TLZ	A,(7B8) 		;CLEAR AC BLOCK NUMBER
	TLO	A,(<OURACS>B8)		;SET CURRENT AC BLOCK TO OUR WORKING BLOCK.
	DATAO	PAG,A
	MOVE	A,PTEMP			;GET SAVED STACK POINTER
	MOVEM	A,P			;PUT IT IN AC BLOCK LOC. 17
	PUSHJ	P,KLPAGE		;TURN ON KL PAGING
	PUSHJ	P,TESTS			;RUN THE TESTS.
	JRST	BEGEND			;END OF PASS

;MACRO FOR ALLOCATING WHOLE PAGES
;IT MAKES SURE THE PAGE BEGINS ON A PAGE BOUNDARY.

DEFINE PAGE(NAME)
<NAME=<.+777>_-9_9
LOC NAME+1000
>

;HARDWARE PAGES

PAGE SPT				;SPECIAL PAGE TABLE
SPTPN==SPT_-9				;SPECIAL PAGE TABLE PAGE NUMBER

PAGE CST				;CORE STATUS TABLE
CSTPN==CST_-9

PAGE EPT				;EXECUTIVE PROCESS TABLE
EPTPN==EPT_-9
TIMVEC=EPT+514				;HOLDS INSTRUCTION EXECUTED FOR INTERVAL TIMER INTERRUPT.

PAGE UPT				;USER PROCESS TABLE
UPTPN==UPT_-9

PAGE P1
P1PN==P1_-9
PAGE P3					;THESE ARE PURPOSELY OUT OF ORDER.
P3PN==P3_-9
PAGE P2					;PAGES USED BY TESTS.
P2PN==P2_-9				;PAGE 2 PAGE NUMBER.
PAGE P7
P7PN==P7_-9
PAGE P5
P5PN==P5_-9
PAGE P6
P6PN==P6_-9
PAGE P4
P4PN==P4_-9
NPAGES==7				;NUMBER OF RESERVED PAGES.

PAGE EMAP0				;EXEC SECTION 0 PAGE MAP.
MAP0PN=EMAP0_-9
PAGE MAP1
MAP1PN=MAP1_-9
PAGE MAP2
PAGE MAP3
PAGE MAP4
PAGE MAP5
PAGE MAP6
PAGE MAP7				;THERE MUST BE EXACTLY "NPAGES" OF THESE MAPS.
PUSE:	BLOCK NPAGES			;THE SPECIAL PAGES USED FOR TESTING EACH HAVE
					;AN ENTRY HERE.  THEY ARE CALLED (P1,P2,P3...
					;PN) WHERE N IS THE VALUE OF "NPAGES".  THE
					;ENTRY IN PUSE FOR PN TELLS WHAT VIRTUAL PAGE
					;OF CORE IS MAPPED TO PHYSICAL PAGE PN.  BIT 17
					;ON MEANS USER MAPPING, OFF MEANS EXEC MAPPING.
SUBTTL MEMORY MANAGEMENT

;*THIS ROUTINE INITIALIZES PAGING.  ALL EXEC SECTION 0 PAGES ARE MAPPED TO
;*THEMSELVES.  ALL OTHER EXEC PAGES, AND ALL USER PAGES ARE RENDERED
;*INNACCESSIBLE.  SEE THE PAGMAP AND UPAGMP MACROS FOR MAKING PAGES
;*ACCESSIBLE.

KLPAGE:	SETUP
	CONI	PAG,A			;FIND OUT WHERE OLD EPT WAS.
	TRZ	A,TRAPF+KLPAGF		;TURN OFF PAGING BEFORE FUTZING WITH
	CONO	PAG,(A)			;POINTERS AND STUFF
	TRZ	A,760000		;KEEP ONLY THE EPT PAGE NUMBER
	SKIPN	OLDEPT			;DON'T REREMEMBER OLD EPT ON A RESTART
	HRROM	A,OLDEPT		;REMEMBER WHERE THE OLD EPT WAS
	LSH	A,^D27			;CHANGE TO WORD ADDRESS IN LEFT HALF
	HRRI	A,EPT			;PREPARE TO BLT EPT INTO THE ITS NEW LOCATION

;*COPY THE EPT AND UPT FROM WHERE THE SUBROUTINE PACKAGE PUT IT TO WHERE
;*WE WANT IT.

	BLT	A,EPT+777		;MOVE THE WHOLE EPT
	DATAI	PAG,A			;NOW MOVE OLD UPT, TOO.
	LSH	A,^D27			;PUT ADDRESS OF OLD UPT IN LEFT HALF.
	HRRI	A,UPT			;PREPARE FOR BLT.
	BLT	A,UPT+777		;MOVE THE UPT

;*CLOSE ALL SECTIONS BY REMOVING ALL POINTERS TO PAGE TABLES.

	SETZM	ESECT			;CLOSE SECTION 0.
	MOVE	A,[ESECT,,ESECT+1]
	BLT	A,ESECT+37		;CLOSE REST OF EXEC SECTIONS.
	SETZM	USECT			;CLOSE USER SECTION 0.
	MOVE	A,[USECT,,USECT+1]
	BLT	A,USECT+37		;CLOSE THE REST OF THE USER SECTIONS.
	MOVE	A,[ACCESS,,MAP0PN]
	MOVEM	A,ESECT+0		;SET UP EXEC SECTION 0 POINTER.
	MOVEM	A,USECT+0		;USER SECTION 0 IS THE SAME AS EXEC SECTION 0.

;*ZERO OUT THE SPECIAL PAGE TABLE.

	MOVE	A,[SPT,,SPT+1]
	SETZM	SPT			;CLEAR THE FIRST WORD
	BLT	A,SPT+777		;AND THE REST

;*CLEAR OUT ALL THE PAGE TABLES.

	SETZM	PUSE
	MOVE	A,[PUSE,,PUSE+1]
	BLT	A,PUSE+NPAGES-1		;CLEAR OUT PAGE USE TABLE.
	SETZM	EMAP0
	MOVE	A,[EMAP0,,EMAP0+1]
	BLT	A,EMAP0+777		;CLEAR SECTION 0 EXEC TABLE.
	SETZM	MAP1
	MOVE	A,[MAP1,,MAP1+1]
	BLT	A,MAP1+NPAGES_9-1	;CLEAR THE TEST PAGE TABLES.

;*INITIALIZE CST AND MAP ALL SECTION 0 PAGES TO THEMSELVES

	MOVSI	A,770000		;WORD FOR EVERY CST ENTRY
	MOVSI	C,ACCESS		;LEFT HALF FOR PAGE TABLE ENTRIES
	MOVSI	B,-1000			;POINTER TO CST AND EMAP0
PTLUP:	MOVEM	A,CST(B)		;INITIALIZE A CST ENTRY
	HRRM	B,EMAP0(B)		;INITIALIZE EXEC SEC. 0 PAGE TABLE ENTRY
	HLLM	C,EMAP0(B)		;AND ITS LEFT HALF
	AOBJN	B,PTLUP			;LOOP UNTIL ALL ENTRIES MADE.

;*MAP THE OLD EPT TO THE NEW ONE.  THIS IS SO THAT THE SUBROUTINE PACKAGE
;*WHICH ASSUMES THE EPT TO BE SOMEWHERE ELSE THAN WHERE WE PUT IT, WILL
;*NOT BE CONFUSED

	MOVE	A,[ACCESS,,EPTPN]	;POINTER TO NEW EPT
	HRRZ	B,OLDEPT		;GET OLD EPT PAGE NUMBER
	MOVEM	A,EMAP0(B)		;CHANGE THE MAP
	DATAI	PAG,A			;GET AC BLOCK INFO.

;*SET UP CST MASK, DATA, AND BASE REGISTERS

	TLZ	A,(7B8)			;CLEAR AC BLOCK NUMBER.
	TLO	A,(<REVBLK>B8)		;SET CURRENT AC BLOCK TO RESERVED ONE.
	MOVEM	A,RESDAT		;SAVE WORD FOR ACCESSING RESERVED AC BLOCK
	TDZ	A,[7B8+17777]		;CLEAR AC BLOCK AND UBR FIELD
	TDO	A,[<OURACS>B8+UPTPN]	;SET UP DATAO PAGE WORD
	MOVEM	A,UPWD			;REMEMBER NEW DATA
	DATAO	PAG,RESDAT		;TELL HARDWARE WE WANT TO ACCESS RESERVED AC BLOCK
	HRROI	CSTMSK,-1		;PUT ALL 1'S IN CST MASK WORD
	MOVEI	CSTDAT,0		;PUT 0 IN CST DATA WORD
	MOVEI	SPTBR,SPT		;PUT SPT ADDRESS IN SPT BASE REGISTER
	MOVEI	CBR,CST			;PUT CST ADDRESS IN CST BASE REGISTER
	DATAO	PAG,UPWD		;GET BACK TO OUR AC'S AND SET NEW UPT

;*INITIALIZE MUUO HANDLER

	MOVEI	A,MUUOH			;GET ADDRESS OF MUUO HANDLER
	MOVEM	A,UUONPC		;STORE IT WHERE COMPOOTER WANTS IT.
	MOVE	A,[UUONPC,,UUONPC+1]
	BLT	A,UUONPC+7		;ONE OF 8 LOCATIONS ARE FETCHED DEPENDING ON THE WEATHER

;*SET UP PAGE FAULT HANDLER ADDRESS

	XMOVEI	A,PFH			;GET ADDRESS OF PAGE FAULT HANDLER
	MOVEM	A,PFHA			;STORE IT WHERE MACHINE WANTS IT.
	CONI	PAG,A			;GET PAGING DATA
	TRZ	A,17777			;CLEAR EBR
	TRO	A,TRAPF+KLPAGF+EPTPN	;SET NEW EBR AND KL PAGING AND TRAP FLAGS
	MOVEM	A,EPWD			;SAVE MAGIC WORD FOR TURNING ON PAGING

;*TURN ON PAGING

	CONO	PAG,@EPWD		;TURN ON PAGING
	POPJ	P,

;*THIS ROUTINE GETS TRANSFERRED TO ON ANY MUUO.

MUUOH:	SFM	UUOSPF			;SAVE THE FLAGS INDUCED BY THE MUUO.
	PUSH	P,A			;DON'T CLOBBER ANY AC'S
	LDB	A,[111100,,MCODE]	;GET THE OPCODE OF THE EXECUTED MUUO
	CAIE	A,<GOEXEC>_-^D27	;DO WE RECOGNIZE IT ??
	JRST	MUUOH1			;NO, INVESTIGATE FURTHER.
	MOVE	A,MCODE			;GET THE FLAGS FROM WHENCE WE CAME
	TLZ	A,(USRBIT)		;TURN OFF USER MODE (THAT'S WHAT "GOEXEC" DOES)
	MOVEM	A,MCODE
	JRST	MUUORT			;RETURN TO WHERE WE CAME FROM.
MUUOH1:	AOSE	ALLOW1			;IS AN MUUO EXPECTED ?
	JRST	BADUUO			;GO PRINT INFO ABOUT BAD MUUO.
	POP	P,A
	XJRSTF	UUOSPF			;RETURN TO CALLER WITH PC FLAGS AS INDUCED BY MUUO.
MUUORT:	POP	P,A
	XJRSTF	MCODE

	T=SIXBTZ<*EXTENDED ADDRESSING TEST*>

BADUUO:	POP	P,A
	ERROR1	13,0,0,ILLEGAL MUUO EXECUTED,DIAG. WILL LOOP ON TEST,BADUOX
	JRST	@TESTPC			;LOOP ON TEST THAT CAUSED FAILURE

BADUOX:	MOVEI	[ASCIZ/
BADUUO WAS EXECUTED FROM TEST# /]
	PNTALF
	MOVE	TESTPC
	PNTOCS
	PCRL
	TYPE	<?BAD MUUO AT PC >
	TYPHAF	MOLDPC
	RTN

;*ROUTINE TO GET INTO USER MODE AND USER IO MODE

GOUSER:	PUSH	P,A
	PUSH	P,B
	SFM	A			;GET THE PC FLAGS.
	TLO	A,(USRBIT+UIOBIT)	;TURN ON USER AND USER IO.
	XMOVEI	B,.+2			;GET OUR OWN PC, SO XJRSTF DOESN'T GO ANYWHERE !
	XJRSTF	A			;TURN ON USER MODE.
	POP	P,B
	POP	P,A			;RESTORE THE AC'S.
	POPJ	P,			;RETURN TO THE MAIN PROGRAM.

;*PAGE FAULT HANDLER

PFH:	AOSE	PFF			;MAKE SURE A PAGE FAULT IS ALLOWED.
	JRST	BADPF			;BAD PAGE FAULT, GO TELL.
	JRST	@PFHSPC			;GO HANDLE SPECIAL PAGE FAULT.

BADPF:	ERROR1	13,0,0,ILLEGAL PAGE FAULT,DIAG. WILL LOOP ON TEST,BADPFX
	JRST	@TESTPC			;LOOP ON TEST
BADPFX:	MOVEI	[ASCIZ/
BAD PAGE FAULT WAS EXECUTED FROM TEST# /]
	PNTALF
	MOVE	TESTPC
	PNTOCS
	PCRL
	TYPE	<?PFW = >
	TYPHAF	PFW
	TYPE	<.  PC = >
	TYPHAF	PFPC+1
	RTN

;*GET TO HERE TO CONTINUE AFTER A PAGE TRAP.

PFHRET:	XJRSTF	PFPC			;CONTINUE AT PC OF PAGE FAULT.
SUBTTL EXTENDED ADDRESSING TESTS.

PMAPRT:	MOVE	T2,A
	LSH	T2,-9			;GET PHYSICAL PAGE NUMBER BEING UNMAPPED.
	SUBI	T2,P1PN			;NOW WE HAVE INDEX INTO PUSE TABLE.
	SKIPN	AC0,PUSE(T2)		;PICK UP THE PAGE THAT WAS PREVIOUSLY MAPPED INTO THIS ONE.
	JRST	NREMOB			;IT WAS NEVER MAPPED, SO WE NEEDN'T UNMAP IT NOW !
	TRNN	AC0,777000		;CHECK FOR SECTION 0 MAPPING.
	JRST	NREMOB			;NEVER UNMAP A SECTION 0 MAPPING.
	MOVEI	AC3,ESECT		;FIRST ASSUME IT WAS AN EXEC MAPPING.
	TLZE	AC0,1
	MOVEI	AC3,USECT		;NO, IT WAS A USER MAPPING.
	LSHC	AC0,-9			;SEPARATE SECTION AND PAGE NUMBER OF OLD MAPPING.
	LSH	AC1,-^D27		;NOW OLD SECTION # IN AC0, OLD PAGE # IN AC1.
	ADD	AC3,AC0			;CREATE ADDRESS OF PAGE TABLE POINTER.
	MOVE	AC0,(AC3)		;PICK UP THE STARTING ADDRESS OF THE PAGE TABLE.
	LSH	AC0,9			;CHANGE TO CORE ADDRESS.
	ADD	AC0,AC1			;CREATE ADDRESS OF PAGE TABLE ENTRY.
	SETZM	(AC0)			;CLEAR OUT THE OLD ENTRY.
	MOVE	T4,PUSE(T2)		;PICK UP THE OLD MAPPING INFO.
	TRZ	T4,777			;KEEP ONLY THE USER BIT AND SECTION NUMBER.
	MOVSI	AC4,-NPAGES		;PREPARE TO LOOK FOR OTHER MAPPINGS IN SAME SECTION.
LK1:	MOVE	AC5,PUSE(AC4)		;PICK UP A MAPPING.
	TRZ	AC5,777			;CLEAR PAGE NUMBER.
	CAME	AC5,T4			;IS THIS A MAPPING IN THE SAME SECTION ?
	JRST	NOQ			;THIS ONE ISN'T THE SAME SECTION.
	CAIE	T2,(AC4)		;ARE WE COMPARING THE CURRENT ENTRY WITH ITSELF ?
	JRST	NREMOB			;NO, SO WE'VE REALLY GOT EVIDENCE THE SECT. IS STILL IN USE
NOQ:	AOBJN	AC4,LK1			;KEEP LOOKING.
	SETZM	(AC3)			;NO OTHER PAGE USING THIS SECT., SO FREE UP THE PAGE TABLE.
NREMOB:	MOVE	T1,ESECT(B)		;FIRST ASSUME THIS IS AN EXEC MAPPING.
	CAIE	T3,0
	MOVE	T1,USECT(B)		;NO, IT'S A USER MAPPING.
	JUMPN	T1,GOTONE		;THIS SECTION ALREADY HAS A PAGE TABLE IF NON-ZERO.
	MOVSI	T2,-NPAGES		;IT DOESN'T, SO LET'S LOOK FOR A FREE PAGE MAP.
	MOVEI	T4,MAP1PN		;T4 HOLDS THE PAGE MAP PAGE NUMBER WE'RE OPTING FOR.
CHKM1:	MOVSI	AC0,-40			;NUMBER OF SECTIONS TO CHECK.
CHKM3:	HRRZ	AC1,ESECT(AC0)		;PICK UP A PAGE TABLE PAGE #.
	HRRZ	AC2,USECT(AC0)		;DO TWO AT ONCE.
	CAME	AC1,T4
	CAMN	AC2,T4
	JRST	CHKM2			;IF WE FIND A MATCH, THEN THIS PAGE TABLE IS BUSY.
	AOBJN	AC0,CHKM3		;CHECK REST OF POINTERS TO MAKE SURE THIS TABLE IS FREE.
	MOVE	T1,T4			;THIS TABLE IS A GOOD ONE.  WE'LL USE IT.
	JRST	GOTONE
CHKM2:	ADDI	T4,1			;TRY THE NEXT PAGE TABLE.
	AOBJN	T2,CHKM1		;LOOP BACK UNLESS WE'VE TRIED ALL POSSIBLE PAGE TABLES.
	JRST	@TESTPC			;RETURN TO TEST THAT FAILED
GOTONE:	HRLI	T1,ACCESS		;GET PRIVATE POINTER ACCESS BITS.
	CAIE	T3,0			;USER MAPPING ?
	MOVEM	T1,USECT(B)		;YES, SO SET UP POINTER TO PAGE TABLE.
	CAIN	T3,0
	MOVEM	T1,ESECT(B)		;NO, SET UP POINTER TO EXEC PAGE TABLE.
	LSH	T1,9			;MAKE PAGE TABLE CORE ADDRESS.
	ADD	T1,C			;NOW T1 POINTS TO SPECIFIC PAGE TABLE WORD.
	LSH	A,-9			;CHANGE PHYSICAL PAGE NUMBER FROM CORE ADDR TO PAGE NUMBER.
	HRLI	A,ACCESS		;SET UP PRIVATE POINTER ACCESS BITS.
	MOVEM	A,(T1)			;UPDATE THE APPROPRIATE PAGE TABLE.
	ANDI	A,777			;KEEP ONLY THE PHYSICAL PAGE NUMBER.
	SUBI	A,P1PN			;CREATE INDEX INTO PUSE TABLE.
	LSH	B,9			;WE WANT SECTION NUMBER TO LEFT OF PAGE NUMBER.
	MOVEM	T3,PUSE(A)		;STORE USER OR EXEC BIT IN PUSE TABLE.
	IORM	B,PUSE(A)		;STORE VIRTUAL SECTION NUMBER.
	IORM	C,PUSE(A)		;AND VIRTUAL PAGE NUMBER.
	DATAO	PAG,UPWD		;TELL HARDWARE ABOUT THE NEW MAPPING.
	POPJ	P,

SUBTTL ACTUAL TESTS

TESTS:
;*		ACTUAL TESTS
;*		------ -----
;*
;*THE GOAL OF THIS PROGRAM IS TO MAKE SURE EXTENDED ADDRESSING
;*WORKS PROPERLY.  THERE IS LITTLE ATTEMPT MADE TO DESIGN THE TESTS
;*TO FIGURE OUT EXACTLY WHAT DOESN'T WORK.  HENCE A TEST OF ONE FEATURE
;*MAY INDEED EMPLOY SOME OTHER NON-TESTED FEATURE !
;*MAKE SURE A TRAP IS TAKEN IF A REFERENCE TO AN ADDRESS WITHIN A SECTION
;*GREATER THAN OR EQUAL TO 37 IS MADE.

	T=SIXBTZ<*EXTENDED ADDRESSING TESTS*>

;*TEST 1 - FORCE PAGE FAIL

T01:	SETUP
	SETOM	PFF			;ALLOW ONE PAGE FAULT.
	XMOVEI	B,HOMTLG		;LOAD UP RETURN ADDRESS FROM PAGE FAULT.
	MOVEM	B,PFHSPC		;TELL PAGE FAULT HANDLER WHERE TO RETURN TO.
	XJMP	40000002		;TRY TO JUMP INTO NON-EX MEM.
HOMTLG:	SKIPE	PFF			;MAKE SURE PAGE FAULT HAPPENED.
	ERROR	T01,13,0,0,,
<NO PAGE FAULT HAPPENED WHEN TRYING TO JUMP INTO TOO LARGE A SECTION>
	LDB	A,[360600,,PFW]		;GET PAGE FAIL CODE.
	CAIE	A,27			;MAKE SURE CORRECT CODE GOT STORED.
	ERROR	T01,13,[27],A,,
	<WRONG PAGE FAIL CODE GOT STORED UPON TRYING TO JUMP TO TOO LARGE A SECTION>
;*TEST 2 - TRY A SIMPLE INSTRUCTION IN A NON-ZERO SECTION TO MAKE SURE
;*LOCAL FETCHING HAPPENS CORRECTLY.

T02:	SETUP
	PAGMAP	(P1,13,407)		;PAGE P1 IS SECTION 13 PAGE 407.
	MOVEI	A,12435			;DATA TO BE FETCHED
	MOVEM	A,P1+500		;STORE DATA IN LOCATION 13407500
	DMOVE	A,[MOVE A,407500
		JRST @B]		;TEST PROGRAM TO BE RUN.
	DMOVEM	A,P1+600		;PUT PROGRAM IN LOCATION 13407600.
	XMOVEI	B,HOME0			;LOAD UP RETURN ADDRESS
	XJMP	13407600		;JUMP TO TEST PROGRAM
HOME0:	CAIE	A,12435			;MAKE SURE TEST SUCCEEDED IN FETCHING CORRECT DATA.
	ERROR	T02,13,[12435],A,,
	<SIMPLE MEMORY FETCH FAILED>

;*TEST 3 - A SIMPLE LOCAL INDEXING TEST WILL BE DONE TO SHOW THAT
;*NEGATIVE INDEXING WORKS CORRECTLY WITHIN A SECTION IF LOCAL INDEXING
;*IS BEING USED.

T03:	SETUP
	DMOVE	A,[MOVE A,-100(B)
		JRST @C]		;PROGRAM JUST DOES A MOVE AND EXITS
	DMOVEM	A,P1+302		;PUT TEST PROGRAM IN LOCATION 13407302.
	MOVEI	B,5555			;DATA TO BE FETCHED
	MOVEM	B,P1+101		;DATA WILL BE FETCHED FROM 13407101.
	MOVEI	B,407201		;SET UP INDEX REGISTER FOR PROGRAM
	XMOVEI	C,HOME2			;SET UP RETURN ADDRESS
	XJMP	13407302		;JUMP TO TEST
HOME2:	CAIE	A,5555			;CHECK RESULT.
	ERROR	T03,13,[5555],A,,
	<NEGATIVE LOCAL INDEXING FAILED>


;*TEST 4 - WRAPAROUND OF MEMORY WILL BE TESTED WITH A POSITIVE INDEX WHICH WHEN
;*ADDED TO THE "Y" FIELD, SHOULD CAUSE A WRAPAROUND.

T04:	SETUP
	MOVE	B,[3.1415926]		;DATA TO BE FETCHED
	MOVEM	B,P1+67			;IT WILL BE FETCHED FROM WORD 67 OF SECTION 13  PAGE 407
	DMOVE	A,[MOVE A,3000(B)	;INSTRUCTION BEING TESTED.
		JRST @C]		;EXIT
	DMOVEM	A,P1+50			;PROGRAM GOES IN SECTIN 13 PAGE 407 WORD 50
	MOVE	B,[400525,,407067-3000]	;INDEX SHOULD WORK.GARBAGE LEFT HALF SHOULD BE OK.
	XMOVEI	C,HOME3			;LOAD UP RETURN ADDRESS
	XJMP	13407050		;START TEST
HOME3:	CAME	A,[3.1415926]		;MAKE SURE CORRECT DATA WAS FETCHED.
	ERROR	T04,13,[3.1415926],A,,
	<POSITIVE LOCAL WRAPAROUND INDEX FAILED>



;*TEST 5 - SOME FLAVORS OF GLOBAL INDEXING WILL BE TRIED.
;*THE FOLLOWING TEST CHECKS GLOBAL INDEXING:

T05:	SETUP
	PAGMAP	(P1,25,777)		;MAKE P1 BE THE LAST PAGE OF SECTION 25
	PAGMAP	(P2,26,0)		;P2 IS THE "NEXT" VIRTUAL PAGE AFTER P1
	DMOVE	A,[MOVE A,100(A)
		JRST @B]		;PROGRAM TO BE RUN
	DMOVEM	A,P2+100		;PUT PROGRAM IN SECTION 26 PAGE 0
	MOVE	B,[SETZ 1]		;ARBITRARY DATA TO BE FETCHED BY TEST
	MOVEM	B,P2+20			;IT WILL BE FETCHED FROM SEC. 26 P. 0 WORD 20
	MOVE	A,[26000020-100]	;INDEX OF 100 SHOULD MODIFY THIS NUMBER
	XMOVEI	B,HOME4			;LOAD UP RETURN ADDRESS
	XJMP	26000100		;JUMP TO TEST
HOME4:	CAME	A,[SETZ 1]		;VERIFY CORRECTNESS
	ERROR	T05,13,[SETZ 1],A,,
	<POSITIVE GLOBAL INDEX FAILED>


;*TEST 6 - THIS TEST IS EASILY MODIFIED TO TEST NEGATIVE INDEXING
T06:	SETUP
	MOVEI	A,-100
	HRRM	A,P2+100		;CHANGE INSTRUCTION TO "MOVE A,-100(A)"
	MOVE	A,[7654321]		;DATA TO BE FETCHED
	MOVEM	A,P1+700		;IT WILL BE FETCHED FROM SEC. 25 P 777
	MOVE	A,[25777700+100]	;INDEX WHICH WHEN MODIFIED POINTS TO CORRECT WORD
	XMOVEI	B,HOME5			;LOAD UP RETURN ADDRESS
	XJMP	26000100		;EXECUTE THE TEST
HOME5:	CAME	A,[7654321]		;MAKE SURE IT WORKED.
	ERROR	T06,13,[7654321],A,,
	<NEGATIVE GLOBAL INDEXING FAILED>


;*TEST 7 - AN IFIW IS TESTED
 

T07:	SETUP
	MOVE	A,[525252,,525252]	;DATA TO BE FETCHED
	MOVEM	A,P2+500		;FROM SEC. 27, P. 0 WORD 500
	PAGMAP	(P1,26,35)		;MAKE P1 BE SEC. 26, P. 35
	PAGMAP	(P2,27,0)		;P2 IS SECTION 27 PAGE 0.
	MOVEI	C,4			;C WILL BE USED AS INDEX REGISTER
	MOVE	A,[1B0+<14140,,7(A)>]	;GARBAGE IN BITS 2-12 SHOULDN'T MATTER
	MOVEM	A,P1+123+4		;PUT IFIW IN SEC. 26 P. 35 WORD 123+4
	DMOVE	A,[MOVE A,@35123(C)
		JRST @B]		;TEST PROGRAM TO BE RUN
	DMOVEM	A,P1+450		;PUT PROGRAM AT LOCATION 26035450
	XMOVEI	B,HOME6			;LOAD UP RETURN ADDRESS
	MOVE	A,[27,,500-7]		;OFFSET OF 7 IN MOVE INSTRUCTION SHOULD CANCEL THE 7 OUT.
	XJMP	26035450		;JUMP TO TEST
HOME6:	CAME	A,[525252,,525252]	;MAKE SURE THE RIGHT DATA WAS FETCHED.
	ERROR	T07,13,[525252,,525252],A,,
	<IFIWS DON'T WORK CORRECTLY>


;*TEST 10 - THE FOLLOWING TEST TRIES AN EXTENDED FORMAT INDIRECT WORD WITH BIT 1 
T10:	SETUP

	PAGMAP	(P1,1,5)		;MAKE P1 BE SECTION 1 PAGE 5
	PAGMAP	(P2,14,777)		;P2 IS NOW SECTION 14 PAGE 777
	PAGMAP	(P3,37,50)		;MAKE P3 BE SECTION 37 PAGE 50
	MOVE	A,[<A>B5+400004]	;ALMOST POINTS TO SECTION 1
	MOVEM	A,P2+750		;PUT EFIW IN SECTION 14 PAGE 777
	MOVE	A,[14,,777444]		;DATA TO BE FETCHED
	MOVEM	A,P1+666		;FROM SECTION 1 PAGE 5 WORD 666
	DMOVE	A,[MOVE A,@-100(C)
		JRST @B]		;PROGRAM TO BE TESTED
	DMOVEM	A,P3+407		;PUT PROGRAM IN SECTION 37, PAGE 50 WORD 407
	MOVE	C,[14777750+100]	;INDEX REGISTER FOR TEST PROGRAM
	MOVEI	A,405662		;EFIW REFERENCES THIS AS INDEX REGISTER
	XMOVEI	B,HOME7			;RETURN ADDRESS
	XJMP	37050407		;JUMP TO TEST PROGRAM
HOME7:	CAME	A,[14,,777444]		;MAKE SURE IT WORKED.
	ERROR	T10,13,[14,,777444],A,,
	<EFIWS WITH BIT 1 OFF AREN'T WORKING CORRECTLY>


;*TEST 11 - THIS LAST TEST IS MODIFIED NOW TO TRY AN EFIW WITH BIT 1 ON:

T11:	SETUP
	MOVE	A,[3,,4]		;DATA TO BE FETCHED
	MOVEM	A,P2+444		;DATA IN LAST TEST POINTS TO THIS WORD WHEN USED AS EFIW
	MOVSI	A,(1B1)			;GET BIT 1
	IORM	A,P2+750		;PUT IT INTO EFIW ALREADY IN MEMORY.
	XMOVEI	B,HOME8			;GET RETURN ADDRESS
	MOVEI	A,405662		;EFIW REFERENCES THIS AS INDEX REGISTER
	XJMP	37050407		;JUMP TO TEST PROGRAM
HOME8:	CAME	A,[3,,4]		;BE SURE EVERYTHING WORKED.
	ERROR	T11,13,[3,,4],A,,
	<EFIWS WITH BIT 1 ON DON'T WORK PROPERLY>


;*TEST 12 - IF BITS 0-1 ARE BOTH ON, A TRAP SHOULD BE TAKEN.  THE NEXT TEST TRIES
;*THAT SITUATION.

T12:	SETUP
	SETOM	PFF			;ALLOW 1 PAGE FAULT.
	MOVSI	A,(3B1)			;GET ILLEGAL COMBINATION
	IORM	A,P2+750		;MODIFY DATA FROM LAST TEST TO BE ILLEGAL INDIRECT WORD
	XMOVEI	B,HOME90		;GET RETURN ADDRESS
	MOVEM	B,PFHSPC		;TELL PAGE FAULT HANDLER WHERE TO RETURN TO.
	MOVEI	A,405662		;INITIALIZE INDEX REGISTER.
	XJMP	37050407		;JUMP TO TEST PROGRAM
HOME90:	SKIPE	PFF			;MAKE SURE THE PAGE FAULT HAPPENED.
	ERROR	T12,13,0,0,,
	<BITS 0 AND 1 BOTH ON IN INDIRECT WORD DIDN'T CAUSE A PAGE FAIL>

	MOVE	A,PFW			;GET THE PAGE FAIL WORD.
	TLZ	A,3000			;FLUSH CACHE BIT & KEEP BIT
	CAME	A,[240014,,777750]	;MAKE SURE EXPECTED PAGE FAIL WORD GOT SET UP.
	ERROR	T12,13,[241014,,777750],A,,
	<REFERENCING TOO LARGE A SECTION CAUSED THE WRONG PAGE FAIL WORD TO BE SET UP>


;*TEST 13 - BOTH BITS BEING ON IN AN INDIRECT WORD IS ALRIGHT IF THE WORD IS IN
;*SECTION 0.  THAT CASE IS NOW TRIED TO BE SURE BITS 0 AND 1 BOTH ON
;*IS ALLOWED IN SECTION 0.

T13:	SETUP
	PAGMAP	(P1,0,P1PN)		;P1 IS MAPPED TO ITSELF.
	MOVE	A,[@3B1+P1+300]		;INDIRECT WORD POINTS TO WORD 300 OF PAGE P1.
	MOVEM	A,P1+400		;PUT INDIRECT WORD IN SECTION 0 PAGE.
	PAGMAP	(P2,1,40)		;P2 IS SECTION 1 PAGE 40.
	DMOVE	A,[MOVE A,@40123
		JRST @B]		;TEST PROGRAM TO BE RUN.
	DMOVEM	A,P2+601		;STORE TEST PROGRAM IN SECTION 1.
	MOVE	A,[1B1+P1+400]		;EFIW THAT POINTS TO SECTION 0.
	MOVEM	A,P2+123		;PUT EFIW WHERE "MOVE" INSTRUCTION EXPECTS IT.
	MOVE	A,[33333,,55555]	;DATA TO BE FETCHED.
	MOVEM	A,P3+8			;1(C) POINTS TO P3+8.
	MOVE	A,[1(C)]		;INDIRECT WORD FOR SECTION 0.
	MOVEM	A,P1+300
	PAGMAP	(P3,0,P3PN)		;MAP P3 TO ITSELF IN SECTION 0.
	MOVEI	C,P3+7			;CONTENTS OF INDEX REGISTER.
	XMOVEI	B,HOME1B		;LOAD UP RETURN ADDRESS.
	XJMP	1040601			;JUMP TO TEST PROGRAM
HOME1B:	CAME	A,[33333,,55555]	;MAKE SURE CORRECT DATA WAS FETCHED.
	ERROR	T13,13,[333333,,555555],A,,
	<INDIRECT WORD WITH BITS 0 AND 1 BOTH ON IN SECTION 0 DIDN'T WORK RIGHT.>


;*TEST 14 - TRY CAUSING AN INDIRECT CHAIN TO ENTER SECTION 0 AND MAKE SURE IT STAYS
;*THERE.  THIS ONE GETS TO SECTION 0 BY AN AC IN THE INDIRECT CHAIN.

T14:	SETUP
	PAGMAP	(P1,20,300)		;P1 IS SECTION 20 PAGE 300
	DMOVE	A,[MOVE A,@300500
		JRST @B]		;TEST PROGRAM TO BE RUN
	DMOVEM	A,P1+400		;TEST PROGRAM STARTS AT 20300400
	MOVE	A,[1B1+T2]
	MOVEM	A,P1+500		;TEST PROGRAM INDIRECTLY ADDRESS T2 IN SECTION 0
	PAGMAP	(P2,0,P2PN)		;P2 IS SECT.0 PAGE P2PN(SO SUBRTN ISN'T SCREWED UP)
	MOVE	T2,[T3,,P2-1000+765];AS EXTENDED ADDR,WOULD BE SECT T3, BUT IT'LL BE SHORT.
	MOVEI	T3,1000			;P2-1+765+1000 IS P2+765,WHERE DATA SHOULD COME FROM.
	MOVE	B,[123,,456]		;DATA TO BE FETCHED.
	MOVEM	B,P2+765		;IT SHOULD BE FETCHED FROM WORD 765 OF P2.
	XMOVEI	B,HOME11		;RETURN ADDRESS
	XJMP	20300400		;JUMP TO TEST PROGRAM
HOME11:	CAME	A,[123,,456]		;MAKE SURE EVERYTHING WORKED.
	ERROR	T14,13,[123,,456],A,,
	<INDIRECTION THROUGH SECTION 0 BY WAY OF AN AC FAILED>


;*TEST 15 - MAKE SURE, HOWEVER, THAT INDIRECTING THROUGH AN AC NEEDN'T GO INTO
;*SECTION 0.  THIS IS DONE BY USING A SECTION # OF 1 INSTEAD OF 0 IN
;*AN EFIW, RATHER THAN THE LAST TEST, WHICH USED AN IFIW.

T15:	SETUP
	MOVE	A,[200001,,T2]		;REFERENCE T2 INDIRECTLY AGAIN, BUT NOT AS PART OF SECT. 0.
	MOVEM	A,P1+500
	MOVEI	B,7			;DATA TO BE FETCHED BY TEST.
	MOVEM	B,P3+765
	PAGMAP	(P3,T3,P2PN-1)		;POINT VIRTUAL PAGE SPECIFIED IN T2 TO PHYSICAL P3.
	MOVE	T2,[T3,,P2-1000+765];AS EXTENDED ADDR WOULD BE SECT T3 BUT IT'LL BE SHORT
	XMOVEI	B,HOMEIA		;LOAD UP RETURN ADRESS
	XJMP	20300400		;JUMP TO TEST.
HOMEIA:	CAIE	A,7			;MAKE SURE CORRECT DATA WAS RECEIVED.
	ERROR	T15,13,[7],A,,
	<TEST FAILED THAT TRIED TO INDIRECT THROUGH AN AC WITHOUT GOING INTO SEC. 0>


;*TEST 16 - NOW TRY HAVING THE INDIRECT CHAIN PASS INTO SECTION 0 BUT NOT THROUGH
;*AN AC.  THE LAST TEST IS MODIFIED FOR THIS PURPOSE.

T16:	SETUP
	MOVE	A,[1B1+P2+200]
	MOVEM	A,P1+500		;NOW WE'RE GOING INDIRECT THROUGH PAGE P2 BUT STILL SECT. 0.
	MOVEM	T2,P2+200		;P2+500 CONTAINS SHORT FORM 600765(T3)
	MOVEI	T3,1000			;T3 GOT CLOBBERED BY PAGMAP MACRO CALL.
	XMOVEI	B,HOME13		;LOAD UP RETURN ADDRESS
	XJMP	20300400		;JUMP TO TEST
HOME13:	CAME	A,[123,,456]
	ERROR	T16,13,[123,,456],A,,
	<INDIRECTION THROUGH SECTION 0 NOT BY WAY OF AN AC FAILED>


;*TEST 17 - THE FOLLOWING TEST TRIES AN IMMEDIATE TYPE INSTRUCTION IN A NON-0
;*SECTION.  THE TEST CHECKS THAT ALTHOUGH THE EFFECTIVE ADDRESS OF THE
;*IMMEDIATE INSTRUCTION IS MORE THAN 18 BITS OF NON-0 DATA, THAT ONLY
;*18 BITS ARE USED, JUST AS IN SECTION 0.

T17:	SETUP
	PAGMAP	(P1,17,17)		;PAGE FOR THE TEST.
	MOVE	A,[MOVEI A,@17010]	;INSTRUCTION TO BE TESTED.
	MOVE	B,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO MAIN PROGRAM.
	DMOVEM	A,P1+20			;PROGRAM IS AT LOCATION 17017020
	MOVE	A,[123,,456]		;ONLY THE RIGHT HALF SHOULD GET USED!
	MOVEM	A,P1+10
	MOVEI	A,0			;START WITH 0.
	XMOVEI	B,HOMICK		;LOAD UP RETURN ADDRESS.
	XJMP	17017020		;JUMP TO TEST
HOMICK:	CAIE	A,456
	ERROR	T17,13,[456],A,,
	<IMMEDIATE INSTRUCTION IN NON-0 SECTION FAILED>


;*TEST 20 - A BUNCH OF TESTS CHECK THE CONSISTANCY OF THE CONFUSION ABOUT WHETHER
;*REAL AC'S OR THEIR SHADOWS (LOW MEMORY ADDRESSES) GET REFERENCED.
;*FIRST TRY WRITING AND RETRIEVING DATA FROM THE SHADOWS:

T20:	SETUP
	PAGMAP	(P1,13,444)		;P1 IS SECTION 13 PAGE 444
	DMOVE	A,[MOVE A,@C
		JRST @B]		;PROGRAM TO BE TESTED
	DMOVEM	A,P1+100
	PAGMAP	(P2,20,0)		;P2 IS SECTION 20 PAGE 0
	MOVE	C,[20,,T1]		;PROGRAM SHOULD READ DATA FROM SECTION 20 WORD T1
	MOVEI	B,111			;DATA THAT SHOULD GET READ
	MOVEM	B,P2+T1			;THIS IS WHERE IT SHOULD GET READ FROM
	MOVEI	T1,222			;THIS IS THE DATA THAT SHOULDN'T GET READ
	XMOVEI	B,HOME9			;SET UP RETURN ADDRESS
	XJMP	13444100		;JUMP TO TEST
HOME9:	CAIE	A,111
	ERROR	T20,13,[111],A,,
	<ERROR TRYING TO READ SHADOW MEMORY>


;*TEST 21 - SECTION 1 IS NOT SUPPOSED TO HAVE ANY SHADOW AC'S.  SO NOW WE'LL
;*MODIFY THIS LAST TEST TO MAKE C REFERENCE SECTION 1 INSTEAD OF SECTION
;*20.  HENCE 222 SHOULD BE FETCHED AS DATA INSTEAD OF 111.

T21:	SETUP
	PAGMAP	(P2,1,0)		;CHANGE P2 TO BE SECTION 1.
	MOVE	C,[1,,T1]
	MOVEI	T1,222
	XMOVEI	B,HOME12		;LOAD RETURN ADDRESS
	MOVEI	A,0			;START WITH 0 IN A.
	XJMP	13444100		;JUMP TO TEST PROGRAM.
HOME12:	CAIE	A,222
	ERROR	T21,13,[222],A,,
	<A DID NOT CONTAIN 222 AFTER "MOVE A,@C" WAS EXECUTED IN SECTION 13,
^C HAD "1,,T1", AND T1 HAD 222 IN IT.>
;*TEST 22 - NOW TRY LOCAL REFERENCE AND MAKE SURE DATA COMES FROM REAL AC.

T22:	SETUP
	PAGMAP	(P2,20,0)		;CHANGE P2 BACK TO SECTION 20.
	MOVEI	T1,222
	MOVE	A,[MOVE A,T1]
	MOVEM	A,P1+100		;CHANGE PROGRAM.
	XMOVEI	B,HOME10		;LOAD UP RETURN ADDRESS
	XJMP	13444100		;JUMP TO TEST
HOME10:	CAIE	A,222
	ERROR	T22,13,[222],A,,
	<ERROR TRYING TO VERIFY NON-EXISTENCE OF SECTION 1 SHADOW MEMORY>


;*TEST 23 - THE FOLLOWING TEST TRIES DOING A JSR @FOO WHERE FOO CONTAINS A LOW
;*ADDRESS IN A NON-ZERO SECTION.  THE JSR IS EXECUTED IN A NON-0 SECTION
;*TOO.  THE TEST CHECKS THAT SHADOW MEMORY IS USED FOR STORING THE
;*JSR RETURN ADDRESS AND THAT REAL AC'S ARE ACTUALLY TRANSFERRED TO.

T23:	SETUP
	PAGMAP	(P1,36,777)		;P1 IS THE LAST PAGE OF SECTION 36
	PAGMAP	(P2,37,0)		;AND P2 IS THE FIRST PAGE OF SECTION 37
	MOVE	A,[JRST @B]
	MOVEM	A,P2+T2			;PUT "JRST @B" IN SHADOW T2
	MOVE	T2,[JRST @C]		;PUT "JRST @C" IN REAL T2
	XMOVEI	C,GOOD0			;PUT GOOD RETURN ADDRESS IN C
	XMOVEI	B,BAD0			;AND BAD RETURN ADDRESS IN B
	MOVE	A,[JSR @777770]		;INSTRUCTION TO BE TESTED
	MOVEM	A,P1+250		;IT WILL BE EXECUTED IN 36000250
	MOVE	A,[37,,T1]		;LOCATION TO BE JSR'ED TO
	MOVEM	A,P1+770		;SET UP INDIRECT WORD TO BE JSR'ED TO
	XJMP	36777250		;JUMP TO TEST PROGRAM
	SETZM	P2+T1
	FATAL				;FATAL ERROR IF PROGRAM GETS TO ANYTHING BUT "GOOD0".
BAD0:	ERROR	T23,13,0,0,,
	<JSR TO SHADOW MEMORY CAUSED INSTRUCTION FETCH FROM SHADOW MEMORY>

GOOD0:	MOVE	A,P2+T1
	CAME	A,[36777251]
	ERROR	T23,13,[36777251],A,,
	<JSR TO SHADOW MEMORY DIDN'T STORE PC CORRECTLY>


;*TEST 24 - MAKE SURE THAT IF THE PC WRAPS AROUND AT THE END OF A SECTION, THAT IT
;*ENTERS THE AC'S, RATHER THAN THE SHADOWS OF A SECTION.  THE INSTRUCTION
;*IN THE AC THAT THE TEST PROGRAM SHOULD WRAP AROUND INTO WILL BE A TRANSFER
;*TO A NON-AC TO VERIFY THAT ALTHOUGH THE FLOW HAS GOTTEN INTO THE AC'S,
;*THE CURRENT CONTEXT SECTION HASN'T BEEN SCREWED UP.

T24:	SETUP
	PAGMAP	(P1,5,777)		;P1 IS THE LAST PAGE OF SECTION 5
	PAGMAP	(P2,5,0)		;TEST PROGRAM WILL WRAP AROUND INTO P2
	MOVE	0,[JSP A,20]		;THIS JSP SHOULD BE WRAPPED AROUND INTO.
	SETZM	P2			;IF WRAPAROUND HAPPENS TO LOW CORE, MAKE SURE TRAP HAPPENS
	MOVE	A,[JRST @B]		;RETURN INSTRUCTION
	MOVEM	A,P2+20			;JSP SHOULD TRANSFER TO P2+20
	XMOVEI	B,HOME14		;LOAD UP RETURN ADDRESS
	MOVE	A,[JFCL]		;INNOCUOUS INSTRUCTION FOR END OF SECTION  5
	MOVEM	A,P1+777		;PUT IT IN END OF SECTION
	XJMP	5777777			;TRANSFER TO TEST PROGRAM
HOME14:	CAME	A,[5,,1]
	ERROR	T24,13,[5,,1],A,,
	<PROGRAM FLOW DIDN'T CORRECTLY WRAPAROUND FROM END OF SECTION INTO THAT SECTION'S AC'S>


;*TEST 25 - THE XMOVEI INSTRUCTION IS NOW TESTED.  THIS FIRST TEST TRIES A XMOVEI
;*IN SECTION 14, AND THE XMOVEI'S EFFECTIVE ADDRESS IS 6000.

T25:	SETUP
	PAGMAP	(P1,14,40)		;P1 IS SECTION 14 PAGE 40
	DMOVE	A,[XMOVEI A,6000
		JRST @B]		;TEST PROGRAM
	DMOVEM	A,P1+200		;STORE TEST PROGRAM
	XMOVEI	B,HOMEM1		;LOAD UP RETURN ADDRESS.
	XJMP	14040200		;JUMP TO TEST PROGRAM
HOMEM1:	CAME	A,[14,,6000]		;MAKE SURE A CONTAINS CORRECT RESULT.
	ERROR	T25,13,[14,,6000],A,,
	<XMOVEI A,6000 IN SECTION 14 PAGE 40 DIDN'T PUT 14,,6000 IN A.>

;*TEST 26 - NOW WE TRY HAVING THE EFFECTIVE ADDRESS OF THE SIMPLEST FORM OF XMOVEI
;*BE AN ADDRESS LESS THAN 20 TO MAKE SURE 1 IS RETURNED IN THE LEFT HALF.

T26:	SETUP
	MOVEI	A,1
	HRRM	A,P1+200		;NOW THE INSTRUCTION IS "XMOVEI A,1".
	XMOVEI	B,HOME2M		;LOAD UP RETURN ADDRESS.
	XJMP	14040200		;RUN THE TEST.
HOME2M:	CAME	A,[1,,1]		;MAKE SURE THE RIGHT THING HAPPENED.
	ERROR	T26,13,[1,,1],A,,
	<XMOVEI A,1 IN SECTION 14 DIDN'T PUT 1,,1 IN A.>


;*TEST 27 - NOW TRY A XMOVEI INSTRUCTION THAT REFERENCES A LONG INDEX REGISTER.

T27:	SETUP
	MOVSI	A,C			;USE REGISTER "C" AS INDEX REGISTER
	IORM	A,P1+200		;NOW THE INSTRUCTION IS "XMOVEI A,1(C)  "
	MOVE	C,[37B5+<4123,,-2>];ALL OF THIS EXCEPT BITS 1 THRU 5 SHOULD GET PUT INTO 1.
	XMOVEI	B,HOMEM3		;RETURN ADDRESS.
	XJMP	14040200		;JUMP TO TEST PROGRAM.
HOMEM3:	CAME	A,[4123,,-1]		;MAKE SURE CORRECT EXTENDED ADDRESS GOT LOADED.
	ERROR	T27,13,[4123,,-1],A,,
	<XMOVEI A,1(C) IN SECT 14 WHEN C CONTAINED 37B5+<4123,,-2> DIDN'T RETURN 4123,,-1.>


;*TEST 30 - TRY XMOVEI AC,N(AC2) WHERE AC2 IS A LONG INDEX REGISTER.  ADDING N
;*TO THE CONTENTS OF AC2 PRODUCES A RIGHT HALF OF LESS THAN 20.  HENCE,
;*THE RETURNED RESULT SHOULD CONTAIN THE SECTION NUMBER OF THE EFFECTIVE
;*ADDRESS OF THE XMOVEI INSTRUCTION IN THE LEFT HALF.

T30:	SETUP
	AOJ	C,			;NOW C CONTAINS 37B5+<4123,,-1>
	XMOVEI	B,HOMEM5		;LOAD RETURN ADDRESS
	XJMP	14040200		;JUMP TO TEST PROGRAM
HOMEM5:	CAME	A,[4124,,0]		;MAKE SURE LEFT HALF GOT REPLACED WITH SECTION NUMBER.
	ERROR	T30,13,[4124,,0],A,,
	<XMOVEI A,1(C) IN SECTION 14 WHEN C CONTAINED 37B5+<4123,,-1> DIDN'T RETURN 4124,,0>


;*TEST 31 - TRY A SHORT INDEX REGISTER NOW.

T31:	SETUP
	TLO	C,(1B0)			;NOW C CONTAINS 774123,,-1
	XMOVEI	B,HOMEM4		;LOAD UP RETURN ADDRESS.
	MOVEI	A,0			;START WITH 0 IN A
	XJMP	14040200		;JUMP TO TEST PROGRAM.
HOMEM4:	CAME	A,[1,,0]		;DID TEST PASS ??
	ERROR	T31,13,[1,,0],A,,
	<XMOVEI A,1(C) IN SECTION 14 WHEN C CONTAINED 774123,,-1 DIDN'T RETURN 1,,0.>


;*TEST 32 - NOW TRY A SHORT FORM INDEX REGISTER WHOSE CONTENTS, WHICH WHEN ADDED
;*TO "Y", PRODUCES AN ADDRESS WHOSE RIGHT HALF ISN'T LESS THAN 20.

T32:	SETUP
	MOVEI	A,400000		;USE Y FIELD WITH ONLY BIT 18 ON.
	HRRM	A,P1+200
	XMOVEI	B,HOMEM6		;LOAD UP RETURN ADDRESS.
	XJMP	14040200		;JUMP TO TEST PROGRAM.
HOMEM6:	CAME	A,[14,,377777]		;MAKE SURE CORRECT RESULT IS RETURNED.
	ERROR	T32,13,[14,,377777],A,,
	<XMOVEI A,400000(C) IN SECTION 14 WITH 774123,,-1 IN C FAILED TO PRODUCE 14,,377777>


;*TEST 33 - MAKE SURE THAT A XMOVEI INSTRUCTION REFERENCING AN AC BY WAY OF
;*AN IFIW ISN'T FOOLED INTO THINKING IT IS IN SECTION 0.

T33:	SETUP
	PAGMAP	(P1,15,0)		;P1 IS SECTION 15 PAGE 0.
	DMOVE	A,[XMOVEI A,@C
		JRST @B]		;TEST PROGRAM.
	DMOVEM	A,P1+740		;PUT TEST PROGRAM IN 15000740
	MOVE	C,[1,,60050]		;DATA THAT SHOULD GET RETURNED IN A.
	XMOVEI	B,HOMEM2		;LOAD UP RETURN ADDRESS
	XJMP	15000740		;JUMP TO TEST PROGRAM.
HOMEM2:	CAME	A,[1,,60050]		;MAKE SURE CORRECT EXTENDED ADDRESS RETURNED IN A.
	ERROR	T33,13,[1,,60050],A,,
	<XMOVEI A,@C IN SECTION 15 DID NOT YIELD 1,,60050 WHEN C CONTAINED 1,,60050.>


;*TEST 34 - MAKE SURE THAT A XMOVEI WHOSE EFFECTIVE ADDRESS CALCULATION ENTERS SECTION 0
;*DOESN'T RETURN NON-0 IN THE LEFT HALF.  THE DATA WORD FETCHED IN THE
;*LAST TEST IS MODIFIED TO HAVE ITS (IFIW STYLE) INDIRECT BIT ON, AND THE
;*WORD IT POINTS TO WILL POINT TO A WORD IN SECTION 0.  THE WORD IN SECTION
;*0 WILL HAVE SOME OF BITS 14-17 ON, BITS THAT SHOULD CAUSE INDEXING AND
;*NOT A LARGE ADDRESS.

T34:	SETUP
	PAGMAP	(P2,1,60)		;P2 IS SECTION 1 PAGE 60.
	MOVE	A,[1B1+P3+776]		;POINTS TO SECTION 0.
	MOVEM	A,P2+50			;PUT SECTION 0 POINTER IN SECTION 1.
	PAGMAP	(P3,0,P3PN)		;P3 IS ITSELF IN SECTION 0.
	MOVE	C,[200001,,60050]
	MOVE	A,[T1,,P3+700]		;THIS SHOULD BE INTERPRETED AS SECTION 0 WORD.
	MOVEM	A,P3+776
	MOVE	T1,[46,,5]		;INDEX REGISTER CONTENTS.
	XMOVEI	B,HOME00		;LOAD UP RETURN ADDRESS.
	XJMP	15000740		;JUMP TO TEST PROGRAM.
HOME00:	CAIE	A,P3+705		;MAKE SURE CORRECT DATA WAS RETURNED.
	ERROR	T34,13,[P3+705],A,,
	<XMOVEI IN NON-0 SECTION WHOSE EFFECTIVE ADDRESS CALCULATION ENTERED SECTION 0 FAILED.>


;*TEST 35 - TRY A XMOVEI IN SECTION 0 TO MAKE SURE IT ONLY ACTS AS MOVEI.

T35:	SETUP
	PAGMAP	(P2,0,P2PN)		;P2 IS NOW SOME PAGE IN SECTION 0.
	DMOVE	A,[XMOVEI A,@7(A)
		JRST @B]		;TEST PROGRAM
	DMOVEM	A,P2+302		;PUT TEST PROGRAM IN SECTION 0.
	MOVE	A,[C,,P2+10]		;ADDED TO 7 GIVES P2+17
	MOVEI	B,-5			;CONTENTS OF P2+17 WILL BE USED FOR EFF. ADDRESS,
	MOVEM	B,P2+17			;SO PUT -5 IN P2+17.
	XMOVEI	B,HOMEM0		;LOAD UP RETURN ADDRESS.
	XJMP	P2+302			;JUMP TO SECTION 0 TEST PROGRAM.
HOMEM0:	CAIE	A,-5			;MAKE SURE NO LEFT HAND BITS ARE ON IN A.
	ERROR	T35,13,[0,,-5],A,,
	<XMOVEI A,@7(A) IN SECTION 0 DIDN'T WORK RIGHT.>



;*TEST 36 - THE PUSHJ INSTRUCTION EXECUTED IN A NON-0 SECTION SHOULD SAVE ONLY
;*THE LONG PC, AND NO FLAGS.  THE FOLLOWING TEST TURNS ON LOTS OF PC
;*FLAGS AND THEN CAUSES A PUSHJ.  THE STACK WORD IS CHECKED TO MAKE
;*SURE IT CONTAINS THE CORRECT RETURN PC, AND THAT NO OTHER BITS ARE
;*ON IN THE STACK WORD.
;*TO CONFUSE MATTERS, THE EFFECTIVE ADDRESS OF THE PUSHJ INSTRUCTION
;*WILL BE ARRANGED TO ENTER SECTION 0, WHICH SHOULD EFFECT HOW THE
;*REST OF THE EFFECTIVE ADDRESS CALCULATION IS CARRIED OUT, BUT SHOULDN'T
;*PREVENT THE EXTENDED ACTION.
;*THIS TEST ALSO VERIFIES THAT THE PUSHJ ACTUALLY CAUSES A TRANSFER TO
;*THE CORRECT LOCATION, AND THAT THE PC FLAGS SET BEFORE THE PUSHJ ARE STILL
;*SET AFTERWARDS.
;*THIS TEST ALSO MAKES SURE THE PUSHDOWN POINTER IS MODIFIED CORRECTLY.

T36:	SETUP
	PAGMAP	(P1,7,244)		;P1 IS SECTION 7 PAGE 244
	MOVE	A,[PUSHJ A,@244500]	;INSTRUCTION TO BE TESTED
	MOVEM	A,P1+400		;PUT PUSHJ IN 7244400
	PAGMAP	(P2,30,333)
	MOVE	A,[1B1+30333111]	;INDIRECT THROUGH SECTION 30....
	MOVEM	A,P1+500
	MOVE	A,[P3+401+<C>B5]	;FINALLY AN END TO THE CHAIN.
	MOVEM	A,P2+111
	PAGMAP	(P3,0,P3PN)		;P3 IS MAPPED TO ITSELF.
	MOVE	C,[JRST@B]		;RETURN INSTRUCTION
	MOVEM	C,P3+404		;WE'RE REALLY PUSHJING TO 000P3000+404
	MOVE	A,[1B1+30333200]	;STACK POINTER.  1B1 SHOULD GET IGNORED.
	SETZM	P2+201			;FIRST ZERO THE STACK WORD.
	MOVEI	C,3			;INDEX REGISTER
	XMOVEI	B,HOME15		;LOAD UP RETURN ADDRESS
					;TURN ON OV,C0,C1,FOV,FUN,NOD
	XJRSTF	[EXP 740140B17,7244400]	;AND JUMP TO TEST PROGRAM
HOME15:	MOVE	B,P2+201		;PICK UP STACK WORD.
	CAME	B,[7244401]
	ERROR	T36,13,[7244401],A,,
	<PUSHJ WITH LONG POINTER STORED THE WRONG STACK WORD>

	JSP	B,.+1			;GET PC FLAGS
	HLRZ	B,B			;AND ONLY THE FLAGS.
	CAIE	B,740140		;MAKE SURE THE FLAGS HAVEN'T BEEN CLOBBERED
	ERROR	T36,13,[740140],A,,
	<PC FLAGS WERE CLOBBERED BY PUSHJ WITH LONG STACK POINTER>

	CAME	A,[1B1+30333201]	;MAKE SURE STACK POINTER WAS UPDATED CORRECTLY.
	ERROR	T36,13,[1B1+30333201],A,,
	<PUSHJ WITH LONG STACK POINTER UPDATED THE POINTER INCORRECTLY>


;*TEST 37 - THE PUSHJ INSTRUCTION SHOULD CAUSE A DIFFERENT STACK POINTER MODIFICATION
;*DEPENDING ON WHETHER THE STACK POINTER IS "LONG" OR "SHORT".  THE LAST
;*TEST TRIED A "LONG" POINTER, AND CAN BE EASILY MODIFIED  TO TRY A
;*"SHORT" ONE.

T37:	SETUP
	XMOVEI	B,HOME16		;LOAD UP RETURN ADDRESS
	MOVE	A,[1B0+<24,,T1>];SHORT STACK BECAUSE OF 1B0, SO 24 SHOULD NOT MEAN SECT 24
	MOVEI	T2,0			;START WITH 0 IN T2
	XJMP	7244400			;JUMP TO TEST PROGRAM
HOME16:	CAME	A,[1B0+<25,,T2>]
	ERROR	T37,13,[1B0+<25,,T2>],A,,
	<PUSHJ WITH SHORT POINTER DID NOT STORE UPDATED POINTER CORRECTLY>

	CAME	T2,[7244401]
	ERROR	T37,13,[7244401],A,,
	<PUSHJ WITH SHORT POINTER DIDN'T STORE STACK WORD CORRECTLY>


;*TEST 40 - A LONG STACK SHOULD CROSS A SECTION BOUNDARY INTO THE LOW CORE OF THE NEXT
;*SECTION.  THE FOLLOWING TEST VERIFIES THIS FACT.

T40:	SETUP
	PAGMAP	(P1,6,777)		;P1 IS THE LAST PAGE OF SECTION 6.
	PAGMAP	(P2,7,0)		;P2 IS SECTION 7 PAGE 0
	MOVE	A,[PUSHJ A,@B]		;SINGLE INSTRUCTION TEST PROGRAM.
	MOVEM	A,P2+20			;PUT TEST PROGRAM IN 7000020
	XMOVEI	B,HOME17		;RETURN ADDRESS
	MOVE	A,[6,,777777]		;STACK SHOULD GO INTO SECTION 7
	SETZB	0,P2			;P2 IS CORRECT STACK WORD, 0 IS ERRONEOUS STACK WORD
	XJMP	7000020			;JUMP TO TEST PROGRAM
HOME17:	CAME	A,[7,,0]
	ERROR	T40,13,[7,,0],A,,
	<POINTER UPDATE WAS INCORRECT FOR PUSHDOWN STACK CROSSING SECTION BOUNDARY>

	MOVE	A,0			;GET AC0
	CAIE	A,0
	ERROR	T40,13,[0],A,,
	<AC 0 WAS CLOBBERED BY PUSHDOWN STACK TRYING TO CROSS SECTION BOUNDARY>

	MOVE	B,P2
	CAME	B,[7000021]
	ERROR	T40,13,[7000021],B,,
	<STACK WORD STORED INCORRECTLY WHEN STACK CROSSED SECTION BOUNDARY>


;*TEST 41 - NOW TRY THE SAME TEST BUT WITH A SHORT POINTER IN "A" INSTEAD OF THE LONG
;*ONE.  THIS TIME THE STACK SHOULD WRAP INTO 0 INSTEAD OF SECTION 7.

T41:	SETUP
	MOVE	A,[1B0+6777777]		;SHORT STACK POINTER
	XMOVEI	B,HOME18		;RETURN ADDRESS
	SETZB	0,P2			;0 IS CORRECT, P2 IS WRONG THIS TIME.
	XJMP	7000020			;JUMP TO TEST PROGRAM
HOME18:	CAME	A,[1B0+7000000]
	ERROR	T41,13,[1B0+7000000],A,,
	<PUSHJ WITH SHORT POINTER DIDN'T WORK CORRECTLY WHEN STACK TRIED TO WRAP INTO AC'S>

	SKIPE	P2
	ERROR	T41,13,[0],P2,,
	<1'ST SHADOW WORD OF NEXT SECT CLOBBERED WHEN STACK TRIED TO WRAP AROUND WITH SHORT POINTER>


;*TEST 42 - TEST A JSP INSTRUCTION, EXECUTED IN SECTION 8.

T42:	SETUP
	PAGMAP	(P1,8,602)		;P1 IS LOCATION 10602000
	DMOVE	A,[JSP A,602071
		JRST @B]		;PROGRAM TO BE TESTED.
	DMOVEM	A,P1+70			;IN LOCATION 10602070.
	XMOVEI	B,HOMJSP		;GET RETURN ADDRESS.
	XJRSTF	[EXP 740140B17,10602070]	;SET ALOT OF PC FLAGS AND JUMP TO PROGRAM.
HOMJSP:	CAME	A,[10602071]		;MAKE SURE ONLY THE PC, AND NOT FLAGS GOT STORED.
	ERROR	T42,13,[10602071],A,,
	<JSP EXECUTED IN NON-0 SECTION STORED PC INCORRECTLY>


;*TEST 43 - NOW WE'LL TRY A POPJ IN A NON-0 SECTION.

T43:	SETUP
	PAGMAP	(P1,36,0)		;PUT STACK IN SECTION 36 PAGE 0.
	MOVE	B,[POPJ A,]		;INSTRUCTION TO BE TESTED.
	MOVEM	B,P2+47			;IN LOCATION 1000047
	PAGMAP	(P2,1,0)
	MOVE	A,[36000000+C]		;LONG STACK POINTER.
	XMOVEI	B,HOMPJ			;GET RETURN ADDRESS.
	MOVEM	B,P1+C			;PUT IT ON THE STACK.
	XJRSTF	[EXP 0,.+1]		;CLEAR THE PC FLAGS.
	JSP	B,.+1			;MAKE SURE THEY'RE CLEAR !!
	TLNE	B,-1			;ALL OF THEM....
	ERROR	T43,13,[0],B,,
	<COULDN'T CLEAR PC FLAGS FOR POPJ TEST>

	XMOVEI	C,[FATAL]		;IN CASE POPJ USES AC STACK "BY ACCIDENT".
	XJRSTF	[EXP 740140B17,1000047]	;JUMP TO THE PROGRAM AND TURN ON PC BITS.
HOMPJ:	CAME	A,[36000000+B]		;MAKE SURE CORRECT STACK POINTER CAME BACK.
	ERROR	T43,13,[36000000+B],A,,
	<LONG POPJ IN NON-0 SECTION INCORRECTLY MODIFIED THE STACK POINTER>

	JSP	A,.+1			;GET THE PC FLAGS.
	HLRZ	A,A			;AND JUST THE FLAGS !!
	CAIE	A,740140		;MAKE SURE THE SET FLAGS STILL ARE !
	ERROR	T43,13,[740140],A,,
	<LONG POPJ CLOBBERED THE PC FLAGS>


;*TEST 44 - MAKE SURE THE SHORT STACK TYPE OF POPJ STILL WORKS, EVEN IN A NON-0
;*SECTION:

T44:	SETUP
	PAGMAP	(P1,3,1)		;LET'S DO THIS TEST IN SECTION 3 PAGE 1.
	MOVE	A,[POPJ C,]		;INSTRUCTION TO BE TESTED.
	MOVEM	A,P1+50			;IN LOCATION 3001050
	MOVE	A,[3,,2000]		;WE'LL POPJ TO PAGE 2 OF SEC. 3.
	SETZM	P1+51			;MAKE SURE THERE'S A 0 EXECUTED IF POPJ FALLS THROUGH.
	MOVEM	A,P1+1			;STORE STACK ENTRY.
	PAGMAP	(P2,3,2)		;PAGE FOR POPJ'ING TO.
	MOVE	C,[1B0+36001001]	;SHORT STYLE STACK POINTER.
	MOVE	A,[JRST @B]		;INSTRUCTION FOR RETURNING TO MAIN PROGRAM.
	MOVEM	A,P2			;PUT IT WHERE POPJ SHOULD TRANSFER TO.
	XMOVEI	B,HOMSPJ		;LOAD UP RETURN ADDRESS.
	XJRSTF	[EXP 740140B17,3001050]	;SET PC FLAGS AND JUMP TO TEST.
HOMSPJ:	CAME	C,[400035,,1000]	;MAKE SURE THE POINTER GOT MODIFIED CORRECTLY.
	ERROR	T44,13,[400035,,1000],C,,
	<POPJ IN NON-0 SECTION MODIFIED SHORT POINTER INCORRECTLY>

	JSP	A,.+1			;GET THE PC FLAGS.
	HLRZ	A,A			;AND ONLY THE FLAGS.
	CAIE	A,740140		;MAKE SURE THE CORRECT FLAGS GOT SET.
	ERROR	T44,13,[740140],A,,
	<SHORT POPJ IN NON-0 SECTION CLOBBERED THE PC FLAGS>


;*TEST 45 - THE FOLLOWING TESTS CHECK PXCT OF PUSH AND POP INSTRUCTIONS.

T45:	SETUP
	PAGMAP	(P1,3,4)		;PAGE FOR TEST.
	UPAGMP	(P2,3,4)		;PAGE FOR USER DATA.
	PAGMAP	(P4,6,777)		;EXEC STACK SPACE
	PAGMAP	(P5,7,0)
	UPAGMP	(P6,6,777)
	UPAGMP	(P7,7,0)		;USER STACK SPACE
	MOVE	T3,[POP C,4000]		;INSTRUCTION TO BE TESTED.
	MOVE	B,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO MAIN PROGRAM.
	MOVEM	B,P1+3
	MOVE	B,[PXCT 1,T3]		;INSTRUCTION BEING TESTED.
	MOVEM	B,P1+2
	MOVE	C,[7,,1]		;STACK POINTER.
	MOVEI	A,3			;EXEC STACK DATA.
	MOVEM	A,P5+1
	MOVEI	A,4			;USER STACK DATA.
	MOVEM	A,P7+1
	XMOVEI	B,HOMXPP		;LOAD UP RETURN ADDRESS.
	SETZM	P1			;START WITH 0 IN DATA AREA.
	XJRSTF	[EXP 3,3004002]		;DO THE PXCT.
HOMXPP:	MOVE	A,P1			;GET DATA THAT GOT POPPED.
	CAMN	C,[7,,0]		;MAKE SURE STACK POINTER GOT UPDATED.
	CAIE	A,3			;CHECK POPPED DATA.
	ERROR	T45,13,[3],A,,
	<PXCT 1,POP FAILED>

	MOVE	C,[7,,1]		;TRY SAME STACK POINTER.
	SETZM	P1			;CLEAR DATA AREA.
	XMOVEI	B,HOMPP2
	XJRSTF	[EXP PCUBIT!3,3004002]	;THIS TIME PREVIOUS CONTEXT IS USER.
HOMPP2:	MOVE	A,P1			;PICK UP DATA AGAIN.
	CAMN	C,[7,,0]		;MAKE SURE STACK POINTER UPDATED.
	CAIE	A,4			;MAKE SURE USER STACK GOT USED.
	ERROR	T45,13,[4],A,,
	<PXCT 1,POP FAILED>

	MOVE	A,[PXCT 5,T3]		;BITS 10 AND 12 BOTH ON NOW.
	MOVEM	A,P1+2
	SETZM	P2			;THIS IS WORD DATA SHOULD GET WRITTEN TO NOW.
	MOVE	C,[7,,1]		;RESET STACK POINTER.
	MOVEI	B,HOMPP3
	XJRSTF	[EXP PCUBIT!3,3004002]
HOMPP3:	MOVE	A,P2
	CAIN	A,4
	CAME	C,[7,,0]
	ERROR	T45,13,[7,,0],C,,
	<PXCT 5,POP FAILED>

	MOVE	A,[PXCT 1,T3]		;JUST BIT 12 AGAIN.
	MOVEM	A,P1+2
	SETZM	P1			;DATA SHOULD GET WRITTEN HERE.
	MOVE	C,[7,,T1]		;STACK WORD SHOULD BE ACCUMULATOR T1.
	DATAO	PAG,UPWD		;MAKE SURE PREVIOUS AC BLOCK IS WHAT'S IN UPWD.
	DATAI	PAG,A			;GET PREVIOUS AC BLOCK NUMBER
	LSH	A,3			;PUT IT IN CURRENT BLOCK NUMBER POSITION.
	TLZ	A,700000		;CLEAR CONTROL BITS
	TLO	A,400000		;SET BIT TO SET AC BLOCK NUMBER.
	DATAO	PAG,A			;ACCESS PREVIOUS AC'S.
	MOVE	T1,[3.14]		;LOAD STACK WORD FOR TEST.
	DATAO	PAG,UPWD		;GET BACK ORIGINAL AC'S.
	XMOVEI	B,HOMPP4		;STACK WORD AND RETURN ADDRESS.
	XJRSTF	[EXP PCUBIT,3004002]
HOMPP4:	MOVE	A,P1
	CAMN	A,[3.14]		;MAKE SURE DATA WORD IS CONTENTS OF T1!!
	CAME	C,[6,,T1-1]		;AND THAT BOTH HALVES GOT CHANGED THIS TIME.
	ERROR	T45,13,[6,,T1-1],C,,
	<PXCT 1,POP FAILED WHEN PCS=USER SEC-0>

	
;*TEST 46 - THIS TEST DOES AN ADJSP IN A NON-0 SECTION IN THE POSITIVE DIRECTION
;*TO A LONG STACK POINTER.

T46:	SETUP
	PAGMAP	(P1,5,5)		;PAGE FOR TEST.
	MOVE	A,[ADJSP C,@T1]		;WE'LL ALWAYS PUT ADJUSTMENT IN T1.
	MOVE	B,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO MAIN PROGRAM.
	DMOVEM	A,P1			;PUT PROGRAM AT 5005000
	MOVE	C,[2,,3]		;LONG STACK POINTER.
	MOVEI	T1,300001		;POSITIVE INCREMENT.
	XMOVEI	B,HOMSSS		;LOAD UP RETURN ADDRESS.
	XJMP	5005000			;RUN THE TEST.
HOMSSS:	CAME	C,[2,,300001+3]
	ERROR	T46,13,[2,,300001+3],C,,
	<ADJSP  IN NON-0 SEC. WITH POS. INC. AND LONG P FAILED>


;*TEST 47 - NOW LET'S TRY A SHORT POINTER WITH POSITIVE INCREMENT.

T47:	SETUP
	MOVE	C,[1B0+4]		;BIT 0 MAKES IT SHORT.
	XMOVEI	B,HOMSS1		;SAME INCREMENT AS BEFORE.
	XJMP	5005000
HOMSS1:	CAME	C,[400000+300001,,4+300001]
	ERROR	T47,13,[400000+300001,,4+300001],C,,
	<ADJSP IN NON-0 SEC. WITH POS. INC. AND SHORT P FAILED>


;*TEST 50 - OK, HOW ABOUT A NEGATIVE INCREMENT WITH THE SHORT POINTER ?

T50:	SETUP
	MOVE	C,[1B0+400002]		;STARTING POINTER.
	MOVEI	T1,-3			;WE'LL DECREMENT THE POINTER BY 3.
	XMOVEI	B,HOMSS2
	XJMP	5005000
HOMSS2:	CAME	C,[400000-3,,400002-3]
	ERROR	T50,13,[400000-3,,400002-3],C,,
	<ADJSP IN NON-0 SEC. WITH NEG. INC. AND SHORT P FAILED>


;*TEST 51 - AND NOW A NEGATIVE INCREMENT WITH A LONG POINTER...

T51:	SETUP
	MOVE	C,[1,,0]		;LONG POINTER.
	XMOVEI	B,HOMSS3		;WE'LL USE INCREMENT OF -3 AGAIN.
	XJMP	5005000
HOMSS3:	CAME	C,[1000000-3]
	ERROR	T51,13,[1000000-3],C,,
	<ADJSP IN NON-0 SEC. WITH NEG. INC. AND LONG P FAILED>


;*TEST 52 - HERE WE MAKE SURE THAT BIT 12 IN SEC-0 BYTE POINTERS HAS NO EFFECT.

T52:	SETUP
	PAGMAP	(P1,0,P1PN)		;MAP PAGE P1 INTO SECTION 0.
	DMOVE	A,[IBP P1+30
		 JRST @B]		;PROGRAM TO BE TESTED.
	DMOVEM	A,P1+50			;STORE IT WHERE WE WILL EXECUTE IT.
	DMOVE	A,[EXP 020740B17+T1,P1+20]	;DOUBLE WORD BYTE POINTER.
	DMOVEM	A,P1+30			;STORE THE DOUBLE WORD BYTE POINTER.
	XMOVEI	B,HOMIBP		;LOAD UP RETURN ADDRESS.
	XJMP	P1+50			;JUMP TO THE IBP INSTRUCTION
HOMIBP:	DMOVE	A,P1+30			;PICK UP THE DOUBLE WORD BYTE POINTER.
	CAMN	A,[350740,,T2]		;MAKE SURE IT GOT INCREMENTED CORRECTLY.
	CAIE	B,P1+20			;MAKE SURE THE SECOND WORD DIDN'T CHANGE.
	ERROR	T52,13,[P1+20],B,,
	<IBP IN SECTION 0 DIDN'T INCREMENT POINTER CORRECTLY>


;*TEST 53 - NOW WE'LL TRY AN LDB INSTRUCTION.

T53:	SETUP
	MOVE	A,[LDB C,P1+30]
	MOVEM	A,P1+50			;CHANGE THE INSTRUCTION.
	MOVEI	A,"X"			;THE ASCII CHARACTER TO BE FETCHED.
	DPB	A,[350700,,T2]		;STORE IT.
	SETZB	C,A			;START WITH 0'S IN BOTH.
	XMOVEI	B,HOMLDB		;GET RETURN ADDRESS.
	XJMP	P1+50			;JUMP TO THE TEST PROGRAM.
HOMLDB:	CAIE	C,"X"			;MAKE SURE THE BYTE GOT LOADED.
	ERROR	T53,13,["X"],C,,
	<LDB IN SECTION 0 WITH BIT 12 ON DIDN'T LOAD THE CORRECT BYTE>


;*TEST 54 - NOW WE'LL DO AN IDPB IN SECTION 0 WITH BIT 12 ON.

T54:	SETUP
	MOVE	A,[IDPB C,P1+30]	;THE INSTRUCTION TO BE TESTED.
	MOVEM	A,P1+50
	MOVE	A,[010740,,C-1]		;BYTE POINTER TO STORE LEFT JUSTIFIED BYTE IN C.
	MOVEM	A,P1+30			;STORE THE BYTE POINTER.
	MOVEI	A,5			;"SECOND WORD" FOR BYTE POINTER.
	MOVEM	A,P1+31			;STORE IT.
	XMOVEI	B,HMIDPB		;LOAD UP RETURN ADDRESS.
	MOVEI	C,"X"			;START WITH RIGHT JUSTIFIED X.
	XJMP	P1+50			;JUMP TO THE TEST PROGRAM.
HMIDPB:	CAME	C,["X"+ASCII /X/]	;MAKE SURE THE IDPB HAPPENED.
	ERROR	T54,13,["X"+ASCII /X/],C,,
	<IDPB IN SECTION 0 WITH BIT 12 ON IN POINTER DIDN'T STORE BYTE CORRECTLY>

	DMOVE	A,P1+30			;PICK UP THE DOUBLE POINTER.
	CAMN	A,[350740,,C]		;MAKE SURE RESULTANT BYTE POINTER IS CORRECT.
	CAIE	B,5			;AND THAT SECOND WORD DIDN'T GET INCREMENTED. !!
	ERROR	T54,13,[5],B,,
	<IDPB IN SECTION 0 WITH BIT 12 ON IN BYTE POINTER DIDN'T INCREMENT CORRECTLY>


;*TEST 55 - NOW LET'S TRY AN ILDB IN SECTION 5 WITHOUT BIT 12 ON IN THE POINTER.

T55:	SETUP
	PAGMAP	(P1,5,50)		;P1 IS SECTION 5 PAGE 50.
	PAGMAP	(P2,5,51)		;CAUSE P2 TO BE CONSECUTIVE.
	PAGMAP	(P3,7,20)		;P3 IS SECTION 7 PAGE 20.
	DMOVE	A,[ILDB C,50777
		JRST @B]		;TEST PROGRAM TO BE RUN.
	DMOVEM	A,P2+40			;STORE PROGRAM AT 5051040
	DMOVE	A,[EXP <030600,,051021>,4777777]
	MOVEM	A,P1+777		;STORE FIRST WORD OF BYTE POINTER.
	MOVEM	B,P2			;AND SECOND WORD.
	MOVSI	A,(SIXBIT /M/)		;GET CHARACTER TO BE PICKED UP BY ILDB.
	MOVEM	A,P2+22			;PUT IT WHERE ILDB SHOULD PICK IT UP.
	XMOVEI	B,HOMLB1		;LOAD UP RETURN ADDRESS.
	XJMP	5051040			;RUN THE TEST.
HOMLB1:	CAIE	C,'M'			;MAKE SURE THE BYTE GOT FETCHED.
	ERROR	T55,13,['M'],C,,
	<OLD-STYLE ILDB INSTRUCTION IN NON-0 SECTION DIDN'T LOAD THE CORRECT BYTE>

	MOVE	A,P1+777		;PICK UP THE FIRST WORD OF THE BYTE POINTER.
	CAME	A,[360600,,51022]	;MAKE SURE IT GOT INCREMENTED CORRECTLY.
	ERROR	T55,13,[360600,,51022],A,,
	<FIRST WORD OF BYTE POINTER INCREMENTED INCORRECTLY BY ILDB IN NON-0 SECTION>

	MOVE	A,P2			;GET THE SECOND WORD.
	CAME	A,[4777777]		;MAKE SURE IT DIDN'T GET INCREMENTED.
	ERROR	T55,13,[4777777],A,,
	<OLD-STYLE ILDB IN NON-0 SECTION MODIFIED THE SECOND WORD OF THE BYTE POINTER>


;*TEST 56 - NOW LET'S TRY IN IDPB INSTRUCTION IN A NON-0 SECTION WITH
;*BIT 12 ON IN THE BYTE POINTER.  WE'LL SET UP P SUCH THAT THE
;*SECOND WORD OF THE BYTE POINTER WILL GET INCREMENTED.  THAT SECOND
;*WORD WILL BE SET UP TO GET INCREMENTED INTO THE NEXT SECTION EVEN !!

T56:	SETUP
	PAGMAP	(P1,4,456)		;THE TEST PROGRAM WILL BE IN SECTION 4.
	PAGMAP	(P2,12,0)		;THE DOUBLE BYTE POINTER WILL BE IN SECTION 12.
	PAGMAP	(P3,36,0)		;THE BYTE WILL BE STORED IN SECTION 36.
	DMOVE	A,[IDPB C,@456123
		JRST @B]		;TEST PROGRAM TO BE RUN.
	DMOVEM	A,P1+775		;PUT PROGRAM AT 4456775
	MOVE	A,[12,,17]		;ADDRESS OF THE BYTE POINTER.
	MOVEM	A,P1+123		;PUT IT WHERE IDPB POINTS TO.
	DMOVE	A,[EXP <020740+T1,,53423>,35777777]
	DMOVEM	A,P2+17			;BITS 13-17 OF FIRST WORD SHOULD GET IGNORED.
	SETZM	P3			;START WITH 0 IN WORD RECEIVING THE BYTE.
	MOVEI	C,"X"			;ASCII CHARACTER TO BE STORED.
	XMOVEI	B,HOMIII		;LOAD UP THE RETURN ADDRESS.
	XJMP	4456775			;JUMP TO THE TEST PROGRAM.
HOMIII:	MOVE	A,P3			;RETRIEVE THE DATA WORD.
	CAME	A,[ASCII /X/]		;MAKE SURE THE CORRECT DATA GOT STORED.
	ERROR	T56,13,[ASCII /X/],A,,
	<IDPB WITH BIT 12 ON IN NON-0 SECTION STORED THE DATA INCORRECTLY>

	DMOVE	A,P2+17			;GET THE MODIFIED DOUBLE WORD BYTE POINTER.
	CAMN	A,[350740+T1,,53423]
	CAME	B,[36000000]
	ERROR	T56,13,[36000000],B,,
	<IDPB WITH BIT 12 ON IN NON-0 SECTION MODIFIED THE POINTER INCORRECTLY>


;*TEST 57 - NOW WE'LL DO AN ILDB IN A NON-0 SECTION WITH INDEXING SPECIFIIED IN
;*THE SECOND WORD OF THE BYTE POINTER.

T57:	SETUP
	PAGMAP	(P1,37,20)		;SECTION 37 PAGE 20 FOR THE TEST PROGRAM.
	DMOVE	A,[ILDB A,@T1
	JRST @B]			;THE TEST PROGRAM.
	DMOVEM	A,P1+30			;PUT PROGRAM AT 37020030
	PAGMAP	(P2,20,3)		;BYTE POINTER WILL BE IN SECTION 20.
	DMOVE	A,[050677,,123
		<C>B5+11500000]
	DMOVEM	A,P2+62			;NOTICE INDEXING BY REGISTER C.
	PAGMAP	(P3,11+T2+1,<<500+600>&777>)	;PAGE TO HOLD THE BYTE.
	MOVE	T1,[20,,003062]		;ILDB INDIRECTS THROUGH T1.
	MOVE	C,[T2,,600000]		;THIS SHOULD GET ADDED TO 11500001 FOR ADDR OF THE BYTE !!
	MOVSI	A,(SIXBIT /B/)		;THE SIXBIT BYTE TO BE LOADED.
	MOVEM	A,P3+1			;PUT IT WHERE ILDB SHOULD RETRIEVE IT FROM.
	XMOVEI	B,HOMLLL		;LOAD UP THE RETURN ADDRESS.
	XJMP	37020030		;JUMP TO THE TEST PROGRAM.
HOMLLL:	CAIE	A,'B'			;MAKE SURE THE RIGHT DATA GOT LOADED.
	ERROR	T57,13,['B'],A,,
	<ILDB IN NON-0 SECTION WITH BIT 12 ON IN POINTER LOADED THE WRONG DATA>

	DMOVE	A,P2+62			;GET THE MODIFIED BYTE POINTER.
	CAMN	A,[360677,,123]		;MAKE SURE THE FIRST WORD GOT MODIFIIED CORRECTLY.
	CAME	B,[<C>B5+11500001]	;AND THE SECOND....
	ERROR	T57,13,[<C>B5+11500001],B,,
	<ILDB IN NON-0 SECTION WITH BIT 12 ON MODIFIIED THE POINTER INCORRECTLY>


;*TEST 60 - LET'S TRY HAVING THE INDIRECT BIT ON IN THE BYTE POINTER THIS
;*TIME:

T60:	SETUP
	MOVE	A,[050677,,123]		;RESTORE THE FIRST PART OF THE BYTE POINTER.
	MOVEM	A,P2+62
	MOVE	A,[1B1+<C>B5+11500000]
	MOVEM	A,P2+63			;TURN ON INDIRECT BIT THIS TIME.
	MOVE	A,[1,,T3]		;WE'LL RETRIEVE THE BYTE FROM AC T3.
	MOVEM	A,P3+1
	MOVSI	T3,(SIXBIT /X/)		;THE BYTE TO BE RETRIEVED.
	XMOVEI	B,HOMLL2		;LOAD UP THE RETURN ADDRESS.
	XJMP	37020030		;JUMP TO THE TEST PROGRAM.
HOMLL2:	CAIE	A,'X'			;MAKE SURE THE RIGHT DATA GOT LOADED.
	ERROR	T60,13,['X'],A,,
	<ILDB IN NON-0 SECTION WITH BIT 12 ON IN POINTER LOADED THE WRONG DATA>

	DMOVE	A,P2+62			;GET THE MODIFIED BYTE POINTER.
	CAMN	A,[360677,,123]		;MAKE SURE THE FIRST WORD GOT MODIFIIED CORRECTLY.
	CAME	B,[1B1+<C>B5+11500001]	;AND THE SECOND....
	ERROR	T60,13,[1B1+<C>B5+11500001],B,,
	<ILDB IN NON-0 SECTION WITH BIT 12 ON MODIFIIED THE POINTER INCORRECTLY>


;*TEST 61 - THE FOLLOWING TEST TRIES AN ILDB INSTRUCTION WITH BIT 12 ON IN THE
;*FIRST WORD.  BIT 0 OF THE SECOND WORD WILL BE ON, AND THE TEST WILL
;*VERIFY THAT NO CARRY ACROSS BIT 18 IS ALLOWED BY THE MICROCODE.

T61:	SETUP
	PAGMAP	(P1,2,400)		;PROGRAM WILL BE IN SECTION 2.
	PAGMAP	(P2,33,0)		;WE'LL FETCH THE BYTE FROM SHADOW MEMORY.
	DMOVE	AC,[000640,,3		;BIT 12 ON, 6-BIT BYTE, WORD INCREMENT REQUIRED.
		400000+C,,777777]	;IFIW, INDEX BY C.
	MOVSI	A,(SIXBIT /P/)		;WE'LL LOAD A P.
	MOVEM	A,P2+T1			;FROM SHADOW T1.
	MOVEI	T1,0			;MAKE SURE T1 CONTAINS THE WRONG DATA !
	MOVE	C,[33,,T1]		;C IS INDEX REGISTER IT POINTS TO WORD CONTAINING THE BYTE.
	DMOVE	A,[ILDB A,AC
		JRST @B]		;PROGRAM TO BE RUN.
	DMOVEM	A,P1+20			;RUN PROGRAM IN LOCATION 2400020
	XMOVEI	B,HOMPAL		;LOAD UP RETURN ADDRESS.
	XJMP	2400020			;RUN THE TEST.
HOMPAL:	CAMN	AC,[360640,,3]		;MAKE SURE RIGHT HALF OF FIRST WORD WASN'T INCREMENTED.
	CAME	AC+1,[400000+C,,0]	;AND THAT SECOND WORD WAS, BUT NOT INTO B17 !!
	ERROR	T61,13,[400000+C,,0],AC+1,,
	<LONG BYTE POINTER WITH IFIW IN SECOND WORD INCREMENTED INCORRECTLY>

	CAIE	A,'P'			;MAKE SURE P (FOR PAULA) GOT RETRIEVED.
	ERROR	T61,13,['P'],A,,
	<ILDB WITH BIT 12 AND IFIW RETRIEVED THE WRONG DATA>


;*TEST 62 - HERE'S A TEST FOR THE ADJBP INSTRUCTION BEING EXECUTED IN A NON-0
;*SECTION WITHOUT BIT 12 OF THE BYTE POINTER ON.

T62:	SETUP
	PAGMAP	(P1,3,4)		;SECTION 3 PAGE 4
	DMOVE	A,[ADJBP A,5001
		JRST @C]		;THE TEST PROGRAM.
	DMOVEM	A,P1+20			;PUT IT AT 3004020
	PAGMAP	(P2,3,5)		;WORD TO HOLD THE BYTE POINTER
	DMOVE	A,[261000,,3
		2000000]		;THE DOUBLE WORD BYTE POINTER.
	DMOVEM	A,P2+1
	HRROI	B,-2			;THIS SHOULDN'T GET CLOBBERED, SINCE BIT 12 ISN'T ON.
	HRROI	A,-4			;WE WANT TO DECREMENT BY 4 BYTES.
	XMOVEI	C,HOMADJ		;LOAD UP THE RETURN ADDRESS.
	XJMP	3004020			;JUMP TO THE TEST PROGRAM.
HOMADJ:	CAMN	B,[-2]			;MAKE SURE THE CORRECT RESULT CAME BACK.
	CAME	A,[061000,,1]		;CHECK THE DECREMENTED BYTE POINTER.
	ERROR	T62,13,[061000,,1],A,,
	<ADJBP INSTRUCTION IN NON-0 SECTION WITHOUT BIT 12 ON RETURNED THE WRONG ANSWER>


;*TEST 63 - NOW WE'LL TRY ADJBP WITH BIT 12 ON !!

T63:	SETUP
	MOVSI	A,(1B12)		;THERE'S BIT 12 !!
	IORM	A,P2+1			;STICK IT IN...
	HRROI	B,-2			;THIS TIME B SHOULD GET THE DECREMENTED SECOND WORD.
	HRROI	A,-4			;AGAIN, WE'LL DECREMENT BY 4.
	XMOVEI	C,HOMAJ2		;LOAD UP THE RETURN ADDRESS.
	XJMP	3004020			;RUN THE TEST.
HOMAJ2:	CAMN	B,[1777776]		;MAKE SURE SECOND WORD GOT DECREMENTED TWICE.
	CAME	A,[061040,,3]		;AND FIRST WORD NOT AT ALL.
	ERROR	T63,13,[061040,,3],A,,
	<ADJBP IN NON-0 SECTION WITH BIT 12 ON RETURNED THE WRONG ANSWER>


;*TEST 64 - THE SFM (SAVE FLAGS IN MEMORY) INSTRUCTION IS NOW TESTED.  THIS
;*INSTRUCTION IS SUPPOSED TO SAVE THE PC FLAGS IN BITS 0-12 OF ITS
;*EFFECTIVE ADDRESS.  FIRST WE'LL TRY IT WITHOUT ANY INDIRECTION.

T64:	SETUP
	PAGMAP	(P1,20,600)		;PROGRAM IN SECTION 20 PAGE 600
	DMOVE	A,[SFM 123
		JRST @B]		;THE TEST PROGRAM.
	DMOVEM	A,P1+407		;PUT PROGRAM AT 20600407
	PAGMAP	(P2,20,0)		;PAGE INTO WHICH FLAGS ARE TO BE WRITTEN.
	SETOM	P2+123			;START WITH ALL BITS ON IN MEMORY.
	XMOVEI	B,HOMSFM		;LOAD UP THE RETURN ADDRESS.
	SETOM	P2+124			;START WITH ALL BITS ON IN "SECOND" MEMORY WORD.
	XJRSTF	[EXP 740140B17,20600407] ;TURN ON PC FLAGS AND JUMP TO PROGRAM.
HOMSFM:	JSP	A,.+1			;READ THE PC BITS INTO A.
	HLRZ	A,A			;KEEP ONLY THE FLAGS.
	CAIE	A,740140		;ARE THE RIGHT FLAGS ON ??
	ERROR	T64,13,[740140],A,,
	<THE WRONG PC FLAGS WERE ON FOLLOWING AN SFM INSTRUCTION>

	DMOVE	A,P2+123		;GET THE RESULTANT SFM DATA.
	CAMN	B,[-1]			;MAKE SURE SECOND WORD IS STILL INTACT.
	CAME	A,[740140B17]		;MAKE SURE FLAGS GOT STORED.
	ERROR	T64,13,[74140B17],A,,
	<SFM IN EXEC NON-0 SECTION WITHOUT INDIRECTION STORED THE DATA INCORRECTLY>

T64A:	XJRSTF	[EXP 37,T64B]		;37 -> PCS 
T64B:	SFM	123			;DO AN SFM.
	HRRZ	A,123			;GET E FIELD OF SFM.
	CAIE	A,37			;DID THE CONTENTS OF THE "PCS" GET TO THE E FIELD?
	ERROR	T64A,13,[37],A,,
	<XJRSTF - DID NOT STORE 37 IN PCS OR^
SFM - PCS DID NOT GET STORED IN THE E FIELD BITS 31 TO 35>


;*TEST 65 - NOW LET'S TRY THE SFM WITH INDIRECTION.

T65:	SETUP
	MOVSI	A,(@)			;GET THE INDIRECT BIT.
	IORM	A,P1+407		;TURN IT ON IN THE INSTRUCTION.
	MOVE	A,[36,,765432]		;ADDRESS INTO WHICH TO STORE THE FLAGS.
	MOVEM	A,P2+123		;STORE THE INDIRECT WORD.
	PAGMAP	(P3,36,765)		;MAP A PAGE TO HOLD THE PC FLAGS.
	SETOM	P3+432			;START WITH -1 IN THE WORD TO RECEIVE THE FLAGS.
	XMOVEI	B,HOMSM2		;LOAD UP THE RETURN ADDRESS.
	XJRSTF	[EXP 740140B17,20600407]	;TURN ON PC BITS AND JUMP TO PROGRAM.
HOMSM2:	MOVE	A,P3+432		;GET THE WORD INTO WHICH SFM WAS SUPPOSED TO WRITE.
	CAME	A,[740140B17]		;MAKE SURE THE BITS AND ONLY THE BITS WERE STORED.
	ERROR	T65,13,[740140B17],A,,
	<SFM IN EXEC NON-0 SECTION WITH INDIRECTION STORED THE PC BITS INCORRECTLY>


;*TEST 66 - HERE'S A TEST OF THE XPCW (SAVE THEN RESTORE FLAGS AND PROGRAM COUNTER)
;*INSTRUCTION:

T66:	SETUP
	PAGMAP	(P1,20,30)
	PAGMAP	(P2,30,40)
	PAGMAP	(P3,10,20)
	MOVE	A,[XPCW @30201]
	MOVEM	A,P1+30			;PUT PROGRAM AT LOCATION 20030030
	MOVE	A,[30040121]		;LOAD UP ADDRESS OF 4 WORD BLOCK.
	MOVEM	A,P1+201		;PUT IT WHERE XPCW EXPECTS IT.
	DMOVE	A,[EXP 740140B17,10020345]
	DMOVEM	A,P2+123		;STORE TRANSFER ADDRESS AND FLAGS FOR XPCW
	SETOM	P2+121			;THIS WORD SHOULD RECEIVE THE FLAGS.
	SETOM	P2+122			;AND THIS ONE THE PC OF THE XPCW.
	XMOVEI	B,HOMSRF		;LOAD UP THE RETURN ADDRESS.
	MOVE	A,[JRST @B]		;INSTRUCTION FOR GETTING BACK !
	MOVEM	A,P3+345		;PUT IT WHERE XPCW SHOULD TRANSFER TO.
	XJRSTF	[EXP 500100B17,20030030]	;SET FLAGS & PCS AND JUMP TO TEST.
HOMSRF:	HLRZ	A,P2+121		;GET STORED PC FLAGS.
	CAIE	A,500100		;MAKE SURE THE CORRECT FLAGS GOT STORED.
	ERROR	T66,13,[500100],A,,
	<XPCW IN NON-0 SECTION STORED THE WRONG FLAGS>

	MOVE	A,P2+122		;PICK UP THE STORED PC.
	CAME	A,[20030031]
	ERROR	T66,13,[20030031],A,,
	<XPCW IN NON-0 SECTION STORED THE WRONG PC.>

	JSP	A,.+1			;GET THE CURRENT PC FLAGS.
	HLRZ	A,A			;ISOLATE THEM.
	CAIE	A,740140		;MAKE SURE THE CORRECT NEW FLAGS GOT STORED.
	ERROR	T66,13,[740140],A,,
	<XPCW IN NON-0 SECTION DIDN'T SET THE NEW PC FLAGS>

T66A:	DATAI	PAG,A			;READ PROCESS STATUS
	TLO	A,37			;ADD PCS
	DATAO	PAG,A			;NOW LOAD IT
	MOVEI	A,T66B			;RETURN
	MOVEM	A,30204			;LOAD (E+3)
	XPCW	30201
T66B:	HRRZ	A,30201			;GET E FIELD OF XPCW
	CAIE	A,37			;DID THE PCS GET TO THE E FIELD (BITS 31-35)?
	ERROR	T66A,13,[37],A,,
	<XPCW - PCS DID NOT GET STORED IN E BITS 31 TO 35>


;*TEST 67 - NOW WE'LL TRY THE XPCW IN A SECTION 0 PAGE.  IT SHOULD STILL WORK.

T67:	SETUP
	PAGMAP	(P1,0,P1PN)		;MAP P1 TO ITSELF.
	PAGMAP	(P2,0,P2PN)
	SETOM	P2+121
	SETOM	P2+122			;START WITH ALL 1'S IN WORDS TO CONTAIN FLAGS.
	MOVSI	A,740140		;PC FLAGS FOR XPCW TO SET UP.
	MOVEM	A,P2+123		;PUT FLAGS WHERE XPCW WILL READ THEM FROM.
	XMOVEI	B,HOMRR2		;LOAD UP RETURN ADDRESS.
	MOVEM	B,P2+124
	MOVE	A,[XPCW P2+121]		;INSTRUCTION TO BE TESTED.
	MOVEM	A,P1+50			;STORE IT IN P1.
	XJMP	P1+50			;JUMP TO THE SECTION 0 TEST PROGRAM.
HOMRR2:	JSP	A,.+1			;GET THE PC FLAGS.
	HLRZ	A,A			;KEEP ONLY THE FLAGS.
	CAIE	A,740140		;MAKE SURE THE FLAGS GOT TURNED ON.
	ERROR	T67,13,[740140],A,,
	<XPCW IN SECTION 0 DIDN'T SET THE PC FLAGS CORRECTLY>

	DMOVE	A,P2+121		;PICK UP THE DATA XPCW WAS SUPPOSED TO STORE.
	CAIN	A,0			;MAKE SURE PC FLAGS OF ALL 0'S GOT STORED.
	CAIE	B,P1+51			;AND THAT THE RIGHT PC GOT STORED.
	ERROR	T67,13,[P1+51],B,,
	<XPCW IN SECTION 0 STORED THE WRONG PC AND/OR FLAGS>


;*TEST 70 - LET'S MAKE SURE THAT AN INSTRUCTION EXECUTED AS AN INTERRUPT INSTRUCTION
;*HAS ITS EFFECTIVE ADDRESS COMPUTED AS A SECTION 0 ADDRESS.
;*THIS TEST ALSO CHECKS THAT THE XPCW THAT IS USED AS THE INTERRUPT
;*INSTRUCTION STORES ALL THE RIGHT DATA AND TRANSFERS SUCCESSFULLY TO
;*A NON-0 SECTION ADDRESS.

T70:	SETUP
	CONO	PI,32440		;PI SYSTEM OFF, CHANNEL 2 RARING TO GO...
	MOVE	A,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO THE MAIN PROGRAM.
	MOVEM	A,P1+650
	PAGMAP	(P1,20,21)		;PAGE INTO WHICH INTERRUPT VECTOR POINTS.
	PAGMAP	(P2,31,43)		;NON-0 SECT FOR PROG FROM WHICH TIMER SHOULD INT.
	MOVE	A,[AOJA A,043222]	;PROGRAM TO BE INTERRUPTED OUT OF.
	MOVEM	A,P2+222		;NOTICE THAT IT'S AN INFINITE LOOP.
	MOVE	A,[CONO PI,PION]	;TURN ON PI SYSTEM IN NON-0 SECTION.
	MOVEM	A,P2+221		;IT COMES RIGHT BEFORE THE INFINITE LOOP.
	MOVE	A,[XPCW @C]		;THIS IS THE INTERRUPT INSTRUCTION.
	MOVEM	A,TIMVEC		;PUT IT WHERE CHANNEL 2 INTERRUPTS TO.
	DMOVE	A,[EXP 0,20021650]	;PC THAT XPCW WILL TRANSFER TO.
	DMOVEM	A,P3+400		;PUT IT SOMEWHERE.
	PAGMAP	(P3,0,P3PN)		;IT MUST BE IN SECTION 0.
	MOVE	C,[T1,,3]		;SO XPCW IS LIKE "XPCW 3(T1)"	
	MOVEI	T1,P3+400-2-3		;2 WORDS FOR STORING THE PC, AND 3 TO OFFSET THE INDEX IN C
	CONO	MTR,2			;PUT IT ON LEVEL 2.
	CONO	TIM,467777		;TURN ON TIMER,CLEAR DONE,SET LONG PERIOD,AND CLEAR TIMER.
	XMOVEI	B,HOMTIM		;LOAD UP RETURN ADDRESS.
	MOVEI	A,0			;TEST PROGRAM SHOULD INCREMENT A.
	XJMP	31043221		;JUMP TO TEST PROGRAM.
HOMTIM:	CAIN	A,0			;MAKE SURE THE TIMER INT. SOMETIME AFTER THE AOJA HAPPENED.
	ERROR	T70,13,0,0,,
	<NO TIMER INTERRUPT HAPPENED DURING THE EXPECTED INSTRUCTIONS>
	DMOVE	A,P3+376		;PICK UP THE STORED PC.
	CAME	B,[31043222]		;MAKE SURE THE CORRECT PC GOT STORED.
	ERROR	T70,13,[31043222],B,,
	<XPCW AS INTERRUPT INSTRUCTION STORED THE WRONG PC>

;*TEST 71 - NOW LET'S MAKE SURE THAT THE XJEN INSTRUCTION SUCCESSFULLY DISMISSES
;*AN INTERRUPT.  THE TEST WILL SET UP THE INTERVAL TIMER.  THE INTERRUPT
;*ROUTINE WILL INCREMENT ACCUMULATOR "A", AND USE AN XJEN INSTRUCTION
;*TO DISMISS THE INTERRUPT.  THE INTERRUPT ROUTINE WILL BE IN A NON-0
;*SECTION.  THE MAIN PROGRAM WILL USE THE TIME BASE IN ORDER TO WAIT
;*ENOUGH TIME FOR 5 INTERRUPTS TO HAPPEN, AND THEN THE CONTENTS OF
;*"A" WILL BE CHECKED TO MAKE SURE IT HAS 5 IN IT.

T71:	SETUP
	CONO	PI,32440		;CLEAR THE PI SYSTEM.
	MOVE	A,[AOJ A,]		;INSTRUCTION TO BE EXECUTED ONCE EVERY TIMER INTERRUPT.
	MOVEM	A,P1+650		;PUT IT WHERE TIMER WILL INTERRUPT TO.
	MOVE	A,[CONO TIM,60000+^D100]	;INTERRUPT EVERY MILLISECOND.
	MOVEM	A,P1+651
	MOVE	A,[XJEN @21000]		;INDIRECTION NEEDED BECAUSE SAVED PC IS IN ANOTHER SECTION.
	MOVEM	A,P1+652		;END OF INTERRUPT ROUTINE.
	MOVEI	A,P3+376		;ADDRESS OF SAVED PC.
	MOVEM	A,P1			;STORE POINTER TO RETURN PC.
	CONO	MTR,5002		;TURN OFF AND CLEAR TIME BASE, PUT TIMER ON CHANNEL 2.
	MOVE	A,[XPCW P3+376]		;INTERRUPT INSTRUCTION.
	MOVEM	A,TIMVEC		;INITALIZE INTERRUPT FOR TIMER.
	MOVEI	A,0			;THIS SHOULD GET INCREMENTED FOR EVERY TIMER INTERRUPT.
	CONO	TIM,460000+^D100	;START THE INTERVAL TIMER, BUT NO INTERRUPTS YET.
	SETZM	TIMBAS
	SETZM	TIMBAS+1		;CLEAR THE TIME BASE.
	CONO	MTR,3002		;TURN ON THE TIME BASE.
	CONO	PI,PION			;LET TIMER INTERRUPTS START HAPPENING.
TIMLUP:	DATAI	TIM,B			;READ TIME BASE INTO B AND C.
	ASHC	B,-14			;SQUEEZE IT ALL INTO ONE WORD.
	CAIE	B,0			;MAKE SURE THE HIGH ORDER WORD STAYS 0.
	ERROR	T71,13,[0],B,,
	<TIME BASE WAS UNEXPECTEDLY LARGE IN XJEN TEST>

	CAIG	C,^D5000		;HAS ENOUGH TIME PASSED YET FOR 5 INTERRUPTS ?
	JRST	TIMLUP			;NO, SO KEEP WAITING.
	CONO	PI,PIOFF		;DON'T LET ANY MORE TIMER INTERRUPTS HAPPEN.
	CONO	TIM,20000		;TURN OFF TIMER AND CLEAR DONE.
	CONO	PI,PICLR		;CLEAR PI IN CASE INTERRUPT HAPPENED AFTER PIOFF.
	CAIE	A,5			;MAKE SURE 5 INTERRUPTS HAPPENED.
	ERROR	T71,13,[5],A,,
	<THE WRONG NUMBER OF INTERRUPTS HAPPENED DURING THE XJEN TEST>

	DATAI	PAG,B			;READ PROCESS STATUS
T71A:	XJEN	[EXP 37,T71B]		;DO XJEN PUTTING PCS INTO (E) BITS 31-35
T71B:	DATAI	PAG,A			;GET PCS
	HLRZ	A,A			;NEED LEFT SIDE
	TRZ	A,777740		;KEEP ONLY BITS 31-35
	CAIE	A,37			;WAS THE PCS STORED?
	ERROR	T71A,13,[37],A,,
	<XJEN - CONTENTS OF E RIGHT DID NOT STORE INTO PCS>
	DATAO	PAG,B			;RESTORE PROCESS STATUS


;*TEST 72 - TRY A REGULAR BLT INSTRUCTION IN A NON-0 SECTION.
;*THIS ONE USES A LOCAL EFFECTIVE ADDRESS FOR THE BLT, AND MAKES SURE
;*DESTINATION OF BLT WRAPS FROM REAL AC'S TO PAGE 0 OF SECTION.

T72:	SETUP
	PAGMAP	(P1,4,777)		;WE'LL BLT FROM THE LAST PAGE OF SECTION 4.
	PAGMAP	(P2,4,0)		;PAGE FOR DESTINATION OF BLT
	DMOVE	A,[BLT C,20
		JRST @B]		;TEST PROGRAM.
	DMOVEM	A,P1+403		;PUT TEST PROGRAM IN LOCATION 4777403
	MOVE	C,[777770,,17]		;DESTINATION IS AC 17 AND WORD 20.
	MOVE	AC,P			;SAVE STACK POINTER !!
	MOVEI	17,0			;CLEAR FIRST WORD OF DESTINATION.
	SETZM	P2+20			;AND SECOND WORD.
	DMOVE	A,[EXP -4,-5]		;SOURCE DATA TO BE MOVED.
	DMOVEM	A,P1+770		;STORE IT FOR BLT TO REFERENCE.
	XMOVEI	B,HOMBUL		;LOAD UP RETURN ADDRESS FOR TEST.
	XJMP	4777403			;JUMP TO TEST PROGRAM.
HOMBUL:	MOVE	B,17			;GET FIRST WORD OF DESTINATION SO P CAN BE RESTORED.
	MOVE	A,P2+20			;AND SECOND FOR COMPARISON.
	MOVE	P,AC			;RESTORE STACK POINTER.
	CAMN	A,[-5]
	CAME	B,[-4]			;MAKE SURE CORRECT DATA GOT WRITTEN.
	ERROR	T72,13,[-4],B,,
	<REGULAR BLT IN NON-0 SECTION FAILED>


;*TEST 73 - TRY BLT IN NON-0 SECTION AGAIN, TO MAKE SURE SOURCE COMES FROM
;*AC'S WHEN LOCAL ADDRESSING IS DONE.  EFFECTIVE ADDRESS CALCULATION
;*WILL START OUT GLOBAL BUT LAST PART OF EFFECTIVE ADDRESS CALCULATION
;*WILL BE ARRANGED TO BE LOCAL

T73:	SETUP
	PAGMAP	(P1,7,0)		;WRONG SOURCE LOCATION
	PAGMAP	(P2,7,3)		;DESTINATION PAGE
	PAGMAP	(P3,7,20);PAGE "PASSED THROUGH" DURING EFFECTIVE ADDR CALCULATION
	PAGMAP	(P4,31,776)		;PAGE TO CONTAIN THE BLT INSTRUCTION
	DMOVE	A,[BLT A,@776123	;INSTRUCTION BEING TESTED
		JRST @C]		;INSTRUCTION TO GET HOME WITH
	DMOVEM	A,P4+100		;PUT BLT IN 31776100
	MOVE	A,[1B1+7020444]		;MAKE INDIRECT CHAIN
	MOVEM	A,P4+123
	MOVE	A,[1B0+3666]		;END OF INDIRECT CHAIN
	MOVEM	A,P3+444
	SETOM	P1+T1			;WRONG SOURCE DATA IS -1 IN FIRST WORD
	DMOVE	T1,[EXP -100,-332]	;REAL SOURCE DATA
	MOVE	A,[T1,,3665]		;BLT SOURCE,,DEST
	XMOVEI	C,HOMBL7		;RETURN ADDRESS
	XJMP	31776100		;JUMP TO THE TEST PROGRAM
	SETZM	P2+665
	SETZM	P2+666			;START WITH 0 IN DESTINATION AREA
HOMBL7:	DMOVN	A,P2+665		;PICK UP DESTINATION DATA AS WRITTEN
	CAIN	A,77
	CAIE	B,332			;MAKE SURE CORRECT DATA GOT WRITTEN
	ERROR	T73,13,[332],B,,
	<BLT WITH LOCAL EFFECTIVE ADDRESS DIDN'T CORRECTLY READ FROM AC'S>


;*TEST 74 - NOW WE'LL TRY A REGULAR BLT WHOSE EFFECTIVE ADDRESS IS GLOBAL, BY
;*VIRTUE OF THE FACT THAT INDEXING WILL BE USED IN THE BLT INSTRUCTION,
;*AND THE CONTENTS OF THE INDEX REGISTER LEFT HALF WILL BE POSITIVE.
;*THE TEST MAKES SURE THAT DUE TO GLOBAL ADDRESSING, SOURCE ADDRESSES
;*LESS THAN 20 CAUSES MEMORY FETCHES RATHER THAN AC REFERENCES.  (AC
;*CONTENTS WILL EXPLICITLY BE DIFFERENT TO CATCH PROBLEM)

T74:	SETUP
	PAGMAP	(P1,5,6)		;DESTINATION IS TO SECTION 5 PAGE 6
	PAGMAP	(P2,5,0)		;SOURCE DATA WILL COME FROM LOW SECTION 5 ADDRESSES
	PAGMAP	(P3,2,345)		;BLT INSTRUCTION WILL BE IN S 2 P 345
	DMOVE	T1,[EXP 2,3]		;T1 CONTAINS THE WRONG SOURCE DATA
	DMOVE	A,[EXP 4,5]		;A CONTAINS THE CORRECT DATA
	DMOVEM	A,P2+T1			;WE'LL FETCH DATA FROM LOW MEMORY
	DMOVE	A,[BLT A,(B)		;INSTRUCTION BEING TESTED
		JRST @C]		;A WAY BACK!
	DMOVEM	A,P3+67			;PUT BLT IN 2345067
	XMOVEI	C,HOMBL2		;LOAD UP RETURN INSTRUCTION
	MOVE	B,[5,,6770]		;END OF DESTINATION IS S 5 W 6770
	MOVE	A,[T1,,6767]		;MOVE BLOCK FROM 5000000+N TO 5006767
	XJMP	2345067			;GO DO THE BLT
HOMBL2:	DMOVE	A,P1+767		;PICK UP BLOCK WRITTEN BY BLT
	CAIN	A,4
	CAIE	B,5			;MAKE SURE CORRECT DATA GOT WRITTEN
	ERROR	T74,13,[5],B,,
	<BLT IN NON-0 SEC. DIDN'T READ SOURCE DATA FROM LOW MEMORY>


;*TEST 75 - NOW TRY ANOTHER EXAMPLE OF GLOBAL ADDRESSING, THIS TIME BY VIRTUE
;*OF INDIRECTION WITH B0 OF THE INDIRECT WORD BEING OFF.  THIS TIME
;*WE'LL MAKE SURE THAT LOW NUMBERED DESTINATION ADDRESSES OF THE BLT
;*GO TO MEMORY RATHER THAN AC'S.

T75:	SETUP
	PAGMAP	(P1,10,0)		;DESTINATION OF BLT IS LOW S 10 ADDRESSES
	PAGMAP	(P2,10,70)		;SOURCE IS SECTION 10 PAGE 70
	PAGMAP	(P3,37,4)		;BLT INSTRUCTION IN SEC. 37 PAGE 4
	PAGMAP	(P4,14,654)		;INDIRECT CHAIN GOES THROUGH SECTION 14
	DMOVE	A,[BLT A,@B		;INSTRUCTION BEING TESTED
		JRST @C]		;A WAY BACK INTO THE WORLD
	DMOVEM	A,P3+2			;PUT PROGRAM AT 37004002
	XMOVEI	C,HOMBL5		;LOAD UP RETURN ADDRESS
	MOVE	A,[10,,20]		;LAST ADDRESS IN DESTINATION IS 10000020
	MOVEM	A,P4+321		;GETS INDIRECTLY REFERENCED BY BLT INSTRUCTION
	DMOVE	A,[555555,,111111
		 333333,,666666]	;DATA GETTING MOVED
	DMOVEM	A,P2+222		;PUT SOURCE DATA IN 10070222
	SETZM	P1+17
	SETZM	P1+20			;CLEAR DESTINATION AREA BEFORE DOING BLT
	MOVE	A,[70222,,17]		;FROM 10070222 TO 10000017
	MOVE	B,[1B1+14654321]	;DOUBLE INDIRECT CHAIN
	MOVE	AC,P			;SAVE STACK POINTER IN CASE BLT SCREWS UP
	XJMP	37004002		;GO DO THE BLT
HOMBL5:	MOVE	P,AC			;RESTORE STACK POINTER
	DMOVE	A,P1+17			;PICK UP DATA AS WRITTEN BY BLT
	CAME	A,[555555,,111111]
	ERROR	T75,13,[555555,,111111],A,,
	<BLT DIDN'T CORRECTLY MOVE DATA TO LOW-ADDRESSED MEMORY>
	CAME	B,[333333,,666666]	;MAKE SURE DATA GOT MOVED CORRECTLY
	ERROR	T75,13,[333333,,666666],B,,
	<BLT DIDN'T CORRECTLY MOVE DATA TO LOW-ADDRESSED MEMORY>
;*TEST 76 - BEFORE WE GET ON TO THE XBLT TEST, HERE'S ONE TO MAKE SURE UNDEFINED
;*EXTENDED OPCODES CAUSE AN MUUO TRAP.  THE FOLLOWING TEST TRIES OPCODE
;*40 AS AN EXTENDED INSTRUCTION.

T76:	SETUP
	SETZM	MCODE
	XMOVEI	A,NONE+1		;GET RETURN ADDRESS FOR MUUO.
	MOVEM	A,UUOSPC		;STORE RETURN ADDRESS.
	SETOM	ALLOW1			;ALLOW AN MUUO !
NONE:	EXTEND	AC,[40B8]		;DO AN ILLEGAL EXTEND INSTRUCTION.
	MOVE	A,MCODE			;MAKE SURE MUUO STUFF GOT SET UP.
	TLZ	A,(-1B12)		;CLEAR PC FLAGS PORTION OF MUUO WORD.
	CAIE	A,(EXTEND AC,)
	ERROR	T76,13,[EXTEND AC,],A,,
	<UNDEFINED EXTENDED OPCODE CAUSED WRONG MUUO WORD TO BE SET UP>


;*TEST 77 - THE FOLLOWING TEST TRIES AN EXTENDED BLT (XBLT) INSTRUCTION.  BOTH
;*THE SOURCE AND DESTINATION AREAS WILL CROSS SECTION BOUNDARIES.
;*A PAGE FAIL WILL BE ARRANGED IN THE MIDDLE OF THE BLT, SO THAT THE
;*AC'S MAY BE EXAMINED TO MAKE SURE THE MICROCODE CORRECTLY RESTORES THEM
;*FOR THE INTERRUPT.

T77:	SETUP
	PAGMAP	(P1,14,777)		;SOURCE AREA STARTS AT END OF SECTION 14.
	PAGMAP	(P2,15,0)		;AND FLOWS INTO SECTION 15.
	PAGMAP	(P3,10,777)		;DESTINATION STARTS IN SECTION 10.
	PAGMAP	(P4,11,0)		;AND FLOWS INTO SECTION 11.
	PUSH	P,ESECT+15		;SAVE SECTION 15 POINTER.
	SETZM	ESECT+15		;WE WANT A PAGE FAULT DURING THE XBLT.
	CONO	PAG,@EPWD		;MAKE SURE HARDWARE SEES CLEARED SECTION POINTER !
	MOVEI	T1,4			;WE'LL MOVE 4 WORDS.
	MOVE	T2,[14777776]		;FROM SECTION 14
	MOVE	T3,[10777775]		;TO SECTION 10.
	DMOVE	A,[EXP 1,2]
	DMOVEM	A,P1+776
	DMOVE	A,[EXP 3,4]
	DMOVEM	A,P2			;SOURCE DATA IS 1,2,3,4.
	MOVEI	A,5
	MOVEM	A,P2+2			;WE'LL MAKE SURE THIS ONE ISN'T MOVED.
	SETZM	P3+775
	SETZM	P3+776
	SETZM	P4
	SETZM	P4+1
	SETZM	P4+2			;START WITH ALL 0'S IN DESTINATION AREA.
	MOVSI	T4,(XBLT)		;INSTRUCTION BEING TESTED.
	DMOVE	AC,[EXTEND T1,T4
		JRST @B]		;TEST PROGRAM TO BE RUN IN SECTION 1 (IN THE AC'S)
	XMOVEI	A,FXBLT			;GET ADDRESS OF SPECIAL BLT PAGE FAULT HANDLER.
	MOVEM	A,PFHSPC		;SAVE IT FOR FAULT HANDLER TO TRANSFER TO.
	XMOVEI	B,HOMXBT		;LOAD UP RETURN ADDRESS.
	SETOM	PFF			;ALLOW 1 PAGE FAULT DURING XBLT.
	XJMP	1B17+AC			;JUMP INTO SECTION 1 TO THE TEST.

;*HERE'S THE CODE THAT GETS EXECUTED WHEN THE FORWARD XBLT GETS ITS
;*PAGE FAULT.

FXBLT:	CAIE	T1,2			;MAKE SURE THERE ARE STILL 2 WORDS TO GO.
	ERROR	T77,13,[2],T1,,
	<FORWARD XBLT HAS INCORRECT COUNT DURING PAGE FAULT>

	CAME	T2,[15000000]
	ERROR	T77,13,[15000000],T2,,
	<FORWARD XBLT HAS INCORRECT POINTERS DURING PAGE FAULT>
	CAME	T3,[10777777]
	ERROR	T77,13,[10777777],T3,,
	<FORWARD XBLT HAS INCORRECT POINTERS DURING PAGE FAULT>

	POP	P,ESECT+15		;REMOVE THE PAGE FAULT.
	CONO	PAG,@EPWD		;TELL HARDWARE ABOUT THE CHANGE.
	JRST	PFHRET			;RETURN TO FINISH THE BLT.

;*GET TO HERE WHEN FORWARD XBLT FINISHES.

HOMXBT:	SKIPE	PFF			;MAKE SURE THE PAGE FAULT HAPPENED.
	ERROR	T77,13,0,0,,
	<FORWARD XBLT DIDN'T PAGE FAULT>

	CAIE	T1,0			;MAKE SURE LENGTH COUNTED TO 0.
	ERROR	T77,13,[0],T1,,
	<FORWARD XBLT DIDN'T COUNT TO 0>

	CAME	T2,[15000002]
	ERROR	T77,13,[15000002],T2,,
	<FORWARD XBLT DIDN'T LEAVE RESULTANT POINTERS CORRECT>
	CAME	T3,[11000001]
	ERROR	T77,13,[11000001],T3,,
	<FORWARD XBLT DIDN'T LEAVE RESULTANT POINTERS CORRECT>

	DMOVE	A,P3+775
	CAIE	A,1
	ERROR	T77,13,[1],A,,
	<FORWARD XBLT DIDN'T MOVE DATA CORRECTLY>
	CAIE	B,2
	ERROR	T77,13,[2],B,,
	<FORWARD XBLT DIDN'T MOVE DATA CORRECTLY>

	MOVE	A,P3+777
	MOVE	B,P4
	CAIE	A,3
	ERROR	T77,13,[3],A,,
	<FORWARD XBLT DIDN'T MOVE DATA CORRECTLY>
	CAIE	B,4
	ERROR	T77,13,[4],B,,
	<FORWARD XBLT DIDN'T MOVE DATA CORRECTLY>

	SKIPE	P4+1
	ERROR	T77,13,0,0,,
	<FORWARD XBLT MOVED TOO MANY DATA WORDS>

	XMOVEI	B,HOMXB2		;PREPARE TO TRY A LENGTH OF 0.
	XJMP	1B17+AC
HOMXB2:	CAIE	T1,0			;MAKE SURE THE LENGTH DIDN'T CHANGE.
	ERROR	T77,13,[0],T1,,
	<XBLT OF 0 WORDS DID SOMETHING>
	CAME	T2,[15000002]		;OR THE SOURCE POINTER.
	ERROR	T77,13,[15000002],T2,,
	<XBLT OF 0 WORDS DID SOMETHING>

	CAME	T3,[11000001]		;MAKE SURE DESTINATION POINTER O.K.
	ERROR	T77,13,[11000001],T3,,
	<XBLT OF 0 WORDS CHANGED THE DESTINATION POINTER>
	SKIPN	XBLTS0			;CAN MICRO CODE DO XBLT IN SECTION 0
	SETOM	ALLOW1			;NO ALLOW 1 MUUO
	XMOVEI	B,HOMXB3
	MOVEM	B,UUOSPC		;SET UP MUUO RETURN ADDRESS.
	XJMP	AC			;MAKE SURE XBLT IN SECTION 0 IS ILLEGAL.
HOMXB3:	SKIPE	ALLOW1			;MAKE SURE IT "MUUOED"
	ERROR	T77,13,0,0,,
	<XBLT IN SECTION 0 DIDN'T TRAP>
;*TEST 100 - O.K., HOW ABOUT XBLTING BACKWARDS...

T100:	SETUP
	MOVNI	T1,4			;WE'LL MOVE 4 WORDS.
	MOVE	T2,[15000002]
	MOVE	T3,[15000001]		;WE'LL USE OVERLAPPING TO DUPLICATE A DATA WORD.
	MOVSI	A,5			;HERE'S THE DATA.
	MOVEM	A,P2+1
	SETZM	P2
	SETZM	P1+777			;START WITH 0'S IN THE REST OF THE DATA WORDS.
	SETZM	P1+776
	SETZM	P1+775
	SETZM	P1+774			;THIS ONE TO MAKE SURE TOO MANY WORDS AREN'T MOVED.
	SETZM	P2+2			;MAKE SURE THE FIRST WORD ISN'T FETCHED FROM HERE.
	PUSH	P,ESECT+14		;THIS TIME WE'LL CAUSE PAGE TRAP ON STORING A DATA WORD.
	SETZM	ESECT+14		;MAKE SECTION 14 OFF LIMITS.
	CONO	PAG,@EPWD		;TELL HARDWARE THAT SECTION 14 IS OFF LIMITS.
	XMOVEI	A,BXBLT			;GET ADDRESS OF PAGE TRAP HANDLER FOR BACKWARDS BLT.
	MOVEM	A,PFHSPC		;TELL PAGE FAULT HANDLER WHERE TO GO.
	SETOM	PFF			;ALLOW 1 PAGE FAULT.
	XMOVEI	B,HOMXB4
	XJMP	1B17+AC			;JUMP TO TEST PROGRAM.

;*PAGE TRAP DURING BACKWARDS BLT TRANSFERS TO HERE.

BXBLT:	CAME	T1,[-3]			;MAKE SURE ONLY ONE WORD GOT MOVED BEFORE TRAP.
	ERROR	T100,13,[-3],T1,,
	<BACKWARDS XBLT COUNT DURING PAGE TRAP IS WRONG>

	CAME	T2,[15000001]		;TRAP SHOULD OCCUR ATTEMPTING TO MOVE [15000000
	ERROR	T100,13,[15000001],T2,,
	<BACKWARDS XBLT POINTER(S) WRONG DURING PAGE TRAP>
	CAME	T3,[15000000]		;INTO 14777777.
	ERROR	T100,13,[15000000],T3,,
	<BACKWARDS XBLT POINTER(S) WRONG DURING PAGE TRAP>

	POP	P,ESECT+14		;ALLOW THE BLT TO CONTINUE
	JRST	PFHRET			;CONTINUE THE XBLT.

;*GET TO HERE WHEN BACKWARDS XBLT FINISHES.

HOMXB4:	CAIE	T1,0			;MAKE SURE THE LENGTH WAS EXHAUSTED.
	ERROR	T100,13,[0],T1,,
	<XBLT BACKWARDS DIDN'T COUNT TO 0>

	CAME	T2,[14777776]		;MAKE SURE THE POINTERS WERE UPDATED.
	ERROR	T100,13,[14777776],T2,,
	<XBLT BACKWARDS UPDATED THE POINTERS INCORRECTLY>
	CAME	T3,[14777775]
	ERROR	T100,13,[14777775],T3,,
	<XBLT BACKWARDS UPDATED THE POINTERS INCORRECTLY>

	SKIPE	P1+774			;MAKE SURE NOT TO MANY WORDS WERE WRITTEN.
	ERROR	T100,13,0,0,,
	<XBLT BACKWARDS MOVED TOO MANY WORDS>

	DMOVE	A,P2			;PICK UP TWO DATA WORDS.
	CAME	A,[5,,]
	ERROR	T100,13,[5,,],A,,
	<XBLT BACKWARDS MOVED DATA INCORRECTLY>
	CAME	B,[5,,]			;MAKE SURE THEY'RE ALL THE SAME.
	ERROR	T100,13,[5,,],B,,
	<XBLT BACKWARDS MOVED DATA INCORRECTLY>

	DMOVE	A,P1+776		;LOOK AT THE REST OF THE DATA WORDS.
	CAME	A,[5,,]
	ERROR	T100,13,[5,,],A,,
	<XBLT BACKWARDS MOVED DATA INCORRECTLY>
	CAME	B,[5,,]			;MAKE SURE THEY'RE ALL THE SAME.
	ERROR	T100,13,[5,,],B,,
	<XBLT BACKWARDS MOVED DATA INCORRECTLY>

	MOVE	B,P1+775		;GET THE LAST DATA WORD.
	CAME	B,[5,,]
	ERROR	T100,13,[5,,],B,,
	<XBLT BACKWARDS MOVED DATA INCORRECTLY>


;*TEST 101 - THE FOLLOWING TESTS TRY PXCTING AN XBLT INSTRUCTION.

T101:	SETUP
	PAGMAP	(P1,32,20)		;PAGE FOR TEST PROGRAM.
	MOVE	A,[[MOVEI T1,2		;HERE'S THE TEST PROGRAM.  TWO WORDS WILL GET MOVED.
		MOVE T2,AC2		;AC2 WILL HAVE THE SOURCE POINTER IN IT.
		MOVE T3,AC3		;AC3 WILL HAVE THE DESTINATION POINTER IN IT.
		XCT AC4			;AC4 WILL HAVE THE PXCT INSTRUCTION IN IT.
		JRST @B			;B WILL HOLD THE RETURN ADDRESS.
			],,P1]		;PLACE INTO WHICH TO MOVE THE TEST PROGRAM.
	BLT	A,P1+20			;20 WORDS SHOULD BE ENOUGH...
	PAGMAP	(P2,2,777)		;EXEC FIRST PART OF DESTINATION AREA.
	PAGMAP	(P3,3,0)		;EXEC REST OF DESTINATION AREA.
	UPAGMP	(P4,2,777)		;USER FIRST PART OF DESTINATION AREA.
	UPAGMP	(P5,3,0)		;USER REST OF DESTINATION AREA.
	PAGMAP	(P6,4,10)		;EXEC SOURCE AREA.
	UPAGMP	(P7,4,10)		;USER SOURCE AREA.
	MOVE	AC2,[4,,010750]		;XBLT SOURCE POINTER.
	MOVE	AC3,[2,,777777]		;DESTINATION POINTER.
	DMOVE	A,[EXP 1B5,2B5]		;EXEC SOURCE DATA.
	DMOVEM	A,P6+750
	DMOVE	A,[EXP 3B5,4B5]		;USER SOURCE DATA.
	DMOVEM	A,P7+750
	PREV	(U,0)			;MAKE PREVIOUS CONTEXT BE USER.
	MOVE	AC,[EXTEND T1,AC1]	;EXTEND INSTRUCTION FOR INVOKING XBLT.
	MOVSI	AC1,(XBLT)		;XBLT BEING INVOKED.
	MOVE	AC4,[PXCT 2,AC]		;PXCT INSTRUCTION TO BE EXECUTED.
	SETZM	P2+777
	SETZM	P3			;START WITH 0 IN DESTINATION AREA.
	JRST	PXSKIP			;SKIP OVER THE DRIVER ROUTINE.

;*ROUTINE FOR RUNNING SOME OF THE PXT TESTS.

PXRUT:	XMOVEI	B,PXRUT2
	SFM	PXRUF			;WE REALLY NEED XJRST HERE !!
	XJRSTF	PXRUF			;JUMP TO TEST PROGRAM.
PXRUT2:	POPJ	P,
PXRUF:	0				;HOLDS PC FLAGS.
	32020000			;PC WE'RE TRANSFERRING TO.

PXSKIP:	PUSHJ	P,PXRUT			;RUN THE TEST.
	MOVE	A,P2+777
	MOVE	B,P3			;RETRIEVE THE SOURCE DATA.
	CAME	A,[3B5]
	ERROR	T101,13,[3B5],A,,
	<PXCT 2,XBLT FAILED>
	CAME	B,[4B5]
	ERROR	T101,13,[4B5],B,,
	<PXCT 2,XBLT FAILED>

	TLO	AC4,(1B12);NOW BOTH SOURCE AND DESTINATION SHOULD BE FROM PREVIOUS CONTEXT.
	SETZM	P4+777
	SETZM	P5			;CLEAR OUT DESTINATION AREA.
	PUSHJ	P,PXRUT			;EXECUTE THE TEST.
	MOVE	A,P4+777
	MOVE	B,P5			;READ DESTINATION STRING.
	CAME	A,[3B5]
	ERROR	T101,13,[3B5],A,,
	<PXCT 3,XBLT FAILED>
	CAME	B,[4B5]			;MAKE SURE CORRECT WORDS GOT MOVED.
	ERROR	T101,13,[4B5],B,,
	<PXCT 3,XBLT FAILED>

	TLZ	AC4,(2B12)		;NOW ONLY DESTINATION SHOULD BE PREVIOUS.
	SETZM	P4+777
	SETZM	P5			;START WITH 0 IN DESTINATION AREA.
	PUSHJ	P,PXRUT			;RUN THE TEST.
	MOVE	A,P4+777
	MOVE	B,P5			;PICK UP DATA.
	CAME	A,[1B5]
	ERROR	T101,13,[1B5],A,,
	<PXCT 1,XBLT FAILED>
	CAME	B,[2B5]
	ERROR	T101,13,[2B5],B,,
	<PXCT 1,XBLT FAILED>

	TLZ	AC4,(17B12)		;NOW TURN ALL THE BITS OFF IN PXCT 9-12.
	SETZM	P2+777
	SETZM	P3			;START WITH 0'S IN DESTINATION.
	PUSHJ	P,PXRUT			;RUN THE TEST.
	MOVE	A,P2+777
	MOVE	B,P3			;PICK UP DESTINATION DATA.
	CAME	A,[1B5]
	ERROR	T101,13,[1B5],A,,
	<PXCT 0,XBLT FAILED>
	CAME	B,[2B5]
	ERROR	T101,13,[2B5],B,,
	<PXCT 0,XBLT FAILED>


;*TEST 102 - THE NEXT 6 TESTS DO A PXCT OF A MOVE INSTRUCTION.  THE MOVE
;*INSTRUCTION USES INDIRECTION SO AS TO CAUSE B9 IN THE PXCT INSTRUCTION
;*TO MAKE A DIFFERENCE.  THE PAG MAPS AND VARIOUS WORD CONTENTS ARE SET
;*UP SUCH THAT AS MANY OF THE SIX CASES TRIED WILL FETCH DIFFERENT DATA
;*WORDS.  THE CURRENT AND PREVIOUS CONTEXTS WILL BE SET TO 3 AND 21
;*REPECTIVELY.  THE SIX CASES TO BE TRIED ARE BITS 9 AND 10 BEING
;*00,01,11 FOR PCU BEING 0 AND 1.

T102:	SETUP
	PAGMAP	(P1,3,40)
	MOVE	A,[2,,50010]
	MOVEM	A,P1
	PAGMAP	(P2,2,50)
	MOVE	A,[1,,11]		;DATA TO BE FETCHED BY PXCT N,[MOVE A,@40000]
					;WHEN PCU=0 AND BITS 9,10 OF N = 00 OR 01.
					;ALSO WHEN PCU=1 AND PITS 9,10 OF N =00.
	MOVEM	A,P2+10
	PAGMAP	(P3,21,40)
	MOVE	A,[4,,3]
	MOVEM	A,P3
	PAGMAP	(P4,4,0)
	MOVE	A,[3,,33]		;DATA TO BE FETCHED WHEN PCU=0 AND 9,10=11
	MOVEM	A,P4+3
	UPAGMP	(P5,21,40)
	MOVE	A,[5,,62222]
	MOVEM	A,P5
	UPAGMP	(P6,2,50)
	MOVE	A,[5,,55]		;DATA TO BE FETCHED WHEN PCU=1, AND 9,10=01
	MOVEM	A,P6+10
	UPAGMP	(P7,5,62)
	MOVE	A,[7,,77]		;DATA TO BE FETCHED WHEN PCU=1, AND 9,10=11
	MOVEM	A,P7+222
	MOVE	A,[MOVE A,@40000]	;INSTRUCTION TO BE PXCTED.
	MOVEM	A,P1+123
	MOVE	A,[PXCT 0,40123]	;INSTRUCTION BEING TESTED.
	MOVEM	A,P1+456
	MOVE	A,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO MAIN PROGRAM.
	MOVEM	A,P1+457
	XMOVEI	B,HOM000		;LOAD UP RETURN ADDRESS.
	XJRSTF	[EXP 21,3040456]	;JUMP TO TEST PROGRAM.
HOM000:	CAME	A,[1,,11]		;MAKE SURE THE EXPECTED DATA GOT FETCHED.
	ERROR	T102,13,[1,,11],A,,
	<PXCT OF MOVE FAILED WHEN PCU=0 AND BITS 9,10=0>

	MOVE	A,[PXCT 4,40123]	;CHANGE BITS 9,10 TO 01
	MOVEM	A,P1+456
	XMOVEI	B,HOM001
	XJRSTF	[EXP 21,3040456]
HOM001:	CAME	A,[1,,11]
	ERROR	T102,13,[1,,11],A,,
	<PXCT OF MOVE INSTRUCTION FAILED WHEN PCU=0 AND BITS 9,10=01>

	MOVE	A,[PXCT 14,40123]	;NOW TRY BITS 9,10 BOTH ON.
	MOVEM	A,P1+456
	XMOVEI	B,HOM011
	XJRSTF	[EXP 21,3040456]
HOM011:	CAME	A,[3,,33]
	ERROR	T102,13,[3,,33],A,,
	<PXCT OF MOVE INSTRUCTION WITH PCU,B9,B10=011 FAILED>

	MOVE	A,[PXCT 0,40123]	;TRY PCU=1, B9,10=00
	MOVEM	A,P1+456
	XMOVEI	B,HOM100
	XJRSTF	[EXP PCUBIT!21,3040456]
HOM100:	CAME	A,[1,,11]
	ERROR	T102,13,[1,,11],A,,
	<PXCT OF MOVE INSTRUCTION FAILED WITH PCU,B9,B10=100>

	MOVE	A,[PXCT 4,40123]	;KEEP PCU=1, SET B10
	MOVEM	A,P1+456
	XMOVEI	B,HOM101
	XJRSTF	[EXP PCUBIT,3040456]
HOM101:	CAME	A,[5,,55]
	ERROR	T102,13,[5,,55],A,,
	<PXCT OF MOVE INSTRUCTION FAILED WITH PCU,B9,B10=101>

	MOVE	A,[PXCT 14,40123]
	MOVEM	A,P1+456
	XMOVEI	B,HOM111
	XJRSTF	[EXP PCUBIT!21,3040456]
HOM111:	CAME	A,[7,,77]
	ERROR	T102,13,[7,,77],A,,
	<PXCT OF MOVE INSTRUCTION FAILED WITH PCU,B9,B10=111>


;*TEST 103 - HERE'S A TEST OF A MOVSLJ INSTRUCTION IN A NON-0 SECTION WITH
;*BIT 12 ON IN BYTE POINTERS.

T103:	SETUP
	PAGMAP	(P1,3,0)		;PAGE FOR SOURCE DATA.
	PAGMAP	(P2,37,777)		;PAGE FOR DESTINATION DATA, AND PROGRAM.
	MOVSI	C,(MOVSLJ)		;WE'LL TRY A MOVE STRING LEFT JUSTIFIED.
	MOVEI	AC,2			;WE'LL MOVE TWO BYTES.
	MOVSI	AC1,440740		;SOURCE POINTER HAS BIT 12 ON.
	MOVE	AC2,[3,,500]		;SOURCE BYTES COME FROM SECTION 3.
	MOVEI	AC3,2			;DESTINATION BYTE STRING HAS 2 BYTES TOO.
	MOVSI	AC4,070740		;BIT 12 ON.
	MOVE	AC5,[37,,777776]	;THIS WILL HAVE TO GET INCREMENTED.
	MOVE	A,[EXTEND AC,C]		;INSTRUCTION BEING TESTED.
	MOVEM	A,P2+500		;YUP
	SETZM	P2+501			;THE INSTRUCTION SHOULD SKIP !!
	MOVE	A,[JRST @B]		;THIS IS HOW WE GET BACK TO THE MAIN STREAM.
	MOVEM	A,P2+502
	SETZM	P2+776
	SETZM	P2+777			;START WITH 0 IN DESTINATION AREA.
	MOVSI	A,(ASCII /AB/)		;SOURCE BYTE DATA
	MOVEM	A,P1+500		;STORE THE SOURCE BYTES.
	XMOVEI	B,HOMMSL		;LOAD UP RETURN ADDRESS
	XJMP	37777500		;JUMP TO EXTEND INSTRUCTION.
HOMMSL:	CAIE	AC,0
	ERROR	T103,13,[0],AC,,
	<FINAL STRING LENGTH OF MOVSLJ NOT 0>
	CAIE	AC3,0			;MAKE SURE LENGTHS EXHAUSTED.
	ERROR	T103,13,[0],AC3,,
	<FINAL STRING LENGTH OF MOVSLJ NOT 0>

	CAME	AC1,[260740,,0]		;CHECK INCREMENTING OF FIRST POINTER.
	ERROR	T103,13,[260740,,0],AC1,,
	<FINAL FIRST POINTER OF MOVSLJ>
	CAME	AC2,[3,,500]
	ERROR	T103,13,[3,,500],AC2,,
	<FINAL FIRST POINTER OF MOVSLJ>

	CAME	AC4,[350740,,0]		;CHECK SECOND POINTER.
	ERROR	T103,13,[350740,,0],AC4,,
	<FINAL SECOND POINTER WAS BAD FOR MOVSLJ>
	CAME	AC5,[37,,777777]	;MAKE SURE SECOND WORD GOT INCREMENTED.
	ERROR	T103,13,[37,,777777],AC5,,
	<FINAL SECOND POINTER WAS BAD FOR MOVSLJ>

	DMOVE	A,P2+776		;LOAD UP DESTINATION STRING.
	CAIE	A,"A"
	ERROR	T103,13,["A"],A,,
	<WRONG STRING WRITTEN BY MOVSLJ>
	CAME	B,[ASCII /B/]		;CHECK FOR VALID DESTINATION STRING.
	ERROR	T103,13,[ASCII /B/],B,,
	<WRONG STRING WRITTEN BY MOVSLJ>


;*TEST 104 - THE FOLLOWING TEST CHECKS THAT THE MICROCODE DOESN'T CARRY FROM B18
;*TO B17 OF THE EDIT PATTERN OPERATOR POINTER WHEN THE EDIT IS BEING
;*DONE IN SECTION 0.  IT ALSO CHECKS THAT THE PATTERN OPERATORS ALWAYS
;*COME FROM SECTION 0 WHEN THE EDIT IS BEING DONE IN SECTION 0, REGARDLESS
;*OF THE LEFT HALF CONTENTS OF AC0.  AS IF THIS WEREN'T ENOUGH, THE TEST
;*ALSO MAKES SURE BIT 12 ON IN BYTE POINTERS DOESN'T CAUSE THEM TO BE
;*DOUBLE POINTERS (AGAIN BECAUSE THE EDIT IS IN SECTION 0).
;*IT ALSO CHECKS THAT MARK POINTER ADDRESS IS IN SECTION 0 REGARDLESS
;*OF LEFT HALF OF AC3.

T104:	SETUP
	PAGMAP	(P1,0,P1PN)		;PAGE FOR THE EDIT INSTRUCTION AND DATA.
	PAGMAP	(P2,0,777)		;PAGE FOR PATTERN OPERATORS.
	SETZM	ESECT+3			;CAUSE PAGE FAULT ON REFERENCE TO SECTION 3.
	CONO	PAG,@EPWD		;TELL HARDWARE ABOUT THE UPDATE.
	MOVE	A,[BYTE(9)SELECT,SELECT,STOP]
	MOVEI	B,0
	LSHC	A,-^D27			;FIRST OP IN A, SECOND TWO IN B.
	MOVE	0,B			;PATTERN OPS SHOULD WRAP INTO AC0.
	MOVEM	A,P2+777		;THEY START IN THE LAST WORD OF SECTION 0.
	MOVE	AC,[3B5+2777777];ONE OF TEST'S FUNCT IS TO MAKE SURE LEFT HALF DOESN'T INC.
	MOVE	A,[EXTEND AC,T1]	;INSTRUCTION BEING EXECUTED.
	MOVEM	A,P1
	SETZM	P1+1			;GET MUUO TRAP IF EDIT DOESN'T SKIP.
	MOVE	T1,[EDIT P1+10]		;TRANSLATION TABLE IS IN P1+10
	MOVE	A,[400000+"N",,"P"]
	MOVEM	A,P1+10+1		;2 TRANSLATES TO "N", 3 TO "P"
	SETZM	P1+7			;DESTINATION STRING GOES HERE.
	MOVE	AC4,[010740,,P1+6]
	MOVSI	AC5,3			;MAKE SURE SECTION 3 ISN'T REFERENCED !.
	MOVE	AC3,[3,,P1+5]		;MARK POINTER, 3 SHOULD BE IGNORED.
	SETZM	P1+5			;START WITH 0 AS MARK POINTER.
	MOVE	A,[2,,3]		;SOURCE STRING.
	MOVEM	A,P1+6
	MOVE	AC1,[002240,,P1+5]	;SOURCE POINTER.
	MOVSI	AC2,3			;3 SHOULD GET IGNORED !!
	MOVE	A,[JRST @B]		;INSTRUCTION FOR RETURNING TO MAIN PROGRAM.
	MOVEM	A,P1+2			;EDIT RETURNS TO HERE...
	XMOVEI	B,HOMED9		;LOAD UP RETURN ADDRESS.
	XJMP	P1			;JUMP TO THE TEST.
HOMED9:	CAME	AC,[6B2+2B5+2000000]
	ERROR	T104,13,[6B2+2B5+2000000],AC,,
	<EDIT IN SECTION RETURNED WRONG AC>
	CAME	AC1,[002240,,P1+6]
	ERROR	T104,13,[002240,,P1+6],AC1,,
	<EDIT IN SECTION RETURNED WRONG AC1>

	CAME	AC2,[3,,]
	ERROR	T104,13,[3,,],AC2,,
	<EDIT IN SECTION 0 CLOBBERED AC2>
	CAME	AC3,[3,,P1+5]
	ERROR	T104,13,[3,,P1+5],AC3,,
	<EDIT IN SECTION 0 CLOBBERED AC3>

	CAME	AC4,[260740,,P1+7]
	ERROR	T104,13,[260740,,P1+7],AC4,,
	<EDIT IN SECTION 0 UPDATED DESTINATION POINTER WRONG>
	CAME	AC5,[3,,]
	ERROR	T104,13,[3,,],AC5,,
	<EDIT IN SECTION 0 UPDATED DESTINATION POINTER WRONG>

	MOVE	A,P1+5
	CAME	A,[440740,,P1+7]
	ERROR	T104,13,[440740,,P1+7],A,,
	<EDIT IN SECTION 0 STORED WRONG MARK POINTER>

	MOVE	A,P1+7
	CAME	A,[ASCII /NP/]
	ERROR	T104,13,[ASCII /NP/],A,,
	<EDIT IN SECTION 0 STORED WRONG DESTINATION STRING>


;*TEST 105 - UPON SIGNIFICANCE STARTING DURING AN EDIT OPERATION, THE DESTINATION
;*POINTER GETS STORED IN THE WORD(S) POINTED TO BY THE MARK POINTER.  THE
;*FOLLOWING TEST MAKES SURE THAT THAT WORD MAY SUCCESSFULLY POINT TO
;*ANOTHER SECTION.
;*IT ALSO ASSURES THAT THE PATTERN STRING MAY BE IN A NON-0 DIFFERENT
;*SECTION THAN THE EDIT INSTRUCTION.  THIS TEST ALSO TRIES SINGLE AND
;*DOUBLE WORD DESTINATION POINTERS TO MAKE SURE THAT ONE OR TWO WORDS
;*GET STORED IN THE MARK POINTER AREA, AS APPROPRIATE.

T105:	SETUP
	PAGMAP	(P1,7,777)		;PAGE FOR FIRST PATTERN OPERATOR.
	PAGMAP	(P2,10,0)		;PAGE FOR REST OF PATTERN STRING.
	PAGMAP	(P3,15,777)		;FIRST PAGE FOR MARK POINTER.
	PAGMAP	(P4,16,0);SECOND MARK POINTER PAGE (ONLY USED IF BIT 12 IN D.P. ON)
	PAGMAP	(P5,13,2)		;PAGE FOR THE EXTEND, EDIT, AND TABLE.
	MOVE	AC,[3B5+7777777]	;PATTERN OPERATOR POINTER, NO SIGNIFICANCE.
	DMOVE	A,[BYTE(9)STOP,STOP,STOP,SIGST,STOP]
	MOVEM	A,P1+777		;FIRST OPERATOR IS "SIGST".
	MOVEM	B,P2			;SECOND (AND LAST) IS "STOP".
	MOVE	AC1,[440700,,34];SOURCE POINTER WHICH SHOULDN'T CHANGE FOR THIS EXAMPLE.
	MOVEI	AC2,3			;SECOND WORD OF SOURCE POINTER, WHICH SHOULDN'T CHANGE.
	MOVE	AC3,[15,,777777]	;MARK POINTER.
	MOVE	AC4,[440700,,C]		;NO BIT 12 IN THIS DESTINATION POINTER.
	MOVEI	AC5,4			;SECOND WORD OF DESTINATION POINTER.
	MOVSI	A,(EDIT)		;EDIT INSTRUCTION TO BE EXECUTED.
	MOVEM	A,P5+4			;PUT IT IN LOCATION 13002004
	SETZM	P5+6
	SETZM	P5+7			;MAKE SURE FILLER AND FLOAT CHARACTERS ARE NON-EXISTENT.
	MOVE	A,[EXTEND AC,2004]	;EXTEND INSTRUCTION FOR INVOKING THE EDIT.
	MOVEM	A,P5+1
	SETZM	P5+2			;NON-SKIP RETURN WILL CAUSE ILLEGAL MUUO.
	MOVE	A,[JRST @B]		;INSTRUCTION FOR RETURNING TO MAIN PROGRAM.
	MOVEM	A,P5+3
	SETZM	P3+777
	SETOM	P4			;SET SECOND MARK POINTER WORD TO ALL 1'S
	XMOVEI	B,HOMEDI		;LOAD UP RETURN ADDRESS.
	XJMP	13002001		;JUMP TO THE TEST.
HOMEDI:	CAME	AC,[1B0+1B5+10B17]	;MAKE SURE PATTERN POINTER GOT UPDATED CORRECTLY.
	ERROR	T105,13,[1B0+1B5+10B17],AC,,
	<EDIT INSTRUCTION LEFT UNKOSHER PATTERN OPERATOR POINTER>

	CAME	AC1,[440700,,34]
	ERROR	T105,13,[440700,,34],AC1,,
	<BAD FINAL SOURCE POINTER IN EDIT INSTRUCTION>
	CAIE	AC2,3			;MAKE SURE SOURCE POINTER DIDN'T CHANGE.
	ERROR	T105,13,[3],AC2,,
	<BAD FINAL SOURCE POINTER IN EDIT INSTRUCTION>

	CAME	AC3,[15,,777777]	;MAKE SURE MARK POINTER DIDN'T CHANGE.
	ERROR	T105,13,[15,,777777],AC3,,
	<EDIT INSTRUCTION CLOBBERED MARK POINTER ADDRESS>

	CAME	AC4,[440700,,C]
	ERROR	T105,13,[440700,,C],AC4,,
	<EDIT INSTRUCTION DESTINATION POINTER CHANGED UNEXPECTEDLY>
	CAIE	AC5,4			;MAKE SURE DESTINATION POINTER DIDN'T CHANGE.
	ERROR	T105,13,[4],AC5,,
	<EDIT INSTRUCTION DESTINATION POINTER CHANGED UNEXPECTEDLY>

	MOVE	A,P3+777
	CAME	A,[440700,,C]		;MAKE SURE MARK POINTER GO SET UP
	ERROR	T105,13,[440700,,C],A,,
	<EDIT INSTRUCTION DIDN'T STORE CORRECT MARK POINTER>

	AOSE	P4			;MAKE SURE SECOND WORD IS STILL -1.
	ERROR	T105,13,[-1],P4,,
	<SECOND MARK POINTER IN EDIT INSTRUCTION GOT UNEXPECTEDLY REFERENCED>


;*TEST 106 - NOW WE'LL HAVE BIT 12 ON IN THE DESTINATION POINTER, AND MAKE SURE THAT
;*TWO WORDS OF DESTINATION POINTER ARE STORED.

T106:	SETUP
	MOVE	AC,[3B5+7777777]	;PATTERN OPERATOR POINTER, NO SIGNIFICANCE.
	DMOVE	A,[BYTE(9)STOP,STOP,STOP,SIGST,STOP]
	MOVEM	A,P1+777		;FIRST OPERATOR IS "SIGST".
	MOVEM	B,P2			;SECOND (AND LAST) IS "STOP".
	MOVE	AC1,[440700,,34];SOURCE POINTER WHICH SHOULDN'T CHANGE FOR THIS EXAMPLE.
	MOVEI	AC2,3			;SECOND WORD OF SOURCE POINTER, WHICH SHOULDN'T CHANGE.
	MOVE	AC3,[15,,777777]	;MARK POINTER.
	MOVE	AC4,[440740,,C]		;BIT 12 IN THIS DESTINATION POINTER.
	MOVEI	AC5,4			;SECOND WORD OF DESTINATION POINTER.
	SETZM	P3+777
	SETOM	P4			;INITIALIZE MARK POINTER AREA.
	XMOVEI	B,HOMED2		;LOAD UP RETURN ADDRESS.
	XJMP	13002001		;JUMP TO THE TEST.
HOMED2:	CAME	AC,[1B0+1B5+10B17]	;MAKE SURE PATTERN POINTER GOT UPDATED CORRECTLY.
	ERROR	T106,13,[1B0+1B5+10B17],AC,,
	<EDIT INSTRUCTION LEFT UNKOSHER PATTERN OPERATOR POINTER>

	CAME	AC1,[440700,,34]
	ERROR	T106,13,[440700,,34],AC1,,
	<BAD FINAL SOURCE POINTER IN EDIT INSTRUCTION>
	CAIE	AC2,3			;MAKE SURE SOURCE POINTER DIDN'T CHANGE.
	ERROR	T106,13,[3],AC2,,
	<BAD FINAL SOURCE POINTER IN EDIT INSTRUCTION>

	CAME	AC3,[15,,777777]	;MAKE SURE MARK POINTER DIDN'T CHANGE.
	ERROR	T106,13,[15,777777],AC3,,
	<EDIT INSTRUCTION CLOBBERED MARK POINTER ADDRESS>

	CAME	AC4,[440740,,C]
	ERROR	T106,13,[440740,,C],AC4,,
	<EDIT INSTRUCTION DESTINATION POINTER CHANGED UNEXPECTEDLY>
	CAIE	AC5,4			;MAKE SURE DESTINATION POINTER DIDN'T CHANGE.
	ERROR	T106,13,[4],AC5,,
	<EDIT INSTRUCTION DESTINATION POINTER CHANGED UNEXPECTEDLY>

	MOVE	A,P3+777
	CAME	A,[440740,,C]		;MAKE SURE MARK POINTER GOT SET UP
	ERROR	T106,13,[440740,,C],A,,
	<EDIT INSTRUCTION DIDN'T STORE CORRECT MARK POINTER>

	MOVE	A,P4			;GET SECOND WORD OF MARK POINTER.
	CAIE	A,4			;MAKE SURE SECOND MARK POINTER WORD GOT STORED.
	ERROR	T106,13,[4],A,,
	<EDIT WITH BIT 12 IN D.P. DIDN'T STORE DOUBLE MARK POINTER>


;*TEST 107 - THE FOLLOWING TESTS TRY THE EXCHMD (EXCHANGE MARK AND DESTINATION
;*POINTER) OPERATOR TO MAKE SURE THAT WHEN ONLY ONE OF THOSE TWO POINTERS
;*IS A DOUBLE POINTER, THAT THE RIGHT WORDS GET SWAPPED.  ALSO, THEY
;*TRY PAGE FAULTS UPON REFERENCING MARK POINTERS, OR PARTS THEREOF, TO
;*VERIFY THAT THERE ISN'T A PROBLEM OF HALF AN EXCHANGE HAPPENING BEFORE
;*A PAGE FAULT, AND THEN AN UNEXCHANGE AFTERWARDS !!

T107:	SETUP
	JRST	EDSKIP			;SKIP OVER TEST DRIVER.

;*HERE'S THE TEST DRIVER FOR THE EXCHMD TESTS.

DRIVER:	PUSH	P,ESECT+16		;SAVE SECTION POINTER FOR SECOND WORD OF MARK POINTER.
	SETZM	ESECT+16		;CLEAR WORD SO REFERENCE TO SECOND WORD CAUSES FAULT.
	CONO	PAG,@EPWD		;TELL HARDWARE WE'VE CHANGED THE PAGE MAP.
	MOVEI	AC,DRIV2		;RETURN ADDR IF GOT MUUO
	MOVEM	AC,UUOSPC		;SET UP SPECIAL PC
	MOVSI	AC,10			;POINT EDIT AT THE "EXCHMD".
	XMOVEI	B,DRIV1			;LOAD UP RETURN ADDRESS FOR PAGE FAULT HANDLER.
	MOVEM	B,PFHSPC
	SETOM	PFF			;ALLOW A PAGE FAULT.
	XMOVEI	B,HOMDRV		;LOAD UP RETURN ADDRESS FOR EDIT ROUTINE.
	XJMP	13002001		;GO START THE EDIT.

DRIV1:	POP	P,ESECT+16		;REMOVE THE FAULT CONDITION DURING EDIT.
	CONO	PAG,@EPWD		;TELL HARDWARE.
	JRST	PFHRET			;LET THE EDIT COMPLETE.

HOMDRV:	SKIPE	PFF			;MAKE SURE THE PAGE FAULT HAPPENED.
	ERROR	T107,13,0,0,,
	<NO PAGE FAULT HAPPENED DURING THE EDIT INSTRUCTION>

DRIV2:	SKIPE	PFF			;IF A UUO WAS OK FINISH UP
	POP	P,ESECT+16		;FIX STACK FOR WHEN PAGE FAULT DOESN'T HAPPEN.
	POPJ	P,			;RETURN TO CALLING PROGRAM.

EDSKIP:	MOVE	A,[BYTE(9)EXCHMD,STOP]
	MOVEM	A,P2			;STORE PATTERN STRING
	MOVE	AC3,[15,,777777]	;MARK POINTER.
	MOVE	AC4,[1B12+3]		;FIRST OF TWO-WORD DESTINATION POINTER.
	MOVSI	AC5,2			;SECOND WORD.
	MOVE	A,[3,,2]
	MOVEM	A,P3+777		;WE'LL EXCHANGE IT WITH A SINGLE WORD MARK POINTER.
	SOS	ALLOW1			;ALLOW ONE UUO
	PUSHJ	P,DRIVER		;RUN THE TEST.
	SKIPE	ALLOW1
	ERROR	T107,13,0,0,,
	<EXCHMD DSTP LONG MARK SHORT DID NOT UUO>

;	CAME AC4,[3,,2]		;MAKE SURE OLD MARK POINTER GOT LOADED AS DEST.POINTER.
;	ERROR	T107,13,[3,,2],AC4,,
 <EXCHMD FAILED>

;	MOVE A,P3+777		;PICK UP OLD DESTINATION POINTER.
;	CAME A,[1B12+3]		;MAKE SURE FIRST WORD GOT STORED.
;	ERROR	T107,13,[1B12+3],A,,
 <EXCHMD FAILED>

;	MOVE A,P4		;CHECK SECOND WORD.
;	CAME A,[2,,0]
;	ERROR	T107,13,[2,,0],A,,
 <EXCHMD FAILED>

	MOVE	AC4,[1,,2]		;NOW WE'LL TRY A SINGLE WORD DESTINATION POINTER.
	SETOM	P3+777			;AND A DOUBLE WORD MARK POINTER.
	MOVE	A,[3,,4]
	MOVEM	A,P4			;SECOND WORD OF MARK POINTER.
	SETOM	ALLOW1			;ALLOW ONE UUO
	PUSHJ	P,DRIVER		;RUN THE TEST.
	SKIPE	ALLOW1
	ERROR	T107,13,0,0,,
	<EXCHMD MARK LONG DSTP SHORT DID NOT UUO>

;	MOVE A,P3+777		;PICK UP MARK POINTER THAT SHOULD HAVE BEEN STORED.
;	CAME A,[1,,2]
;	ERROR	T107,13,[1,,2],A,,
 <EXCHMD FAILED>

;	AOSN AC4		;MAKE SURE DESTINATION POINTER IS NOW -1.
;	CAME AC5,[3,,4]		;AND SECOND WORD SHOULD BE CORRECT TOO.
;	ERROR	T107,13,[3,,4],AC5,,
 <EXCHMD FAILED>

	MOVE	AC4,[1B12+2]		;NOW TRY BOTH POINTERS BEING TWO WORDS.
	MOVE	AC5,[3,,4]
	MOVE	A,[1B12+5]
	MOVE	B,[6,,7]
	MOVEM	A,P3+777
	MOVEM	B,P4
	PUSHJ	P,DRIVER
	CAMN	AC4,[1B12+5]
	CAME	AC5,[6,,7]
	ERROR	T107,13,[6,,7],AC5,,
	<EXCHMD FAILED>

	MOVE	A,P3+777
	MOVE	B,P4			;PICK UP MARK POINTER AS WRITTEN BY EDIT
	CAME	A,[1B12+2]
	ERROR	T107,13,[1B12+2],A,,
	<EXCHMD FAILED>
	CAME	B,[3,,4]
	ERROR	T107,13,[3,,4],B,,
	<EXCHMD FAILED>


;*TEST 110 - THE FOLLOWING TEST DOES A PXCT OF AN EXTEND INSTRUCTION.
;*THIS TEST ALSO MAKES SURE THAT CARRIES IN SECOND LONG BYTE POINTER
;*WORD ARE SUPPRESSED FROM BIT 6 INTO BIT 5.

T110:	SETUP
	UPAGMP	(P1,1,777)		;WE'LL DO DECIMAL TO BINARY WITH THE
	UPAGMP	(P2,2,0)		;DECIMAL DIGITS FLOWING FROM SECTION 1 TO 2.
	PAGMAP	(P3,4,7)		;PAGE USED FOR SOURCE EFFECTIVE ADDRESS CALCULATION
	PAGMAP	(P4,7,7)
	MOVE	B,[SIXBIT /314159/]	;THE NUMBER TO BE CONVERTED.
	MOVEI	A,0
	LSHC	A,22			;GET 314 IN A AND 159 IN B.
	MOVEM	A,P1+777		;FIRST THREE DIGITS IN LOCATION 1777777
	MOVEM	B,P2			;LAST THREE IN 2000000
	MOVSI	AC1,220640		;FIRST WORD OF DOUBLE WORD BYTE POINTER.
	MOVE	AC2,[1B1+-1_-6+<C>B5]	;@-1(C)
	MOVEI	AC0,6			;THERE ARE 6 DIGITS IN THE NUMBER.
	DMOVE	AC3,[3,,4]		;INITIAL BINARY DATA THAT INST. SHOULD CLEAR AT STARTUP.
	DMOVE	A,[EXP 1777777,2000000]	;EFFECTIVE ADDRESSES OF SOURCE DATA.
	DMOVEM	A,P3
	MOVE	C,[4,,7001]		;SOURCE EFFECTIVE ADDRESS USES C AS INDEX REGISTER
	MOVE	A,[EXTEND AC,A]		;INSTRUCTION TO BE PXCTED.
	MOVEM	A,P4+677
	MOVE	A,[PXCT 2,7677]		;INSTRUCTION TO BE TESTED.
	MOVEM	A,P4+700
	MOVE	A,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO THE RANCH..
	MOVEM	A,P4+702
	MOVE	A,[CVTDBO -'0']		;INSTRUCTION TO BE PXCTED.
	XMOVEI	B,HOMILU		;ADDRESS OF THE "RANCH"!
	SETZM	P4+701			;THIS 0 SHOULD GET SKIPPED BY SUCCESSFUL EXTEND INSTRUCTION
	XJRSTF	[EXP PCUBIT,7007700]	;RUN THE TEST.
HOMILU:	CAIE	AC3,0			;MAKE SURE HIGH ORDER ANSWER IS 0.
	ERROR	T110,13,[0],AC3,,
	<PXCTED DECIMAL TO BINARY INSTRUCTION GENERATED THE WRONG ANSWER>
	CAME	AC4,[^D314159]		;MAKE SURE CORRECT NUMBER GOT GENERATED.
	ERROR	T110,13,[^D314159],AC4,,
	<PXCTED DECIMAL TO BINARY INSTRUCTION GENERATED THE WRONG ANSWER>

	CAME	AC1,[220640,,]		;THE FIRST BYTE POINTER WORD SHOULDN'T HAVE CHANGED.
	ERROR	T110,13,[220640],AC1,,
	<PXCTED DECIMAL TO BINARY INSTRUCTION UPDATED THE SOURCE POINTER INCORRECTLY>
	CAME	AC2,[1B1+<C>B5]		;THE SECOND WORD SHOULD POINT TO SECTION 2 NOW.
	ERROR	T110,13,[1B1+<C>B5],AC2,,
	<PXCTED DECIMAL TO BINARY INSTRUCTION UPDATED THE SOURCE POINTER INCORRECTLY>

	CAME	AC0,[1B0]		;MAKE SURE THE LENGTH COUNTED DOWN TO 0.
	ERROR	T110,13,[1B0],AC0,,
	<PXCTED DECIMAL TO BINARY INSTRUCTION DIDN'T EXHAUST THE DIGIT COUNT>


;*TEST 111 - HERE'S A TEST OF MOVSLJ INSTRUCTION, WITH THE DESTINATION STRING
;*BEING WRITTEN TO PREVIOUS CONTEXT WITH PXCT.

T111:	SETUP
	PAGMAP	(P1,24,2)		;PAGE FOR SOURCE STRING.
	UPAGMP	(P2,7,7)		;PAGE FOR DESTINATION STRING.
	MOVE	A,[ASCII /LOVER/]	;STRING TO BE MOVED.
	MOVEM	A,P1+3
	PAGMAP	(P3,1,0)		;PAGE FOR TEST PROGRAM.
	MOVSI	T1,(MOVSLJ)		;INSTRUCTION BEING PXCTED.
	MOVE	T2,[EXTEND AC,T1]	;INSTRUCTION FOR INVOKING MOVSLJ.
	MOVE	A,[PXCT 1,T2]		;INSTRUCTION BEING TESTED.
	MOVEM	A,P3+40			;STORE TEST INSTRUCTION.
	SETZM	P3+41			;MUUO WILL HANDLE NON-SKIP ERROR.
	MOVE	A,[JRST @B]		;INSTRUCTION FOR GETTING BACK TO MAIN PROGRAM.
	MOVEM	A,P3+42
	MOVEI	AC,6
	MOVEI	AC3,6			;STRING LENGTHS.
	MOVE	AC1,[440740,,3]		;FIRST OF DOUBLE WORD SOURCE POINTER; RIGHT HALF IGNORED.
	MOVE	AC2,[24,,2003]		;POINTER TO SORCE STRING.
	MOVSI	AC4,440740		;DESTINATION POINTER IS ALSO DOUBLE WORD.
	MOVE	AC5,[1B0+7010]		;SECTION # WILL BE SENT BY PCS.
	SETZM	P2+10			;START WITH 0 IN DESTINATION AREA.
	DATAI	PAG,A			;READ CURRENT PCS.
	MOVEI	B,7			;CHANGE IT TO 7.
	DPB	B,[220500,,A]
	DATAO	PAG,A			;TELL HARDWARE ABOUT THE CHANGE.
	XMOVEI	B,HOMSH			;LOAD UP RETURN ADDRESS.
	XJRSTF	[EXP PCUBIT!7,1000040]	;TURN ON PCU ANDJUMP TO TEST PROGRAM.
HOMSH:	MOVE	A,P2+10			;READ STRING THAT WAS TO GET WRITTEN.
	CAME	A,[ASCII /LOVER/]
	ERROR	T111,13,[ASCII /LOVER/],A,,
	<PXCT 1,MOVSLJ FAILED>


;*TEST 112 - THE FOLLOWING TESTS MAKE SURE THAT MUUOS WORK PROPERLY, AND CAUSE
;*VARIOUS DATA TO GET STORED CORRECTLY.

T112:	SETUP
	UPAGMP	(P1,7,10)		;NON-0 SECTION PAGE FOR MUUO PROGRAM.
	SETZM	MCODE
	SETZM	MOLDPC
	SETZM	MADDR			;CLEAR OUT MUUO INFO WORDS.
	PREV	(X,12)			;TURN OFF PCU BIT AND SET PCS = 12
	MOVE	AC,[1B0+2]		;EFFECTIVE ADDRESS OF MUUO WILL BE AC 2
	MOVE	A,[44B8+4B12+@AC]	;OPCODE IS 44, AC FIELD IS 4, E IS 1,,2.
	MOVEM	A,P1+27			;STORE MUUO TO BE EXECUTED.
	DATAI	PAG,A			;GET PREVIOUS AC BLOCK #.
	MOVEI	B,5			;WE WANT TO SET IT TO 5.
	DPB	B,[300300,,A]		;SET PREVIOUS AC BLOCK #
	MOVEI	B,12			;WANT TO SET PCS FOR MUUO TO STORE IN PROCESS CONTEXT WORD.
	DPB	B,[220500,,A]
	DATAO	PAG,A			;TO 5.
	XMOVEI	B,HOMMUO		;LOAD UP RETURN ADDRESS.
	MOVEM	B,UUOSPC		;SET UP RETURN ADDRESS FOR MUUO.
	SETZM	MINFO			;START WITH 0 IN WORD MICROCODE IS SUPPOSED TO FILL.
	SETOM	ALLOW1			;ALLOW ONE MUUO.
	XJRSTF	[EXP 750140B17,7010027]	;ENTER USER MODE AND RUN TEST.
HOMMUO:	PUSH	P,MCODE			;SAVE DATA AS SET UP BY UCODE BECAUSE OF MUUO.
	PUSH	P,MOLDPC		;THIS MUST BE DONE BECAUSE MUUO USED TO
	PUSH	P,MADDR			;GET US BACK INTO EXEC MODE
	PUSH	P,MINFO			;WILL CLOBBER THIS DATA BEFORE WE'VE VERIFIED IT !
	JSP	A,.+1			;SAVE PC FLAGS TOO.
	GOEXEC				;NOW RETURN TO EXEC MODE.
	LDB	B,[220500,,MINFO]	;GET PCS AS SET UP BY MUUO.
	CAIE	B,7			;MAKE SURE IT'S THE SECTION IN WHICH MUUO WAS EXECUTED.
	ERROR	T112,13,[7],B,,
	<MUUO DIDN'T SET UP PCS CORRECTLY>

	POP	P,AC
	POP	P,AC1
	POP	P,AC2
	POP	P,AC3			;RETRIEVE MUUO DATA.
	HLRZ	A,A			;GET PC FLAGS AS SET BY MUUO
	CAIE	A,(PCUBIT)		;PREVIOUS CONTEXT USER BIT ONLY SHOULD BE ON.
	ERROR	T112,13,0,A,,
	<MUUO DIDN'T SET UP PCU BIT IN PC FLAGS>

	CAME	AC3,[750140B17+44B26+4B30]	;CHECK STORED PC FLAGS,OPCODE,AC FIELD.
	ERROR	T112,13,[750140B17+44B26+4B30],AC3,,
	<MUUO IN NON-0 SECTION STORED WRONG INFO IN UPT+424>

	CAME	AC2,[7010030]
	ERROR	T112,13,[7010030],AC2,,
	<MUUO IN NON-0 SECTION STORED THE WRONG PC>

	CAME	AC1,[1,,2]		;MAKE SURE IT'S SECTION INDEPENDENT AC POINTER.
	ERROR	T112,13,[1,,2],AC1,,
	<MUUO STORED INCORRECT EFFECTIVE ADDRESS>

	CAME	AC,[6B2+<OURACS>B8+5B11+12B17+UPTPN]
	ERROR	T112,13,[6B2+<OURACS>B8+5B11+12B17+UPTPN],AC,,
	<MUUO DIDN'T SET UP PROCESS CONTEXT WORD CORRECTLY>


;*TEST 113 - HERE'S THE TEST FOR LUUO'S.
;*THIS ONE DOES AN LUUO IN EXEC MODE.

T113:	SETUP
	PAGMAP	(P1,14,4)		;PAGE FOR OUR LUUO.
	MOVE	A,[3B8+4B12+@4000]	;LUUO TO BE EXECUTED.
	MOVEM	A,P1+666		;PUT IT IN LOCATION 14004666
	MOVE	A,[<C>B5+-3_6_-6]	;MOVE A,[-3(C)]	LONG STYLE
	MOVEM	A,P1			;EFFECTIVE ADDRESS CALCULATION OF LUUO USES THIS WORD.
	MOVE	C,[4,,20]		;E WILL BE 4,,15 FOR THIS LUUO.
	XMOVEI	B,HOMLUO		;LOAD UP RETURN ADDRESS
	MOVEM	B,ALOHA			;FOR LUUO HANDLER ADDRESS.
	MOVEI	A,UUOCOD		;GET ADDRESS OF FOUR WORD LUUO INFORMATION BLOCK.
	MOVEM	A,UUOPTR		;PUT IT WHERE MICROCODE EXPECTS IT.
	SETZM	ULPTR			;CLEAR THE USER MODE LUUP POINTER.
	SETZM	UUOCOD			;CLEAR WORD WHICH WILL CONTAIN UUO OPCODE.
	SETZM	UUOPC			;AND THE ONE TO CONTAIN THE PC.
	SETZM	UUOE			;AND THE ONE FOR THE EFFECTIVE ADDRESS
	XJRSTF	[EXP 740140B17,14004666]	;JUMP TO THE LUUO !
HOMLUO:	DMOVE	A,UUOCOD		;PICK UP TWO WORDS THAT SHOULD HAVE GOTTEN SET UP.
	CAME	A,[740140B17+3B26+4B30]
	ERROR	T113,13,[740140B17+3B26+4B30],A,,
	<LUUO STORED THE WRONG DATA>
	CAME	B,[14004667]		;MAKE SURE CORRECT PC GOT STORED.
	ERROR	T113,13,[14004667],B,,
	<LUUO STORED THE WRONG DATA>

	MOVE	A,UUOE			;PICK UP STORED LUUO EFFECTIVE ADDRESS.
	CAME	A,[4,,15]		;SKIP IF CORRECT EFFECTIVE ADDRESS GOT STORED.
	ERROR	T113,13,[4,,15],A,,
	<LUUO CAUSED THE WRONG EFFECTIVE ADDRESS TO GET STORED>

	JSP	A,.+1			;CHECK PC FLAGS.
	CAME	A,[740140B17+.]
	ERROR	T113,13,[740140B17+.],A,,
	<LUUO CLOBBERED PC FLAGS>


;*TEST 116 - NOW WE'LL TRY AN LUUO IN USER MODE.

T116:	SETUP
	UPAGMP	(P1,14,4)		;PAGE FOR OUR LUUO.
	MOVE	A,[3B8+4B12+@4000]	;LUUO TO BE EXECUTED.
	MOVEM	A,P1+666		;PUT IT IN LOCATION 14004666
	MOVE	A,[-3&<<C>B5>]		;MOVE A,[-3(C)]	LONG STYLE
	MOVEM	A,P1			;EFFECTIVE ADDRESS CALCULATION OF LUUO USES THI WORD.
	MOVE	C,[4,,20]		;E WILL BE 4,,20 FOR THIS LUUO.
	XMOVEI	B,HOMLUU		;LOAD UP RETURN ADDRESS
	MOVEM	B,ALOHA			;FOR LUUO HANDLER ADDRESS.
	MOVEI	A,UUOCOD		;GET ADDRESS OF FOUR WORD LUUO INFORMATION BLOCK.
	MOVEM	A,ULPTR			;PUT IT WHERE MICROCODE EXPECTS IT.
	SETZM	UUOPTR			;CLEAR THE EXEC MODE UUO POINTER.
	SETZM	UUOCOD			;CLEAR WORD WHICH WILL CONTAIN UUO OPCODE.
	SETZM	UUOPC			;AND THE ONE TO CONTAIN THE PC.
	SETZM	UUOE			;AND THE ONE FOR THE EFFECTIVE ADDRESS
	XJRSTF	[EXP USRBIT,14004666]	;JUMP TO THE LUUO(AND TURN ON USER MODE) !
HOMLUU:	GOEXEC				;RETURN TO EXEC MODE.
	DMOVE	A,UUOCOD		;PICK UP TWO WORDS THAT SHOULD HAVE GOTTEN SET UP.
	CAME	A,[USRBIT+3B26+4B30]
	ERROR	T116,13,[USRBIT+3B26+4B30],A,,
	<LUUO STORED THE WRONG DATA>
	CAME	B,[14004667]		;MAKE SURE CORRECT PC GOT STORED.
	ERROR	T116,13,[14004667],B,,
	<LUUO STORED THE WRONG DATA>

	MOVE	A,UUOE			;PICK UP STORED LUUO EFFECTIVE ADDRESS.
	CAME	A,[4,,20]		;SKIP IF CORRECT EFFECTIVE ADDRESS GOT STORED.
	ERROR	T116,13,[4,,20],A,,
	<LUUO CAUSED THE WRONG EFFECTIVE ADDRESS TO GET STORED>

	POPJ	P,			;END OF TESTS.
