SUBTTL	PROGRAM CONTROL SECTION
								SALL
; **********************************************************************
;*START - INITIALIZATION ROUTINE
; **********************************************************************

START:	MOVEI	START		;GET ADDRESS OF CURRENT PROGRAM SECTION
	MOVEM	TESTPC		;STORE IT

	PGMINT			;INITIALIZE PROGRAM

	SETZM	MIC202#
	SKIPE	USER		;USER MODE ?
	JRST	STARTA		;YES, CAN'T DO UCODE CHECK THEN

	BLKI	APR,0		;GET KL10 CPU ID INFO
	MOVSS			;SEPARATE MICROCODE VERSION NUMBER
	ANDI	777
	CAIL	202		;VERSION 202 OR LATER ?
	SETOM	MIC202		;YES, SET FLAG
	CAIL	230		;IF 230 OR GREATER
	SETZM	MIC202		;UCODE FIX 202 REMOVED

; **********************************************************************
;*STARTA - PROGRAM PASS CONTROL SECTION
; **********************************************************************

STARTA:	GO	MUUOHS		;SET UP PROGRAM'S OWN MUUO HANDLER
	SETZM	OFFSET

	MOVEI	1		;INITIALIZE STRING LENGTH
	MOVEM	RLEN#
	SETZM	INCSKP#		;CLEAR SKIP RETURN FLAG

	SWITCH
	MOVEI	AC1,^D10
	TLNN	RELIAB		;RELIABILITY MODE?
	MOVEI	AC1,1		;NO - FAST CYCLE MODE
	MOVEM	AC1,RPEAT#

	JRST	TRAPT1		;START TESTING

SUBTTL	MUUO TRAP TESTING

; **********************************************************************
;*TEST 1 -- EXTENDED OPERATOR EXECUTION TRAP TEST
;*
;*	THIS TEST EXECUTES ALL EXTENDED OPERATORS IN THE 
;*	EXTENDED INSTRUCTION SET AS INSTRUCTIONS.
;*	FOR EXAMPLE, 004 (EDIT) IS EXECUTED AS AN INSTRUCTION OPCODE.
;*	EACH ATTEMPTED EXECUTION SHOULD CAUSE AN LUUO.
;*	IF IT DOES NOT AN ERROR PRINTOUT OCCURS.
; **********************************************************************
									SALL
T=	SIXBTZ	<EXTENDED OPERATOR EXECUTION TRAP TEST>

TRAPT1:	MOVEI	.		;GET TEST ADDRESS
	MOVEM	TESTPC		;STORE IT
	MOVE	REPT,RPEAT	;GET LOOP COUNTER

TRAP1:	HRLZ	AC6,OPTAB-1	;AC6/-TABLE LENGTH,,0
	HRRI	AC6,OPTAB	;AC6/-TABLE LENGTH,,TABLE ADDRESS

TRAP1A:	MOVE	41		;SAVE SUBROUTINE PKG.TRAP ROUTINE ADDR
	MOVEM	SVLUUO#

	MOVE	[PUSHJ 17,LUUOH] ;GET ADDRESS OF LUUO HANDLER
	MOVEM	41		;SETUP FOR UUO INTERCEPTION

	SETOM	GOTRAP#		;INDICATE THAT TRAP IS EXPECTED
	MOVE	(AC6)		;RETRIEVE OPCODE FROM TABLE
	SETZM	EXLAB		;CLEAR INSTRUCTION WORD
	DPB	[POINT 9,EXLAB,8] ;INSERT IN NEXT LOCATION TO BE EXECUTED

; **************************************************
EXLAB:	BLOCK	1		;WORD THAT HOLDS THE INSTRUCTION
	JFCL			;IN CASE INSTRUCTION DOESN'T TRAP
; **************************************************

	MOVE	SVLUUO		;RESTORE SUBROU. PKG.TRAP ROUTINE SETUP
	MOVEM	41

	SKIPE	GOTRAP		;IF GOTRAP=0 THEN INSTRUCTION TRAPPED
	ERROR	(TRAP1A,13,EXLAB,0,
^CORRECT=INSTRUCTION,
ILLEGAL INSTRUCTION EXECUTION FAILED TO CAUSE LUUO)
	AOBJN	1,TRAP1A	;GET THE NEXT OPCODE FROM THE TABLE

	REPTLP	TRAP1
	JRST	TRAPT2

; **********************************************************************
;*TEST 2 -- ILLEGAL EXTENDED OPERATOR TRAP TEST
;*
;*	THE MICROCODE PERFORMS A RANGE CHECK ON THE EXTENDED
;*	OPERATOR CODE IN E0. (KS ONLY - SINCE THE KS10 IS A SINGLE
;*	SECTION MACHINE AND DOES NOT SUPPORT EXTENDED ADDRESSING,
;*	BITS 9-12 OF E0 SHOULD CAUSE A TRAP IF NOT EQUAL TO ZERO.)
;*	IF AN MUUO DOES NOT OCCUR WHEN ILLEGAL VALUES ARE SPECIFIED
;*	FOR THE E0 WORD AN ERROR PRINTOUT OCCURS.
; **********************************************************************
									SALL
T=	SIXBTZ	<ILLEGAL EXTENDED OPERATOR TRAP TEST>

TRAPT2:	MOVEI	.		;GET TEST ADDRESS
	MOVEM	TESTPC		;STORE IT
	MOVE	REPT,RPEAT

TRAP2:	SETZB	AC,AC+1		;CLEAR AC'S TO PROTECT THE PROGRAM IN 
	SETZB	AC+3,AC+4	;CASE NO MUUO'S OCCUR

	HRLZI	5,37000		;THIS VALUE IS AN OUT OF RANGE OPERATOR
	MOVEM	5,E0		;SETUP E0 FIELD

	SETOM	GOTRAP		;INDICATE THAT WE EXPECT AN MUUO

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE EXTENDED INSTRUCTION
	JFCL			;IN CASE THE INSTRUCTION DOESN'T TRAP
; **************************************************

	SKIPE	GOTRAP
	ERROR	(TRAP2,13,E0,0,
^CORRECT=INSTRUCTION,
OUT OF RANGE OPERATOR FAILED TO TRAP)

	SKIPE	SM10		;KS-10?
	JRST	TRAP2A		;YES - SO CHECK BITS 9-12 IN E0 WORD

	REPTLP	TRAP2
	JRST	TRAPT3		;KL DOES NOT CHECK BITS 9-12

TRAP2A:	SETZB	AC,AC+1		;CLEAR AC'S TO PROTECT THE PROGRAM IN 
	SETZB	AC+3,AC+4	;CASE NO MUUO'S OCCUR

	HRLZI	5,1740		;SET BITS IN E0 9,12 (SHOULD BE BLANK)
	MOVEM	5,E0		;SETUP EO FIELD

	SETOM	GOTRAP		;INDICATE THAT WE EXPECT AN MUUO

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE EXTENDED INSTRUCTION
	JFCL			;IN CASE THE INSTRUCTION DOESN'T TRAP
; **************************************************

	SKIPE	GOTRAP		;GOTRAP=0 MEANS TRAP OCCURED
	ERROR	(TRAP2A,13,E0,0,
^CORRECT=INSTRUCTION,
ILLEGAL AC FIELD BITS 9-12 FAILED TO TRAP)

	REPTLP	TRAP2
	JRST	TRAPT3

; **********************************************************************
;*TEST 3 -- ILLEGAL AC FIELD TRAP TEST
;*
;*	THIS TEST EXECUTES THE EXTENDED INSTRUCTIONS
;*	WITH ILLEGAL OR UNUSED AC FIELDS SET (BIT BY BIT). THE
;*	EXECUTION OF THESE INSTRUCTIONS SHOULD CAUSE A TRAP. IF IT
;*	DOES NOT OCCUR AN ERROR PRINTOUT OCCURS. (KS ONLY - SINCE THE
;*	KS-10 IS A SINGLE SECTION MACHINE BITS 6-17 OF THE PATTERN
;*	POINTER FIELD (AC) FOR THE EDIT INSTRUCTION SHOULD TRAP
;*	IF NOT EQUAL TO ZERO.)
;*
;*	NOTE: THERE ARE SOME AC FIELDS THAT ARE LISTED AS UNUSED OR 0
;*	      IN THE INSTRUCTION SPEC THAT ARE NOT TRAPPED AS
;*	      MUUOS BY THE MICROCODE (I.E. ILLEGAL SETTING OF THOSE
;*	      BITS HAS NO EFFECT ON THE INSTRUCTION).
; **********************************************************************
									SALL
T=	SIXBTZ	<ILLEGAL AC FIELD TRAP TEST>

TRAPT3:	MOVEI	.		;GET TEST ADDRESS
	MOVEM	TESTPC		;STORE IT
	MOVE	REPT,RPEAT

TRAP3:	LDB	SP,[POINT 0,SOURCE,0] ;SETUP ACS TO PROTECT PROGRAM
	LDB	DP,[POINT 0,DESTIN,0] ;IN CASE THE INSTR DOESN'T TRAP

	SETZB	AC,AC+3		;CLEAR STRING LENGTH ACS

; **************************************************
;*TEST COMPARE INSTRUCTION STRING LENGTH AC BITS 0,9
; **************************************************

	HRLZI	AC6,-6		;AC6/- #CMP INSTR,,0
	HRRI	AC6,OPTAB	;AC6/- #CMP INSTR,,OPCODE TABLE ADDRESS

CMPTRP:	MOVEI	AC4,^D9		;SETUP LOOP COUNTER
	MOVSI	AC5,(1B8)	;ILLEGAL BIT MASK

CMPT1:	SETZM	E0		;CLEAR THE E0 FIELD FOR TEST

	MOVE	AC7,(AC6)		;GET COMPARE INSTRUCTION OPCODE
	DPB	AC7,E0OP	;PUT INSTRUCTION OPCODE IN E0
	OR	AC,AC5		;ILLEGAL SOURCE LENGTH BITS TO SLEN

	SETOM	GOTRAP		;INDICATE THE MUUO IS EXPECTED

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION
	JFCL			;IN CASE THE INSTRUCTION DOESN'T TRAP
; **************************************************

	SKIPE	GOTRAP		;GOTRAP=0 MEANS TRAP OCCURED
	ERROR	(CMPTRP,13,AC,0,
^CORRECT=SOURCE LENGTH,
ILLEGAL SOURCE LENGTH IN COMPARE INSTR DIDN'T CAUSE TRAP)

	SETZM	AC		;RESET AC
	OR	AC+3,AC5	;ILLEGAL DESTINATION LENGTH BITS TO DLEN
	SETOM	GOTRAP		;INDICATE THAT TRAP EXPECTED

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION
	JFCL			;IN CASE THE INSTRUCTION DOESN'T TRAP
; **************************************************

	SKIPE	GOTRAP		;GOTRAP=0 MEANS TRAP OCCURED
	ERROR	(CMPTRP,13,AC+3,0,
^CORRECT=DESTINATION LENGTH,
ILLEGAL DESTIN LENGTH IN COMPARE INSTR DIDN'T CAUSE TRAP)

	SETZM	AC+3		;RESET DESTINATION LENGTH AC
	LSH	AC5,1		;SETUP FOR NEXT BIT IN FIELD

	SOJG	AC4,CMPT1	;DO NEXT BIT IN FIELD

	AOBJN	AC6,CMPTRP	;GO TRY NEXT OPCODE

; **************************************************
;*TEST THE MOVE STRING DESTINATION LENGTH BITS 0,9
; **************************************************

MVSTRP:	HRLI	AC6,-4		;AC6/- #MVS INSTR,,CURRENT TABLE ADDRESS

MVS1:	MOVSI	AC5,(1B8)	;SETUP ILLEGAL BIT MASK
	MOVEI	AC4,^D9		;NUMBER OF BIT POSTIONS TO CHECK

MVS2:	MOVE	AC7,(AC6)		;GET OPERATOR OPCODE
	SETZM	E0		;CLEAR OPERATOR FIELD
	DPB	AC7,E0OP	;PUT OPCODE IN BITS 0,9
	OR	AC+3,AC5	;SETUP ILLEGAL DESTINATION LENGTH

	SETOM	GOTRAP		;INDICATE THAT MUUO IS EXPECTED

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION
	JFCL			;IN CASE THE TRAP DOESN'T OCCUR
; **************************************************

	SKIPE	GOTRAP		;GOTRAP=0 MEANS TRAP OCCURED
	ERROR	(MVS2,13,AC+3,0,
^CORRECT=DESTINATION LENGTH,
ILLEGAL DLEN IN MOVE STRING INSTR DIDN'T CAUSE TRAP)

	LSH	AC5,1		;SETUP NEXT BIT

	SOJG	AC4,MVS2	;TEST NEXT BIT

	AOBJN	AC6,MVS1	;GO TRY NEXT OPCODE

	SKIPE	SM10		;KS-10?
	JRST	EDITRP		;YES

	ERLP2	TRAPT3		;KL-10 SO END OF THIS TEST
	REPTLP	TRAP3

	JRST	CMPMOD		;GO TO NEXT TEST

; **************************************************
;*TEST EDIT INSTRUCTION ILLEGAL PATTERN POINTER FIELD (KS-10 ONLY)
; **************************************************

EDITRP:	MOVEI	AC7,4		;GET EDIT INSTRUCTION OPCODE
	SETZM	E0		;CLEAR E0 FIELD
	DPB	AC7,E0OP	;PUT OPCODE IN BITS 0,9
	MOVSI	AC5,(1B17)	;ILLEGAL FIELD MASK
	MOVEI	AC4,^D12	;NUMBER OF ILLEGAL BITS TO CHECK

EDIT1:	SETZM	AC		;CLEAR THE PATTERN POINTER REGISTER
	OR	AC,AC5		;SET THE ILLEGAL BIT
	SETOM	GOTRAP		;INDICATE THAT MUUO EXPECTED

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION
	JFCL			;IN CASE THE INSTRUCTION DOESN'T TRAP
; **************************************************

	SKIPE	GOTRAP		;GOTRAP=0 MEANS TRAP OCCURED
	ERROR	(EDIT1,13,AC,0,
^CORRECT=PATTERN POINTER,
ILLEGAL PATTERN POINTER FIELD IN EDIT INSTR DIDN'T CAUSE TRAP)

	LSH	AC5,1		;SETUP NEXT BIT FIELD

	SOJG	AC4,EDIT1	;JUMP IF MORE FIELDS TO CHECK

	REPTLP	TRAP3
	JRST	CMPMOD

SUBTTL	EXTEND INSTRUCTION CASE TESTING

; **********************************************************************
;*EXTEND INSTRUCTION CASE TESTING -- GENERAL INFORMATION
;*
;*	THERE ARE 5 EXTEND INSTRUCTION CASE TEST MODULES (MODULE NAMES
;*	SUFFIXED BY "MOD"). EDIT INSTR TESTING CONSISTS OF 9 SUBMODULES.
;*
;*	EACH MODULE EXECUTES INSTRUCTIONS WITH PARAMETERS DERIVED FROM
;*	A CASE TABLE (I.E. VARYING STRING LENGTHS, BYTE SIZES, FILLER
;*	VALUES, PATTERNS, OFFSETS, ETC.).
;*
;*	WHEN THE INSTRUCTION HAS BEEN SET UP, AN INSTRUCTION SIMULATOR
;*	(ROUTINE NAMES SUFFIXED BY "SIM") IS CALLED. THE REAL INSTRUCTION
;*	IS THEN EXECUTED.
;*
;*	THE RESULTS OF THE INSTRUCTION AND THE SIMULATOR ARE COMPARED IN
;*	AN INSTRUCTION COMPARATOR ROUTINE (ROUTINE NAME SUFFIXED BY "COM").
;*
;*	EACH INSTRUCTION IS RUN FOR EVERY CASE SPECIFIED AND THEN
;*	THE NEXT INSTRUCTION IS RUN FOR EVERY CASE, ETC.
;*
;*	ON ERROR AN ERROR MESSAGE IS PRINTED AND THE PROGRAM PROCEEDS
;*	WITH THE NEXT CASE IN SEQUENCE.  THE FAILURE INFORMATION IS PRINTED
;*	BY AN INSTRUCTION PRINTING ROUTINE (ROUTINE NAME SUFFIXED BY "PNT").
;*
;*	THE INITIAL AC BLOCK IS STORED IN ORIGSV.
;*	THE RESULTS OF THE  SIMULATOR ARE STORED IN RESSV.
;*	AC6 HOLDS THE INSTRUCTION OPCODE INFORMATION.
;*	AC7 HOLDS THE CASE TABLE INFORMATION.
;*	 THE INTEGRITY OF THESE ACS IS PRESERVED THROUGHOUT MODULE EXECUTION. 
; **********************************************************************

; **********************************************************************
;*TEST 4 -- COMPARE STRING INSTRUCTION TEST
;*
;*	THIS TEST EXERCISES THE EXTENDED INSTRUCTION SET'S
;*	SIX COMPARE INSTRUCTIONS.
; **********************************************************************
									SALL
T=	SIXBTZ	<COMPARE STRING INSTRUCTION TEST>

CMPMOD:	MOVEI	.		;GET TEST ADDRESS
	MOVEM	TESTPC		;STORE IT
	MOVE	REPT,RPEAT

CMPM:	HRLZI	AC6,-6		;AC6/- #CMP INSTR,,0
	HRRI	AC6,CMPTAB	;AC6/- #CMP INSTR,,OPCODE TABLE ADDR

CMP1:	HRLZ	AC7,CMPCAS-1	;AC7/- #CMP CASES,,0
	HRRI	AC7,CMPCAS	;AC7/- #CMP CASES,,CASE TABLE ADDRESS

CMP2:	MOVE	(AC6)		;RETRIEVE CURRENT COMPARE OPCODE
	DPB	E0OP		;PUT IN INSTRUCTION OPCODE FIELD

	GO	RANLEN		;STRING LENGTH TO AC0
	MOVEM	SLEN		;STORE IN STRING LENGTHS
	MOVEM	DLEN

	SETZM	SKPWD1#		;CLEAR SKIP INDICATOR WORDS
	SETZM	SKPWD2#
	SETZM	E0+1		;CLEAR FILLER WORDS
	SETZM	E0+2

; **************************************************
;DETERMINE THE DESIRED PATTERN TYPE
; **************************************************

	MOVE	1,(AC7)		;RETRIEVE CURRENT CASE PARAMETER WORD
	TLNN	1,(ALTPT)	;ALTERNATING 1'S AND 0'S PATTERN?
	JRST	CHKB1		;NO

	MOVE	APAT		;YES - GET THE PATTERN
	JRST	CMPLEN		;CONTINUE

CHKB1:	TLNN	1,(ONESPT)	;ONE'S PATTERN?
	JRST	CHKC1		;NO

	MOVE	BPAT		;YES - GET THE PATTERN
	JRST 	CMPLEN		;CONTINUE

CHKC1:	TLNN	1,(ONEPT)	;ONE PATTERN (0,,1)?
	JRST	CMPER1		;NO - CASE TABLE ERROR

	MOVE	CPAT		;YES - GET THE PATTERN
	JRST	CMPLEN		;CONTINUE

CMPER1:	PMSG	<^CMPXX PATTERN NOT SELECTED - ABORTING CURRENT CASE>
	AOBJN	AC7,CMP2
	JRST	MOVMOD		;NO CASES LEFT - GO TO NEXT TEST

CMPLEN:	MOVEM	PATTERN#	;STORE CHOSEN PATTERN

	TLNE	1,(EQLEN)	;STRINGS OF EQUAL LENGTH?
	JRST	CMPBYT		;YES - THIS IS ALREADY SET UP

; **************************************************
;STRINGS WILL BE OF UNEQUAL LENGTH SO NOW PICK A FILLER
; **************************************************

CMPFIL:	TLNN	1,(EQFIL)	;FILLER = PATTERN?
	JRST	CMPF1		;NO

	MOVE	PATTERN		;YES - PATTERN TO AC0
	JRST	CMPL

CMPF1:	TLNN	1,(LFILL)	;ZERO FILLER?
	JRST	CMPF2		;NO
	MOVE	DPAT		;YES - ZERO PATTERN TO AC0
	JRST	CMPL

CMPF2:	TLNN	1,(GFILL)	;ONE'S FILLER
	JRST	CMPER2		;NO - CASE TABLE ERROR
	MOVE	BPAT		;YES - ONE'S PATTERN TO AC0
	JRST	CMPL

CMPER2:	PMSG	<^ABORTING CURRENT CASE - FILLER PATTERN NOT SPECIFIED>
	AOBJN	AC7,CMP2
	JRST	MOVMOD		;NO CASES LEFT - GO TO NEXT TEST

; **************************************************
;NOW PUT THE FILLER (STORED IN AC0) INTO THE AC BLOCK
;THE FILLER GOES INTO E0+1 IF SLEN < DLEN AND INTO E0+2 IF SLEN > DLEN
; **************************************************

CMPL:	TLNN	1,(SZERO)	;SOURCE LENGTH = 0?
	JRST	CMPL1		;NO
	SETZM	SLEN		;YES - ZERO SOURCE LENGTH
	MOVEM	E0+1		;SETUP FILLER
	JRST	CMPBYT

CMPL1:	TLNN	1,(DZERO)	;DESTIN LENGTH = 0?
	JRST	CMPL2		;NO
	SETZM	DLEN		;YES - ZERO DESTINATION LENGTH
	MOVEM	E0+2		;SETUP FILLER
	JRST	CMPBYT

CMPL2:	TLNN	1,(DSZER)	;BOTH SOURCE AND DESTIN LENGTH'S ZERO?
	JRST	CMPL3		;NO - BOTH MUST BE HAVE LENGTHS > 0
	SETZB	SLEN,DLEN	;YES - SET BOTH TRING LENGTHS TO ZERO
	JRST	CMPBYT

CMPL3:	TLNN	1,(SLONG)	;DESTIN SHORTER THAN SOURCE?
	JRST	E0FIL1		;NO
	LSH	DLEN,-1		;DLEN=1/2 SLEN
	MOVEM	E0+2		;SETUP FILLER
	JRST	CMPBYT

E0FIL1:	LSH	SLEN,-1		;SLEN=1/2 DLEN
	MOVEM	E0+1		;SETUP FILLER
	JRST	CMPBYT

; **************************************************
;DETERMINE STRING BYTE SIZES
; **************************************************

CMPBYT:	TLNE	1,(S44)		;FULL WORD SOURCE BYTES?
	JRST	CMPB1		;YES

	MOVEI	AC0,37
	ANDM	AC0,E0+1
	MOVE	SP,[POINT 5,SOURCE]
	SKIPA

CMPB1:	MOVE	SP,[POINT 36,SOURCE] ;SETUP SOURCE BYTE POINTER

	TLNE	1,(D44)		;FULL WORD DESTIN BYTE SIZE?
	JRST	CMPB2		;YES

	MOVEI	AC0,37
	ANDM	AC0,E0+2
	MOVE	DP,[POINT 5,DESTIN]
	SKIPA

CMPB2:	MOVE	DP,[POINT 36,DESTIN] ;SETUP DESTINATION POINTER

; **************************************************
;PROCEED TO SET UP THE STRINGS
; **************************************************

CMPSTR:	PUT	AC6		;NEED THAT SPARE AC!

	MOVE	SLEN1,SLEN	;COPY OF SOURCE STRING LENGTH
	MOVE	SP1,SP		;COPY OF SOURCE STRING POINTER
	MOVE	AC0,PATTERN	;COPY OF PATTERN
	SETZM	AC4		;CLEAR REWRITE BYTE WORD

	IDPB	AC0,SP1		;WRITE THE FIRST BYTE TO THE STRING

CSET1:	SOSG	SLEN1
	JRST	CSET2		;JUMP IF LAST BYTE WRITTEN

	IDPB	AC0,SP1		;WRITE A BYTE
	JRST	CSET1		;GO FOR THE NEXT ONE

CSET2:	TLNE	1,(ALS)		;ALTER THE LAST SOURCE BYTE?
	DPB	AC4,SP1		;YES - ZERO IT

	MOVE	DLEN1,DLEN	;COPY OF DESTINAION STRING LENGTH
	MOVE	DP1,DP		;COPY OF DESTIN STRING BYTE POINTER
	IDPB	AC0,DP1		;WRITE THE FIRST BYTE

CSET3:	SOSG	DLEN1
	JRST	CSET4		;JUMP IF LAST BYTE WRITTEN

	IDPB	AC0,DP1		;WRITE A BYTE
	JRST	CSET3		;GO FOR THE NEXT ONE

CSET4:	TLNE	1,(ALD)		;ALTER THE LAST DESTIN BYTE
	DPB	AC4,DP1		;YES - ZERO IT

; **************************************************
;SAVE THE ORIGINAL AC BLOCK FOR ERROR PRINTOUT IF NECESSARY
; **************************************************

	MOVE	AC0,[AC,,ORIGSV]
	BLT	AC0,ORIGSV+4

	GET	AC6		;RESTORE AC6

; **************************************************
	GO 	CMPSIM		;CALL THE COMPARE INSTR SIMULATOR
	SETOM	SKPWD1		;SIMULATED SKIP RETURN
; **************************************************

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION FOR REAL
	SETOM	SKPWD2		;REAL SKIP RETURN
; **************************************************

	GO	CMPCOM		;COMPARE THE RESULTS
	ERROR	CMP2,13,0,0,,,CMPPNT

	AOBJN	AC7,CMP2	;EXECUTE THE NEXT CASE
	AOBJN	AC6,CMP1	;EXECUTE THE CASES WITH THE NEXT OPCODE

	REPTLP	CMPM
	JRST	MOVMOD		;FINISHED - GO TO NEXT TEST

; **********************************************************************
;*TEST 5 -- MOVE STRING INSTRUCTION TEST
;*
;*	THIS TEST EXERCISES THE EXTENDED INSTRUCTION SET'S
;*	FOUR MOVE STRING INSTRUCTIONS.
; **********************************************************************
									SALL
T=	SIXBTZ	<MOVE STRING INSTRUCTION TEST>

MOVMOD:	MOVEI	.
	MOVEM	TESTPC
	MOVE	REPT,RPEAT

MOVM:	HRLZI	AC6,-4		;AC6/- #MOV INSTR,,0
	HRRI	AC6,MOVTAB	;AC6/- #MOV INSTR,,OPCODE TABLE ADDR

MOV1:	HRLZ	AC7,MOVCAS-1	;AC7/- #MOV CASES,,0
	HRRI	AC7,MOVCAS	;AC7/- #MOV CASES,,CASE TABLE ADDRESS

MOV2:	GO	CLRSTR		;CLEAR THE SOURCE AND DESTINATION AREAS

	MOVE	(AC6)		;RETRIEVE CURRENT MOVE OPCODE
	DPB	E0OP		;PUT IN INSTRUCTION OPCODE FIELD

	SETZM	TRANFG
	CAIN	AC0,015		;MOVST INSTRUCTION?
	SETOM	TRANFG#		;YES - SET TRANSLATE FLAG

	GO	RANLEN		;STRING LENGTH TO AC0
	MOVEM	SLEN		;STORE IN STRING LENGTHS
	MOVEM	DLEN

	SETZM	SKPWD1#		;CLEAR SKIP INDICATOR WORDS
	SETZM	SKPWD2#
	SETZM	E0+1		;CLEAR FILLER WORD

	SKIPN	TRANFG		;MOVST?
	JRST	CHKA2		;NO

	MOVEI	AC0,1		;TRANSLATE PATTERN ALWAYS STARTS WITH 1
	JRST	MOVLEN		;AND INCREMENTS

; **************************************************
;DETERMINE THE DESIRED PATTERN TYPE
; **************************************************

CHKA2:	MOVE	1,(AC7)		;RETRIEVE CURRENT CASE PARAMETER WORD
	TLNN	1,(ALTPT)	;ALTERNATING 1'S AND 0'S PATTERN?
	JRST	CHKB2		;NO
	MOVE	APAT		;YES - GET THE PATTERN
	JRST	MOVLEN		;CONTINUE

CHKB2:	TLNN	1,(ONESPT)	;ONE'S PATTERN?
	JRST	CHKC2		;NO
	MOVE	BPAT		;YES - GET THE PATTERN
	JRST 	MOVLEN		;CONTINUE

CHKC2:	TLNN	1,(ONEPT)	;ONE PATTERN (0,,1)?
	JRST	MOVER1		;NO - ERROR
	MOVE	CPAT		;YES - GET THE PATTERN
	JRST	MOVLEN		;CONTINUE

MOVER1:	PMSG	<^MOVXX PATTERN NOT SELECTED - ABORTING CURRENT CASE>
	AOBJN	AC7,MOV2
	JRST	CDBMOD		;NO CASES LEFT - GO TO NEXT TEST

MOVLEN:	MOVEM	PATTERN		;STORE CHOSEN PATTERN
	TLNE	1,(EQLEN)	;STRINGS OF EQUAL LENGTH?
	JRST	MOVBYT		;YES - ALREADY SET UP

; **************************************************
;FIND OUT IF A FILLER IS NEEDED AND DETERMINE STRING LENGTHS
; **************************************************

MOVL:	TLNN	1,(DZERO)	;DESTINATION LENGTH = ZERO?
	JRST	MOVL1		;NO
	SETZM	DLEN		;YES - ZERO DESTINATION LENGTH
	JRST	MOVBYT

MOVL1:	TLNN	1,(DSZER)	;BOTH DESTIN AND SOURCE LENGTHS = 0?
	JRST	MOVL2		;NO
	SETZB	SLEN,DLEN	;YES - ZERO THEM BOTH
	JRST	MOVBYT

MOVL2:	TLNN	1,(SLONG)	;SOURCE STRING LONGER THAN DESTIN?
	JRST	MOVL3		;NO
	LSH	DLEN,-1		;YES - DLEN = 1/2 SLEN
	JRST	MOVBYT

MOVL3:	TLNN	1,(SZERO)	;SOURCE STRING LENGTH = 0?
	JRST	MOVL4		;NO
	SETZM	SLEN		;YES - ZERO SOURCE STRING LENGTH
	JRST	MOVFIL		;GET A FILLER

MOVL4:	LSH	SLEN,-1		;SLEN = 1/2 DLEN

; **************************************************
;NOW PICK A FILLER
; **************************************************

MOVFIL:	TLNN	1,(EQFIL)	;FILLER = PATTERN?
	JRST	MOVF1		;NO
	MOVE	PATTERN		;YES - PATTERN TO AC0
	JRST	MOVF3

MOVF1:	TLNN	1,(LFILL)	;ZERO FILLER?
	JRST	MOVF2		;NO
	MOVE	DPAT		;YES - ZERO PATTERN TO AC0
	JRST	MOVF3

MOVF2:	TLNN	1,(GFILL)	;ONE'S FILLER
	JRST	MOVER2		;NO - ERROR
	MOVE	BPAT		;YES - ONE'S PATTERN TO AC0
	JRST	MOVF3

MOVER2:	PMSG	<^ABORTING CURRENT CASE - FILLER PATTERN NOT SPECIFIED>
	AOBJN	AC7,MOV2
	JRST	CDBMOD		;NO CASES LEFT - GO TO NEXT TEST

MOVF3:	MOVEM	E0+1		;STORE THE FILLER

; **************************************************
;DETERMINE STRING BYTE SIZES
; **************************************************

MOVBYT:	SKIPE	TRANFG		;5 BIT BYTES IF MOVST
	JRST	MOVB1

	TLNN	1,(S44)		;FULL WORD SOURCE BYTES?
	JRST	MOVB1		;NO
	MOVE	SP,[POINT 36,SOURCE] ;SETUP SOURCE BYTE POINTER
	SKIPA

MOVB1:	MOVE	SP,[POINT 5,SOURCE]
	SKIPE	TRANFG
	JRST	MOVB2

	TLNN	1,(D44)		;FULL WORD DESTIN BYTE SIZE?
	JRST	MOVB2		;NO
	MOVE	DP,[POINT 36,DESTIN] ;SETUP DESTINATION POINTER
	SKIPA

MOVB2:	MOVE	DP,[POINT 5,DESTIN]

; **************************************************
;PROCEED TO SET UP THE STRINGS
; **************************************************

MOVSTR:	PUT	AC6		;NEED THAT SPARE AC!

	MOVE	SLEN1,SLEN	;COPY OF SOURCE STRING LENGTH
	MOVE	SP1,SP		;COPY OF SOURCE STRING POINTER
	MOVE	AC0,PATTERN	;COPY OF PATTERN

	IDPB	AC0,SP1		;WRITE THE FIRST BYTE TO THE STRING

SET1:	SOSG	SLEN1
	JRST	MOVOP		;JUMP IF LAST BYTE WRITTEN

	SKIPE	TRANFG
	ADDI	AC0,1		;INCREMENT THE PATTERN IF MOVST

	IDPB	AC0,SP1		;WRITE A BYTE
	JRST	SET1		;GO FOR THE NEXT ONE

MOVOP:	MOVE	AC0,(AC6)	;RETRIEVE THE CURRENT OPCODE
	CAIE	AC0,015		;MOVST INSTRUCTION?
	JRST	MOVOFF		;NO - SEE IF MOVSO

	MOVEI	AC0,E1		;GET ADDRESS OF TRANSLATION TABLE
	HRRM	AC0,E0		;STORE IT IN THE E0 FIELD

; **************************************************
;SET THE FLAGS IN AC FOR MOVST INSTRUCTION
; **************************************************

	TRNE	1,(SFL)		;SET THE S FLAG?
	OR	SLEN,BIT0	;YES

	TRNE	1,(NFL)		;SET THE N FLAG?
	OR	SLEN,BIT1	;YES

	TRNE	1,(MFL)		;SET THE M FLAG?
	OR	SLEN,BIT2	;YES

; **************************************************
;SET THE CODE BITS IN THE TRANSLATION TABLE
; **************************************************

	SETZM	AC0		;TEMP LOC FOR CONTROL BITS

	TRNE	1,(C1)		;SETUP THE SECOND HALFWORD
	OR	BIT18

	TRNE	1,(C2)
	OR	BIT19

	TRNE	1,(C3)
	OR	BIT20

	TRNE	1,(C4)		;SETUP THE THIRD HALFWORD
	OR	BIT0

	TRNE	1,(C5)
	OR	BIT1

	TRNE	1,(C6)
	OR	BIT2

	GO	SETRAN		;YES - SET UP THE TRANSLATION TABLE
	JRST	GOMOV

MOVOFF:	CAIE	AC0,014		;IS IT MOVSO?
	JRST	GOMOV		;NO - DON'T NEED AN OFFSET

	MOVE	AC4,AC1		;COPY OF PARAM WORD
	ANDI	AC4,OFF		;SAVE ONLY OFFSET INDEX
	LSH	AC4,OFFSH	;SHIFT INTO POSITION
	MOVE	AC4,OFFTAB(AC4)	;GET THE OFFSET WORD
	HRRM	AC4,E0		;PUT AS EFFECTIVE ADDRESS IN E0 WORD

; **************************************************
;SAVE THE ORIGINAL AC BLOCK FOR ERROR PRINTOUT IF NECESSARY
; **************************************************

GOMOV:	MOVE	AC0,[AC,,ORIGSV]
	BLT	AC0,ORIGSV+4

	GET	AC6		;RESTORE AC6

; **************************************************
	GO 	MOVSIM		;CALL THE COMPARE INSTR SIMULATOR
	SETOM	SKPWD1		;SIMULATED SKIP RETURN
; **************************************************

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION FOR REAL
	SETOM	SKPWD2		;REAL SKIP RETURN
; **************************************************

	GO	MOVCOM		;COMPARE THE RESULTS
	ERROR	MOV2,13,0,0,,,MOVPNT

	AOBJN	AC7,MOV2	;EXECUTE THE NEXT CASE
	AOBJN	AC6,MOV1	;EXECUTE THE CASES WITH THE NEXT OPCODE

	REPTLP	MOVM
	JRST	CDBMOD

; **************************************************
;SETRAN -- ROUTINE TO SETUP TRANSLATE TABLE FOR MOVST
;	TAKE TWO SPECIAL HALFWORDS IN AC0 , RETURNS +1 ALWAYS
; **************************************************

SETRAN:	PUT	AC1
	PUT	AC2

	HRLZI	AC1,-10		;AC1/-TABLE LENGTH,,0
	HRRI	AC1,E1		;AC1/-TABLE LENGTH,,TABLE ADDRESS
	MOVE	AC2,[1,,1]

SETLOC:	MOVEM	AC2,(AC1)
	AOBJN	AC1,SETLOC

	IORM	AC0,E1		;PUT 1ST HALFWORD IN FIRST LOCATION
	HRRM	AC2		;PATCH UP OTHER HALF OF WORD
	IORM	AC0,(AC1)
	HRLM	AC2

	GET	AC2
	GET	AC1
	RTN

; **********************************************************************
;*TEST 6 -- CONVERT DECIMAL TO BINARY INSTRUCTION TEST
;*
;*	THIS TEST EXERCISES THE EXTENDED INSTRUCTION SET'S
;*	TWO CVTDBX INSTRUCTIONS.
; **********************************************************************
									SALL
T=	SIXBTZ	<CONVERT DECIMAL TO BINARY INSTRUCTION TEST>

CDBMOD:	MOVEI	.
	MOVEM	TESTPC
	MOVE	REPT,RPEAT

CDBM:	HRLZI	AC6,-2		;AC6/- #CVTDBX INSTR,,0
	HRRI	AC6,CDBTAB	;AC6/- #CVTDBX INSTR,,OPCODE TABLE ADDR

CDB1:	HRLZ	AC7,CDBCAS-1	;AC7/- #CVTDBX CASES,,0
	HRRI	AC7,CDBCAS	;AC7/- #CVTDBX CASES,,CASE TABLE ADDR

CDB2:	SETZM	E0
	MOVE	(AC6)		;RETRIEVE CURRENT CVTDBX OPCODE
	DPB	AC0,E0OP	;DEPOSIT OPCODE IN FIELD

	SETZM	TRANFG		;CLEAR TRANSLATE FLAG
	CAIN	AC0,011		;CVTDBT INSTRUCTION?
	SETOM	TRANFG		;YES - SET THE FLAG

	SETZM	SKPWD1		;CLEAR THE SKIP INDICATOR FLAGS
	SETZM	SKPWD2

; **************************************************
;DETERMINE THE SOURCE STRING LENGTH
; **************************************************

	MOVE	AC1,(7)		;RETRIEVE CASE PARAMETER WORD
	MOVE	AC5,AC1
	ANDI	AC5,STRL	;SAVE ONLY INDEX TO LENGTH TABLE
	LSH	AC5,STRLSH	;SHIFT INTO POSITION
	MOVE	SLEN,LTAB(AC5)	;STRING LENGTH TO AC5

; **************************************************
;DETERMINE THE INITIAL BINARY DATA
; **************************************************

	TRNE	AC1,(B0)	;SET BIT 0?
	MOVE	AC5,BIT0	;YES

	TRNN	AC1,(B0)	;SET BIT 35?
	MOVE	AC5,BIT18	;YES

	TRNE	AC1,(HW)	;PUT INTO HIGH BINARY DATA?
	MOVEM	AC5,DBH		;YES

	TRNN	AC1,(HW)	;PUT INTO LOW BINARY DATA?
	MOVEM	AC5,DBL		;YES

; **************************************************
;DETERMINE THE STRING BYTE SIZE
; **************************************************

	TLNE	1,(S44)		;FULL WORD BYTE SIZE?
	MOVE	SP,[POINT 36,SOURCE] ;NO - 8 BIT BYTES

	TLNN	1,(S44)		;FULL WORD BYTE SIZE?
	MOVE	SP,[POINT 8,SOURCE] ;YES

; **************************************************
;DETERMINE THE S,N,M FLAGS
; **************************************************

	TRNE	1,(SFL)		;SET THE S FLAG?
	OR	SLEN,BIT0	;YES

	TRNE	1,(NFL)		;SET THE N FLAG?
	OR	SLEN,BIT1	;YES

	TRNE	1,(MFL)		;SET THE M FLAG?
	OR	SLEN,BIT2	;YES

; **************************************************
;DETERMINE THE DATA TO BE CONVERTED
; **************************************************

	MOVE	AC5,AC1		;COPY OF PARAMETER WORD
	ANDI	AC5,DATA	;SAVE ONLY DATA TABLE INDEX BITS
	LSH	AC5,DATASH	;SHIFT INTO POSITION
	MOVE	AC5,DATTAB(AC5)	;AC5 HAS ADDRESS OF DATA STRING

; **************************************************
;SETUP THE SOURCE STRING
; **************************************************

	MOVE	AC3,SLEN	;COPY OF THE STRING LENGTH
	AND	AC3,[777,,777777] ;SAVE JUST THE LENGTH

	MOVE	AC4,SP		;COPY OF SOURCE BYTE POINTER

CDB3:	SOJL	AC3,CDB3A

	SETZM	AC0
	ILDB	AC0,AC5		;GET A SOURCE BYTE

	SKIPE	TRANFG
	ANDI	AC0,17		;IF CVTDBT MAKE THE BYTE A TABLE INDEX

	IDPB	AC0,AC4		;PUT IT INTO THE SOURCE STRING
	JRST	CDB3

; **************************************************
;PICK AN OFFSET IF CVTDBO INSTRUCTION
; **************************************************

CDB3A:	SKIPE	TRANFG		;INSTRUCTION CVTDBO?
	JRST	CDB4		;NO

	MOVE	AC5,AC1		;COPY OF PARAM WORD 
	ANDI	AC5,OFF
	LSH	AC5,OFFSH	;SHIFT INTO POSITION
	MOVE	AC5,OFFTAB(AC5)	;GET DESIRED OFFSET
	HRRM	AC5,E0		;STORE THE OFFSET
	JRST	GOCDB		;ALL SET UP - EXECUTE THE INSTR

CDB4:	MOVEI	E1
	HRRM	E0		;STORE THE ADDR OF THE TRANSLATE TABLE

	SETZM	AC0		;TEMP LOC FOR CONTROL BITS
	TRNE	1,(C1)		;SETUP THE SPECIAL HALFWORD
	OR	BIT18

	TRNE	1,(C2)
	OR	BIT19

	TRNE	1,(C3)
	OR	BIT20

	TRNE	1,(C4)		
	OR	BIT0

	TRNE	1,(C5)
	OR	BIT1

	TRNE	1,(C6)
	OR	BIT2

	GO	CDBTRN		;GO SETUP THE TRANSLATION TABLE

GOCDB:	MOVE	AC0,[AC,,ORIGSV] ;SAVE CONTENTS OF AC BLOCK
	BLT	AC0,ORIGSV+4

; **************************************************
	GO	CDBSIM		;CALL THE CVTDBX SIMULATOR
	SETOM	SKPWD1
; **************************************************

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE REAL INSTRUCTION
	SETOM	SKPWD2
; **************************************************

	GO	CDBCOM		;COMPARE THE RESULTS
	ERROR	CDB2,13,0,0,,,CDBPNT

	AOBJN	AC7,CDB2	;EXECUTE THE NEXT CASE
	AOBJN	AC6,CDB1	;EXECUTE CASES WITH NEXT OPCODE

	REPTLP	CDBM
	JRST	CBDMOD

; **************************************************
;CDBTRN -- ROUTINE TO SET UP THE TRANSLATE TABLE FOR CVTDBT
; **************************************************

CDBTRN:	PUT	AC1
	PUT	AC2

	HRLZI	AC1,-10		;AC1/-TABLE LENGTH,,0
	HRRI	AC1,E1		;AC1/-TABLE LENGTH,,TABLE ADDRESS
	MOVE	AC2,[400000,,400001]

SETLC1:	MOVEM	AC2,(AC1)
	AOBJN	AC2,.+1		;GET THE NEXT ENTRY
	AOBJN	AC2,.+1
	AOBJN	AC1,SETLC1

	HLLM	E1		;PUT 1ST HALFWORD IN 1ST LOCATION
	HRLM	AC1-1		;PUT 2ND HALFWORD IN LAST LOCATION

	GET	AC2
	GET	AC1
	RTN

; **********************************************************************
;*TEST 7 -- CONVERT BINARY TO DECIMAL INSTRUCTION TEST
;*
;*	THIS TEST EXERCISES THE EXTENDED INSTRUCTION SET'S
;*	TWO CVTBDX INSTRUCTIONS.
; **********************************************************************
									SALL
T=	SIXBTZ	<CONVERT BINARY TO DECIMAL INSTRUCTION TEST>

CBDMOD:	MOVEI	.
	MOVEM	TESTPC
	MOVE	REPT,RPEAT

CBDM:	HRLZI	AC6,-2		;AC6/- #CVTBDX INSTR,,0
	HRRI	AC6,CBDTAB	;AC6/- #CVTBDX INSTR,,OPCODE TABLE ADDR

CBD1:	HRLZ	AC7,CBDCAS-1	;AC7/- #CVTBDX CASES,,0
	HRRI	AC7,CBDCAS	;AC7/- #CVTBDX CASES,,CASE TABLE ADDR

CBD2:	GO	CLRSTR

	SETZM	E0
	MOVE	(AC6)		;RETRIEVE CURRENT CVTBDX OPCODE
	DPB	AC0,E0OP	;STORE THE OPCODE

	SETZM	TRANFG
	CAIN	AC0,013		;CVTBDT INSTR?
	SETOM	TRANFG		;YES

	SETZM	SKPWD1		;CLEAR THE SKIP INDICATOR WORDS
	SETZM	SKPWD2

; **************************************************
;DETERMINE THE DESTINATION STRING LENGTH
; **************************************************

	MOVE	AC1,(7)		;RETRIEVE THE PARAMETER WORD
	MOVE	AC5,AC1		;MAKE A COPY
	ANDI	AC5,STRL	;SAVE ONLY LENGTH INDEX
	LSH	AC5,STRLSH	;SHIFT INTO POSITION
	MOVE	DLEN,LTAB(AC5)	;STORE IT

; **************************************************
;DETERMINE THE STRING BYTE SIZE
; **************************************************

	TLNE	1,(S44)		;FULL WORD BYTE SIZE?
	MOVE	DP,[POINT 36,DESTIN] ;NO - 8 BIT BYTES
	TLNN	1,(S44)		;FULL WORD BYTE SIZE?
	MOVE	DP,[POINT 8,DESTIN] ;YES

; **************************************************
;DETERMINE THE S,N,M FLAGS
; **************************************************

	TRNE	1,(SFL)		;SET THE S FLAG?
	OR	DLEN,BIT0	;YES

	TRNE	1,(NFL)		;SET THE N FLAG?
	OR	DLEN,BIT1	;YES

	TRNE	1,(MFL)		;SET THE M FLAG?
	OR	DLEN,BIT2	;YES

; **************************************************
;DETERMINE THE DATA TO BE CONVERTED
; **************************************************

	MOVE	AC5,1		;COPY OF PARAMETER WORD
	ANDI	AC5,DATA	;SAVE ONLY DATA TABLE INDEX BITS
	LSH	AC5,DATASH	;SHIFT INTO POSITION
	DMOVE	BDH,@DATCBD(AC5) ;GET HIGH AND LOW DATA INTO THE AC'S

; **************************************************
;PICK AN OFFSET IF CVTBDO INSTRUCTION
; **************************************************

CBD3:	SKIPE	TRANFG		;INSTRUCTION CVTBDO?
	JRST	CBD4		;NO

	MOVE	AC5,AC1		;COPY OF PARAM WORD 
	ANDI	AC5,OFF		;JUST KEEP THE OFFSET BITS OF CASE WORD
	LSH	AC5,OFFSH	;SHIFT INTO POSITION
	MOVE	AC5,OFFTAB(AC5)	;GET DESIRED OFFSET
	HRRM	AC5,E0		;STORE THE OFFSET
	JRST	GOCBD		;ALL SET UP - EXECUTE THE INSTR

CBD4:	MOVEI	E1
	HRRM	E0		;STORE LOCATION OF TRANSLATE TABLE

	SETZM	AC0		;TEMP LOC FOR CONTROL BITS
	TRNE	1,(C1)		;SETUP THE TWO HALFWORDS
	OR	BIT18

	TRNE	1,(C2)
	OR	BIT19

	TRNE	1,(C3)
	OR	BIT20

	TRNE	1,(C4)
	OR	BIT0

	TRNE	1,(C5)
	OR	BIT1

	TRNE	1,(C6)
	OR	BIT2

	GO	CBDTRN		;GO SETUP THE TRANSLATION TABLE

GOCBD:	MOVE	AC0,[AC,,ORIGSV] ;SAVE CONTENTS OF AC BLOCK
	BLT	AC0,ORIGSV+4

; **************************************************
	GO	CBDSIM		;CALL THE CVTBDX SIMULATOR
	SETOM	SKPWD1
; **************************************************

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE REAL INSTRUCTION
	SETOM	SKPWD2
; **************************************************

	GO	CBDCOM		;COMPARE THE RESULTS
	ERROR	CBD2,13,0,0,,,CBDPNT

	AOBJN	AC7,CBD2	;EXECUTE THE NEXT CASE
	AOBJN	AC6,CBD1	;EXECUTE CASES WITH NEXT OPCODE

	REPTLP	CBDM
	JRST	EDMODM

; **********************************************************************
;*TEST 8 -- EDIT INSTRUCTION TEST
;*
;*	THE EDIT INSTRUCTION TEST CONSISTS OF A SERIES OF
;*	SUBMODULES EACH OF WHICH TESTS A SINGLE PATTERN BYTE TYPE.
;*
;*	EDMOD1 -- STOP (001) PATTERN BYTE TYPE TEST
;*	EDMOD2 -- EXCHMD (004) PATTERN BYTE TYPE TEST
;*	EDMOD3 -- SIGST (002) PATTERN BYTE TYPE TEST
;*	EDMOD4 -- FLDSEP (003) PATTERN BYTE TYPE TEST
;*	EDMOD5 -- MESSAG (1XX) PATTERN BYTE TYPE TEST
;*	EDMOD6 -- NOP (005) PATTERN BYTE TYPE TEST
;*	EDMOD7A -- SKPM (5XX) PATTERN BYTE TYPE TESTS
;*	EDMOD7B -- SKPN (6XX) PATTERN BYTE TYPE TESTS
;*	EDMOD7C -- SKPA (7XX) PATTERN BYTE TYPE TESTS
;*	EDMOD8 -- SELECT (001) PATTERN BYTE TYPE TEST
;*	EDMOD9 -- NON DEFINED PATTERN BYTE TYPE TEST
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT INSTRUCTION TEST>

EDMODM:	MOVE	REPT,RPEAT

; **********************************************************************
;*EDMOD1 -- STOP (001) PATTERN BYTE TYPE TEST
;*
;*	THE STOP PATTERN IS TESTED IN ALL FOUR POSITIONS OF
;*	THE PATTERN BYTE TABLE. IT WILL BE EXECUTED WITH ALL COMBINATIONS
;*	OF THE S,N AND M FLAGS. PATTERN TABLE LOCATIONS WITH THE EXCEPTION
;*	OF THE FIRST WORD WILL BE FILLED WITH SIGST.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - STOP (001) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD1,EDM1,EDMOD2,ED1WD,SIGWD,0)

; **********************************************************************
;*EDMOD2 -- EXCHMD (004) PATTERN BYTE TYPE TEST
;*
;*	THE EXCHMD PATTERN BYTE WILL BE TESTED IN FOUR SEQUENCES, THESE ARE:
;*		EXCHMD STOP,
;*		EXCHMD EXCHMD STOP,
;*		EXCHMD EXCHMD EXCHMD STOP,
;*		EXCHMD EXCHMD EXCHMD EXCHMD STOP.
;*
;*	THE MARK ADDRESS IN AC+3 WILL BE INITIALIZED TO [POINT 0,SOURCE]
;*	AND DP WILL BE EQUAL TO [POINT 36,DESTIN]. THE S,N, AND M FLAGS
;*	WILL BE VARIED TO INSURE THAT THEIR VALUES HAVE NO EFFECT ON THE
;*	OUTCOME OF THE INSTRUCTION. ALL BYTES IN THE PATTERN BYTE TABLE
;*	WILL BE SET TO STOP WITH THE EXCEPTION OF THE FIRST WORD OF THE TABLE.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - EXCHMD (004) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD2,EDM2,EDMOD3,ED2WD,STOPWD,1)

; **********************************************************************
;*EDMOD3 -- SIGST (002) PATTERN BYTE TYPE TEST
;*
;*	THERE ARE THREE MAIN EXECUTION PATHS TO BE TESTED:
;*	1. S=1
;*	2. S=0, E0+2=0
;*	3. S=0, E0+2 NOT =0
;*
;*	THE VALUES OF THE M AND N FLAGS ARE VARIED TO INSURE THAT THEIR
;*	VALUE HAS NO EFFECT ON THE OUTCOME OF THE INSTRUCTION. WITH THE
;*	EXCEPTION OF THE TEST PATTERN BYTES THE TABLE WILL BE FILLED
;*	WITH THE STOP OPERATOR.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - SIGST (002) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD3,EDM3,EDMOD4,ED3WD,STOPWD,2)

; **********************************************************************
;*EDMOD4 -- FLDSEP (003) PATTERN BYTE TYPE TEST
;*
;*	THE FLDSEP OPERATOR WILL BE TESTED WITH ALL COMBINATIONS
;*	OF THE S,N AND M FLAGS. THE REMAINING BYTES IN THE TABLE WILL BE
;*	FILLED WITH THE STOP OPERATOR. ALL BYTES IN THE PATTERN BYTE
;*	TABLE WILL BE FILLED WITH STOP EXCEPT FOR THE FIRST WORD.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - FLDSEP (003) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD4,EDM4,EDMOD5,ED4WD,STOPWD,3)

; **********************************************************************
;*EDMOD5 -- MESSAG (1XX) PATTERN BYTE TYPE TEST
;*
;*	THERE ARE THREE  EXECUTION PATHS THAT MUST BE TESTED:
;*	1. S=1
;*	2. S=0, E0+1=0
;*	3. S=0, E0+1 NOT =0
;*
;*	THE N AND M FLAGS WILL BE VARIED TO INSURE THAT THERE VALUE HAS
;*	NO EFFECT ON THE OUTCOME OF THE INSTRUCTION. ALL BYTES IN THE
;*	PATTERN TABLE WILL BE FILLED WITH THE STOP OPERATOR WITH THE
;*	EXCEPTION OF THE FIRST WORD. THEN ALL POSSIBLE MESSAGE
;*	CHARACTERS WILL BE INSERTED INTO THE DESTINATION STRING.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - MESSAG (1XX) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD5,EDM5,EDM5A,ED5WD,STOPWD,4)

; **********************************************************************
;*INSERT EVERY MESSAGE CHARACTER IN THE DESTINATION STRING
; **********************************************************************

EDM5A:	GO	CLRSTR		;CLEAR THE DESTINATION STRINGS

	MOVE	AC0,[MESSGS,,E0+1] ;SET UP THE 64 MESSAGE CHARACTERS
	BLT	AC0,E0+4

	MOVEI	AC0,37		;GET NEXT CODE
	HRRI	AC1,E0+5
	HRLI	AC1,-^D39

FILE0:	MOVEM	AC0,(AC1)	;PUT INTO E0 TABLE
	ADDI	AC0,1
	AOBJN	AC1,FILE0

PTMSET:	MOVEI	AC1,^D63	;SET UP THE PATTERN BYTE TABLE
	MOVE	AC2,PATPT	;GET BYTE POINTER

	MOVEI	AC0,100
PTM1:	IDPB	AC0,AC2		;PUT THE BYTE IN THE TABLE
	ADDI	AC0,1
	SOJG	AC1,PTM1

	MOVEI	AC0,STOP	;FINISH UP WITH STOP
	IDPB	AC0,AC2		;OVERWRITE THE LAST BYTE WITH A STOP

	MOVEI	AC7,MCASE	;GET SPECIAL CASE PARAMETER WORD
	GO	EDTSET		;INITIALIZE THE AC BLOCK

	MOVE	AC0,[AC,,ORIGSV]
	BLT	AC0,ORIGSV+4

; **************************************************
	GO	EDTSIM		;SIMULATE THE INSTRUCTION
	SETOM	SKPWD1
; **************************************************

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE REAL INSTRUCTION
	SETOM	SKPWD2
; **************************************************

	GO	EDTCOM		;COMPARE THE RESULTS
	ERROR	EDM5A,13,0,0,,,EDTPNT

	JRST	EDMOD6		;GO TO NEXT SUBMODULE TEST

; **********************************************************************
;*EDMOD6 -- NOP (005) PATTERN BYTE TYPE TEST
;*
;*	THE EDIT INSTRUCTION WILL BE EXECUTED WITH THE FOUR SEQUENCES:
;*		NOP STOP,
;*		NOP NOP STOP,
;*		NOP NOP NOP STOP,
;*		NOP NOP NOP NOP STOP.
;*
;*	THE REST OF THE PATTERN BYTE TABLE WILL BE FILLED 
;*	WITH THE STOP OPERATOR. THE S,N AND M FLAGS WILL BE VARIED TO
;*	INSURE THAT THEIR VALUE HAS NO EFFECT ON THE OUTCOME OF THE
;*	INSTRUCTION.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - NOP (005) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD6,EDM6,EDMD7A,ED6WD,STOPWD,5)

; **********************************************************************
;*EDMOD7A -- SKPM (5XX) PATTERN BYTE TYPE TESTS
;*
;*	THE EDIT INSTRUCTION WITH THIS BYTE PATTERN BYTES WILL BE TESTED WITH
;*	ALL COMBINATIONS OF THE S,N AND M FLAGS AND A VARIETY OF VALUES
;*	FOR THE XX COMPONENT OF THE INSTRUCTION. WITH THE EXCEPTION OF
;*	THE SKIP PATTERN BYTES THE TABLE WILL BE FILLED WITH THE STOP OPERATOR.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - SKPM (5XX) PATTERN BYTE TYPE TESTS>

	EDMOD(EDMD7A,EDM7A,EDMD7B,ED7AWD,STOPWD,6)

; **********************************************************************
;*EDMOD7B -- SKPN (6XX) PATTERN BYTE TYPE TESTS
;*
;*	THE EDIT INSTRUCTION WITH THIS BYTE PATTERN BYTES WILL BE TESTED WITH
;*	ALL COMBINATIONS OF THE S,N AND M FLAGS AND A VARIETY OF VALUES
;*	FOR THE XX COMPONENT OF THE INSTRUCTION. WITH THE EXCEPTION OF
;*	THE SKIP PATTERN BYTES THE TABLE WILL BE FILLED WITH THE STOP OPERATOR.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - SKPN (6XX) PATTERN BYTE TYPE TESTS>

	EDMOD(EDMD7B,EDM7B,EDMD7C,ED7BWD,STOPWD,7)

; **********************************************************************
;*EDMOD7C -- SKPA (7XX) PATTERN BYTE TYPE TESTS
;*
;*	THE EDIT INSTRUCTION WITH THIS BYTE PATTERN BYTES WILL BE TESTED WITH
;*	ALL COMBINATIONS OF THE S,N AND M FLAGS AND A VARIETY OF VALUES
;*	FOR THE XX COMPONENT OF THE INSTRUCTION. WITH THE EXCEPTION OF
;*	THE SKIP PATTERN BYTES THE TABLE WILL BE FILLED WITH THE STOP OPERATOR.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - SKPA (7XX) PATTERN BYTE TYPE TESTS>

	EDMOD(EDMD7C,EDM7C,EDMOD8,ED7CWD,STOPWD,^D8)

; **********************************************************************
;*EDMOD8 -- SELECT (001) PATTERN BYTE TYPE TEST
;*
;*	THIS INSTRUCTION WILL BE EXECUTED WITH VARIED VALUES
;*	FOR TOP (THE OPCODE PART OF THE TRANLATE FUNCTION) AND
;*	THE S,N AND M FLAGS.
;*
;*	COMBINATIONS OF THE FOLLOWING PARAMETERS WILL BE TESTED:
;*	1. S,N AND M FLAGS
;*	2. E0+1 = AND NOT =0
;*	3. E0+2 = AND NOT =0
;*	4. VARIED VALUES FOR TOP (THE OPCODE PART OF THE TRANSLATE TABLE.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - SELECT (001) PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD8,EDM8,EDMOD9,ED8WD,STOPWD,^D9)

; **********************************************************************
;*EDMOD9 -- NON DEFINED PATTERN BYTE TYPE TEST
;*
;*	THE EDIT INSTRUCTION WILL BE EXECUTED WITH UNDEFINED
;*	VALUES FOR THE PATTERN BYTES. THESE BYTES SHOULD BE INTERPRETED
;*	AS NOOPS (RESULTING IN INCREMENTATION OF THE PB#). THE SPECIFIC
;*	BYTES TESTED ARE 2XX,3XX,4XX,006.
; **********************************************************************
									SALL
T=	SIXBTZ	<EDIT - NON DEFINED PATTERN BYTE TYPE TEST>

	EDMOD(EDMOD9,EDM9,PFTST,ED9WD,STOPWD,^D10)

	REPTLP	EDMOD1

SUBTTL	PAGE FAIL TESTING
									SALL
T= SIXBTZ<PAGE FAIL TESTING>

; **********************************************************************
;*TEST 9 -- PAGE FAIL RECOVERY TEST
;*
;*	THIS TEST SETS UP THE PAGE FAILURES FOR EACH INSTRUCTION
;*	USING A PREDETERMINED AC BLOCK STORED IN MEMORY (PFBLKX).
;*
;*	WHERE APPLICABLE, PAGE FAILURES WILL BE CAUSED AT THE FIRST,
;*	MIDDLE, AND LAST BYTES OF THE SOURCE AND DESTINATION STRINGS,
;*	AND AT THE E0+1 (FILLER) BYTES.
;*
;*	THE PAGE FAILUES ARE CAUSED BY RELOCATING PAGE 400 TO PAGE 75.
;*	
;*	THE EXTEND INSTRUCTIONS ARE SET UP SO THAT THEY REFERENCE PAGE 401
;*	(WHICH DOES NOT EXIST).
;*
;*	A PAGE FAIL SHOULD OCCUR ON THE FIRST REFERENCE TO LOCATION 401000.
;*
;*	THE PAGE FAIL ROUTINE COMPARES THE INTERMEDIATE VALUES OF
;*	THE AC BLOCK TO THE CORRECT VERSION STORED IN MEMORY AND
;*	THE CONTENTS OF LOCATION 501 (SAVED FLAGS AND PC). IF THEY
;*	ARE NOT CORRECT AN ERROR PRINTOUT OCCURS.
;*
;*	THE INSTRUCTION IS CONTINUED BY RELOCATING BOTH PAGES 400 AND 401.
;*	PAGE 400 IS RELOCATED TO 75000 AND PAGE 401 IS RELOCATED TO 76000.
;*
;*	WHEN THE EXECUTION OF THE EXTEND INSTRUCTION IS FINISHED THE
;*	SIMULATOR FOR THAT PARTICULAR SET OF INSTRUCTIONS IS EXECUTED.
;*	(SINCE BOTH PAGES 400 AND 401 ARE NOW RELOCATED THE SIMULATOR
;*	CAN EXECUTE THE INSTRUCTION WITHOUT PAGE FAIL.)
;*
;*	THE FINAL RESULTS OF THE INSTRUCTION CONTAINED IN THE AC BLOCK
;*	ARE COMPARED TO THOSE OF THE SIMULATOR. IF NOT EQUAL AN ERROR
;*	PRINTOUT OCCURS.
; **********************************************************************

PFTST:	SKIPE	USER
	JRST	BEGEND		;NO PAGE FAIL TESTING IN USER MODE

	MOVE	REPT,RPEAT

	MOVEI	AC0,PFHAND	;SET UP ADDRESS OF PF HANDLER
	MOVEM	AC0,LPGFTR

; **********************************************************************
;*PAGE FAIL TESTING OF THE COMPARE INSTRUCTIONS
; **********************************************************************
									SALL
T=	SIXBTZ	<PAGE FAIL TESTING OF THE COMPARE INSTRUCTIONS>

	PFMAC (-6,-7,PFRES1,PFBLK1,CMP,SETRAN)

; **********************************************************************
;*PAGE FAIL TESTING OF MOVE STRING INSTRUCTIONS
; **********************************************************************
									SALL
T=	SIXBTZ	<PAGE FAIL TESTING OF MOVE STRING INSTRUCTIONS>

	PFMAC(-4,-7,PFRES1,PFBLK1,MOV,SETRAN)

; **********************************************************************
;*PAGE FAIL TESTING OF CVTDBX INSTRUCTIONS
; **********************************************************************
									SALL
T=	SIXBTZ	<PAGE FAIL TESTING OF CVTDBX INSTRUCTIONS>

	PFMAC(-2,-3,PFRES2,PFBLK2,CDB,CDBTN)

; **********************************************************************
;*PAGE FAIL TESTING OF CVTBDO INSTRUCTIONS
; **********************************************************************
									SALL
T=	SIXBTZ	<PAGE FAIL TESTING OF CVTBDO INSTRUCTIONS>

	PFMAC(-1,-2,PFRES3,PFBLK3,CBD,CBDTRN)

; **********************************************************************
;*PAGE FAIL TESTING OF THE EDIT INSTRUCTIONS
; **********************************************************************
									SALL
T=	SIXBTZ	<PAGE FAIL TESTING OF THE EDIT INSTRUCTIONS>

	PFMAC(-1,-6,PFRES4,PFBLK4,EDT,SETRAN)
	REPTLP	CMPST
	JRST	BEGEND		;END OF PROGRAM
SUBTTL	INSTRUCTION SIMULATORS

; **********************************************************************
;*INSTRUCTION SIMULATORS -- GENERAL INFORMATION
;*
;*	EACH INSTRUCTION SIMULATOR ROUTINE IS ENTERED WITH
;*	THE ORIGINAL AC BLOCK IN ORIGSV. THEY ARE COPIED INTO
;*	AC'S 10-14.
;*
;*	THE CURRENT OPCODE OF THE INSTRUCTION BEING TESTED
;*	IS CONTAINED IN THE E0 WORD (BITS 0,8).
;*
;*	FOR THE INSTRUCTIONS WHICH INVOLVE FORMING A DESTINATION STRING
;*	THE RESULT IS STORED IN AN AREA CALLED "SIMDES" INSTEAD OF
;*	"DESTIN" TO MAKE ERROR COMPARISON POSSIBLE.
;*
;*	THE FINAL AC BLOCK FOR THE INSTRUCTION IS STORED IN FIVE
;*	LOCATIONS AT RESSV BEFORE RETURN TO THE INSTRUCTION MODULE.
;*
;*	RETURN IS +1 ALWAYS.
;*
;*	CMPSIM -- ROUTINE TO SIMULATE THE COMPARE STRING INSTRUCTION
;*	MOVSIM -- ROUTINE TO SIMULATE THE MOVE STRING INSTRUCTIONS
;*	CDBSIM -- ROUTINE TO SIMULATE THE CVTDBO AND CVTDBT INSTRUCTIONS
;*	CBDSIM -- ROUTINE TO SIMULATE THE CVTBDX INSTRUCTIONS
;*	EDTSIM -- ROUTINE TO SIMULATE THE EDIT INSTRUCTION
; **********************************************************************

; **********************************************************************
;*CMPSIM -- ROUTINE TO SIMULATE THE COMPARE STRING INSTRUCTION
;*
;*	THE SKIP/NON-SKIP RETURN OF THE CMPXX SIMULATOR IS HANDLED
;*	USING 3 FLAGS AND A SKIP TABLE, SKPTAB.
;*
;*	WHEN STRING1 IS FOUND GREATER THAN, LESS THAN, AND/OR = TO
;*	STRING2, THE APPROPRIATE FLAG IS OR'ED WITH AC3.
;*
;*	SKPTAB IS INDEXED BY INSTRUCTION OPCODE AND BEFORE THE
;*	INSTRUCTION RETURNS, AC3 IS ANDED WITH THE CORRECT
;*	SKPTAB WORD.
;*
;*	IF THE RESULT IS NON-ZERO THE SKIP CONDITION FOR THE INSTR
;*	HAS BEEN SATISFIED AND THE RETURN POINTER IS INCREMENTED.
; **********************************************************************

CMPSIM:	GO	SVAC		;SAVE ACCUMULATORS

	LDB	OP1,E0OP	;COPY OF CURRENT OPCODE

	MOVE	AC0,[ORIGSV,,AC] ;RETRIEVE ORIGINAL AC BLOCK
	BLT	AC0,AC+4

	SETZM	AC3		;CLEAR SKIP TABLE COMPARE WORD

CMPS1:	SOSGE	SLEN
	SKIPA	AC7,E0+1	;IF SOURCE EXHAUSTED, GET FILLER
	ILDB	AC7,SP		;SOURCE REMAINS, GET BYTE

	SOSGE	DLEN		;DO THE SAME WITH DESTINATION STRING
	SKIPA	AC2,E0+2
	ILDB	AC2,DP

	JUMPGE	SLEN,CMPS2	;GO COMPARE BYTES
	JUMPL	DLEN,CMPDON	;BOTH STRING ARE EQUAL

CMPS2:	HLRZ	AC4,AC7		;GET THE LEFT HALF OF SOURCE AND DESTIN
	HLRZ	AC5,AC2

	CAMN	AC4,AC5		;COMPARE SOURCE AND DESTINATION BYTES
	JRST	CMPS3		;EQUAL - GET RIGHT HALF

	CAMG	AC4,AC5
	ORI	AC3,LF

	CAML	AC4,AC5
	ORI	AC3,GF		;SET SOURCE > DESTIN FLAG

	SKIPE	AC3
	JRST	CMPOUT

CMPS3:	HRRZ	AC4,AC7
	HRRZ	AC5,AC2

	CAMN	AC4,AC5
	JRST	CMPS1		;EQUAL - GET NEXT BYTES

	CAMG	AC4,AC5		;BYTES ARE NOT EQUAL
	ORI	AC3,LF		;SET SOURCE < DESTIN FLAG

	CAML	AC4,AC5
	ORI	AC3,GF		;SET SOURCE > DESTIN FLAG

	JRST CMPOUT		;NOW EXIT

CMPDON:	ORI	AC3,EF		;SET SOURCE = DESTIN FLAG

CMPOUT:	AND	AC3,SKPTAB(OP1) ;IF RESULT OF AND = 0 THEN NON-SKIP RTN
	SKIPE	AC3
	AOS	(P)

	SKIPGE	SLEN		;CLEANUP IF EITHER LENGTH HAS GONE NEGATIVE
	SETZM	SLEN
	SKIPGE	DLEN
	SETZM	DLEN

	MOVE	AC0,[SLEN,,RESSV] ;SAVE THE END RESULT

	BLT	AC0,RESSV+4
	GO	RSTAC		;RESTORE THE ACCUMULATORS

	RTN

; **********************************************************************
;*MOVSIM -- ROUTINE TO SIMULATE THE MOVE STRING INSTRUCTIONS
; **********************************************************************

MOVSIM:	GO	SVAC		;SAVE ACCUMULATORS

	LDB	OP1,E0OP	;COPY OF CURRENT OPCODE

	MOVE	AC0,[ORIGSV,,AC] ;RETRIEVE INITIAL AC BLOCK
	BLT	AC0,AC+4

	HLLZ	AC6,AC		;SEPERATE THE FLAGS AND LENGTH
	HRRZ	AC,AC

	SKIPN	OFFSET		;DON'T OFFSET DESTIN STRING IF PFTST
	HRRI	DP,SIMDES	;PUT SIMULATED DESTIN STRING ELSEWHERE

	SKIPE	DLEN		;IF DESTIN LEN = 0 THEN SIMPLE RETURN
	JRST	MOVS1A		;NO

	SKIPN	SLEN		;IS THE SOURCE LENGTH 0 TOO?
	JRST	SETSKP		;YES - DO A SKIP RETURN
	JRST	MOVOUT		;NO

MOVS1A:	CAIN	OP1,015		;IS INSTRUCTION MOVST?
	JRST	MOVSTS		;YES - JUMP TO THAT CODE

	CAIN	OP1,014		;IS INSTRUCTION MOVSO?
	JRST	MOVSOS		;YES - JUMP TO THAT CODE

	SETZB	AC2,AC5		;SET BYTE OFFSET AND OFFSET MASK TO ZERO

	CAMN	SLEN,DLEN	;ARE THE STRING LENGTHS EQUAL?
	JRST	MOVS3		;YES - DO THE MOVE

	CAIE	OP1,017		;NO - MOVSRJ INSTRUCTION?
	JRST	MOVS3		;NO - DO THE MOVE

	MOVE	AC2,SLEN	;FIND DIFFERENCE BETWEEN STRING LENGTHS
	SUB	AC2,DLEN

	SKIPG	AC2		;SKIP IF DESTINATION SHORTER
	JRST	MOVS2		;SOURCE SHORTER - PUT FILLER IN DESTIN

MOVS1:	ILDB	AC7,SP		;THROW AWAY A SOURCE BYTE
	SOJ	SLEN,
	SOJN	AC2,MOVS1	;WHEN DIFFERENCE IS FILLED IN,

	JRST	MOVS3		;DO REST OF MOVE
	
MOVS2:	MOVE	AC7,E0+1	;GET THE FILLER

MOVS2A:	IDPB	AC7,DP		;PUT FILLER IN DESTINATION
	SOJ	DLEN,		;DECREMENT DESTIN LENGTH
	AOJN	AC2,MOVS2A	;WHEN DIFFERENCE IS FILLED IN,

	JRST	MOVS3		;DO REST OF MOVE

MOVSOS:	HRROI	AC2,-1		;AC2 IS OFFSET COMPARE WORD
	LDB	AC5,[300600,,DP] ;GET # BITS IN DESTINATION BYTE
	LSH	AC2,(AC5)	;AC2 SHOWS BITS THAT MIGHT BE LOST
	HRREI	AC5,@E0		;AC13 CONTAINS THE BYTE OFFSET

MOVS3:	SOSGE	DLEN		;ANY DESTINATION LEFT?
	JRST	SETSKP		;NO

	SOSGE	SLEN		;ANY SOURCE LEFT
	SKIPA	AC7,E0+1	;NO - GET FILLER
	ILDB	AC7,SP		;YES - GET BYTE

	SKIPGE	SLEN		;ANY SOURCE LEFT?
	JRST	MOVS4		;NO - JUST DEPOSIT FILLER

	ADD	AC7,AC5		;ADD BYTE OFFSET TO BYTE
	TDNE	AC7,AC2		;WILL INFORMATION BE LOST?
	JRST	MOVPL		;YES - RETURN PC+1

MOVS4:	IDPB	AC7,DP		;DEPOSIT BYTE IN DESTINATION
	JRST	MOVS3		;DO THE NEXT ONE!

MOVSTS:	SOJL	SLEN,MOVST1	;ANY SOURCE LEFT?

	JUMPE	DLEN,MOVST1	;JUMP IF DESTINATION EXHAUSTED

	ILDB	AC7,SP		;GET SOURCE BYTE
	ROT	AC7,-1		;SIGN BIT SAYS WHETHER ODD OR EVEN
	SKIPGE	AC7
	SKIPA	AC7,E1(AC7)	;GET TRANSLATION TABLE ENTRY RIGHT
	MOVS	AC7,E1(AC7)	;GET TRANSLATION TABLE ENTRY LEFT

	TRNE	AC7,400000	;IS THE S FLAG SET?
	TLO	AC6,200000	;YES - TURN ON THE N FLAG

	LDB	AC4,[POINT 2,AC7,20] ;GET THE SIGN CONTROL
	XCT	[JFCL			  ;0 - NO ACTION
		 JRST  MOVST3		  ;1 - ABORT INSRUCTION
		 TLZ   AC6,100000	  ;2 - CLEAR M FLAG
		 TLO   AC6,100000](AC4)   ;3 - SET M FLAG

	TRNE	AC7,400000	;NOTE THE START FLAG
	TLOA	AC6,400000	;START SIGNIFICANCE
	JUMPGE	AC6,MOVSTS	;DON'T STORE - TRY NEXT BYTE

	ANDI	AC7,77777	;CLEAR LEFT HALF AND FLAGS
	IDPB	AC7,DP		;DEPOSIT BYTE IN DESTINATION
	SOJA	DLEN,MOVSTS	;GET NEXT BYTE

MOVST1:	AOSN	SLEN		;SOURCE GONE?
	AOS	(P)		;YES - SETUP SKIP RETURN

	MOVE	AC7,E0+1	;GET THE FILLER BYTE
MOVST2:	SOJL	DLEN,MOVST3	;JUMP WHEN DESTINATION FINISHED
	IDPB	AC7,DP		;DEPOSIT IT IN THE DESTINATION STRING
	JRST	MOVST2		;DESTINATION LEFT - CONTINUE

MOVST3:	DPB	SLEN,[3300,,SLEN] ;DEPOSIT REMAINING SOURCE LENGTH
	JRST	MOVOUT

SETSKP:	CAIE	OP1,017		;MOVSRJ INSTRUCTION?
	JRST	SKP1		;NO

	AOS	(P)		;YES - IT ALWAYS SKIPS
	JRST	MOVOUT

SKP1:	SKIPG	SLEN		;IS THERE UNUSED SOURCE BYTES?
	AOS	(P)		;NO - SKIP RETURN
	SKIPA

MOVPL:	ADDI	DLEN,1		;ADJUST DESTIN LENGTH

MOVOUT:	SKIPGE	SLEN		;RESET ANY NEG LENGTHS TO 0
	SETZM	SLEN
	SKIPGE	DLEN
	SETZM	DLEN

	SKIPE	TRANFG		;MOVST INSTRUCTION?
	OR	SLEN,AC6	;YES - OR THE TRANSLATE FLAGS WITH SLEN

	MOVE	AC0,[SLEN,,RESSV] ;SAVE THE FINAL RESULT
	BLT	AC0,RESSV+4

	GO	RSTAC		;RESTORE ACCUMULATORS
	RTN

; **********************************************************************
;*CDBSIM -- ROUTINE TO SIMULATE THE CVTDBO AND CVTDBT INSTRUCTIONS
; **********************************************************************

CDBSIM:	GO	SVAC		;SAVE ACCUMULATORS

	LDB	OP1,E0OP	;COPY OF CURRENT OPCODE

	MOVE	AC0,[ORIGSV,,AC] ;RETRIEVE INITIAL AC BLOCK
	BLT	AC0,AC+4

	MOVE	AC6,SLEN
	TLZ	AC6,777000	;AC6/STRING LENGTH WITHOUT FLAGS
	AND	SLEN,[777000,,0] ;SLEN NOW HAS ONLY THE FLAGS

	CAIE	OP1,010		;CVTDBO INSTRUCTION?
	JRST	CDBS1		;NO - TRANSLATE INSTRUCTION

	HRREI	AC5,@E0		;GET THE BYTE OFFSET
	TLZ	DBL,(1B0)	;CLEAR THE LOW ORDER SIGN BIT
	TLON	SLEN,400000	;TEST AND SET THE SIGNIFICANCE FLAG
	SETZB	DBH,DBL		;CLEAR HIGH AND LOW ORDER DATA

CDBS1:	SOJL	AC6,CDBDON	;JUMP IF ALL BYTES PROCESSED

	ILDB	AC7,SP		;GET A SOURCE BYTE
	CAIE	OP1,011		;CVTDBO INSTRUCTION?
	JRST	CDBLEG		;YES - GO SEE IF LEGAL DIGIT

	ROT	AC7,-1		;CVTDBT - ISOLATE ODD,EVEN BIT
	SKIPGE	AC7
	SKIPA	AC7,E1(AC7)	;GET TRANSLATION TABLE ENTRY RIGHT
	MOVS	AC7,E1(AC7)	;GET TRANSLATION TABLE ENTRY LEFT

	TRNE	AC7,400000	;IS S FLAG SET IN TABLE ENTRY?
	TLO	SLEN,200000	;YES - SET THE N FLAG

	LDB	AC4,[POINT 2,AC7,20] ;GET THE SIGN CONTROL
	XCT	[JFCL			  ;0 - NO ACTION
		 JRST  CDBOUT		  ;1 - ABORT INSRUCTION
		 TLZ   SLEN,100000	  ;2 - CLEAR M FLAG
		 TLO   SLEN,100000](AC4)  ;3 - SET M FLAG

	TRNN	AC7,400000	;NOTE THE SIGNIFICANCE FLAG
	JUMPGE	SLEN,CDBS1	;DON'T STORE - GET NEXT BYTE

	TLON	SLEN,400000	;TEST AND SET SIGNIFICANCE
	SETZB	DBL,DBH		;CLEAR HIGH AND LOW BINARY DATA

	ANDI	AC7,17		;DISCARD THE HIGH BITS OF TRANS TABLE ENTRY
	SKIPA

CDBLEG:	ADD	AC7,AC5		;ADD OFFSET IF CVTDBO INSTRUCTION
	JUMPL	AC7,CDBOUT	;TERMINATE INSTR IF BYTE NEGATIVE

	CAIL	AC7,^D10	;TERMINATE INSTR IF BYTE > DECIMAL 9
	JRST	CDBOUT

	LSH	DBL,1
	LSHC	DBH,1		;MULTIPLY BY 2
	LSH	DBL,-1
	DMOVEM	DBH,TEMP	;SAVE THE DOUBLE WORD RESULT

	LSH	DBL,1
	LSHC	DBH,2		;MULTIPLY BY 4
	LSH	DBL,-1

	ADD	AC7,TEMP+1	;ADD THE PARTIAL PRODUCT
	ADD	DBL,AC7
	ADD	DBH,TEMP

	TLZE	DBL,400000	;IS THERE A CARRY OUT OF LOW WORD
	AOJ	DBH,		;YES - INCREMENT THE HIGH WORD

	JRST	CDBS1		;GET THE NEXT BYTE

CDBDON:	TLNE	SLEN,100000	;IS THE M FLAG SET?
	DMOVN	DBH,DBH		;YES - NEGATE THE DOUBLE WORD RESULT
	AOSA	(P)		;PROVIDE FOR A SKIP RETURN

CDBOUT:	IOR	SLEN,AC6
	TLZ	DBL,(1B0)	;CLEAR COPY OF SIGN BIT

	TLNE	DBH,(1B0)	;TEST THE SIGN OF THE RESULT
	TLO	DBL,(1B0)	;IT'S NEGATIVE - SET COPY OF SIGN TO 1

	CAIE	OP1,011		;OFFSET INSTRUCTION?
	JRST	CDBRET		;YES - RETURN

	TLNN	SLEN,400000	;CVTDBT - IS S FLAG SET?
	SETZB	DBL,DBH		;NO - SET THE ANSWER TO ZERO

CDBRET:	MOVE	AC0,[SLEN,,RESSV] ;STORE THE RESULTS

	BLT	AC0,RESSV+4
	GO	RSTAC		;RESTORE ACCUMULATORS

	RTN

; **********************************************************************
;*CBDSIM -- ROUTINE TO SIMULATE THE CVTBDX INSTRUCTIONS
;
;	IN A MACHINE WITH MICROCODE 202 OR EARLIER OR GREATER THAN 230,
;	THE "N" AND "M" FLAGS ARE SET UP FIRST AND MAY THEREFORE BE
;	AFFECTED BY AN INSTRUCTION THAT IS ABORTED BECAUSE THE BINARY
;	INTERGER IS TOO LARGE.
; **********************************************************************

CBDSIM:	GO	SVAC		;SAVE ACCUMULATORS

	SETZM	OVERR#		;OVERFLOW ERROR FLAG

	LDB	OP1,E0OP	;COPY OF CURRENT OPCODE

	MOVE	AC0,[ORIGSV,,AC] ;RETRIEVE INITIAL AC BLOCK
	BLT	AC0,AC+4

	SKIPN	OFFSET		;DON'T OFFSET STRING IF PFTST
	HRRI	DP,SIMDES	;PUT SIMULATOR RESULT ELSEWHERE

	HRREI	AC0,@E0		;GET BYTE OFFSET
	MOVEM	OFS#

	LDB	AC2,[POINT 9,DLEN,35] ;AC2 HAS DESTIN STRING LENGTH
	TLZ	BDL,(1B0)	;CLEAR THE LOW ORDER SIGN BIT
	CAIN	BDH,0		;IS THE NUMBER = 0?
	CAIE	BDL,0
	TLO	DLEN,200000	;NO - SET THE N (NON-ZERO) FLAG

	JUMPGE	BDH,CBDS1	;JUMP IF THE NUMBER IS POSITIVE

	DMOVN	BDH,BDH		;MAKE THE NUMBER POSITIVE
	TLO	DLEN,100000	;BUT REMEMBER THAT IT WAS NEGATIVE

	TLNE	BDH,(1B0)	;NEGATIVE?
	TLO	BDL,(1B0)	;YES - SET THE LOW ORDER SIGN

CBDS1:	JUMPE	AC2,CBDOVF	;ZERO LENGTH MEANS OVERFLOW

	CAIL	BDH,0		;2**70?
	JRST	CBDOST		;NO

	CAIGE	AC2,^D22	;YES - IS THE LENGTH LONG ENOUGH?
	JRST	CBDOVF		;NO

	TLNN	DLEN,400000	;SIGNIFICANCE FLAG SET?
	JRST	CBDS3		;NO - NO STORAGE OF LEADING 0'S

	MOVE	AC3,E0+1	;YES - GET THE FILLER
CBDS2:	CAIN	AC2,^D22
	JRST	CBDS3

	IDPB	AC3,DP		;STORE THE FILLER IN DESTINATION STRING
	SOJA	AC2,CBDS2	;GO BACK FOR MORE

CBDS3:	MOVEI	AC2,^D21	
	MOVEI	AC3,1

	CAIN	OP1,012		;CVTBDO INSTRUCTION?
	ADD	AC3,OFS		;ADD OFFSET TO THE NUMBER

	CAIN	OP1,013		;CVTBDT INSTRUCTION?
	HRRZ	AC3,E1(AC3)	;GET REPRESENTATION OF "1"

	IDPB	AC3,DP		;STORE FIRST DIGIT OF ANSWER
	DMOVE	BDH,[EXP 47121545107,104130000000]

CBDOST:	DMOVE	AC3,BDH
	GO	DECPNT		;OUTPUT DIGITS

	SKIPE	OVERR		;IS THERE AN OVERFLOW ERROR?
	JRST	CBDOVF		;YES

CBDEX:	SETZB	BDH,BDL		;RETURN WITH DATA 0
	AND	DLEN,[777000,,] ;LEAVE LENGTH 0

	MOVE	AC0,[AC,,RESSV]
	BLT	AC0,RESSV+4

	GO	RSTAC
	AOS	(P)
	RTN

DECPNT:	GO	DECPN3		;STORE DIGITS

	TLNN	DLEN,100000	;MINUS FLAG SET?
	JRST	DECPNR

	CAIN	OP1,012
	JRST	DECPNR

	HRLZ	AC2,E1(AC6)
	DPB	AC2,DP

DECPNR:	RTN

DECPN3:	MOVE	AC5,AC4		;SAVE LOW ORDER DIVIDEND

	IDIVI	AC3,12		;DIVIDE HIGH PART BY 10
	DIVI	AC4,12		;AND LOW PART

	SOJGE	AC2,DECP4	;IF LENGTH GOES NEG -- OVERFLOW

	SETOM	OVERR		;INDICATE OVERFLOW ERROR
	JRST	DECPN2		;INITIATE A RETURN

DECP4:	PUSH	P,AC5
	JUMPN	AC4,DECPN1
	JUMPN	AC3,DECPN1
	JUMPGE	DLEN,DECLDN	;SFL=0 MEANS DON'T STORE LEADING 0'S
	MOVE	AC5,E0+1

DECFIL:	JUMPE	AC2,DECLDN	;NO MORE ROOM
	IDPB	AC5,DP		;STORE A LEADING 0
	SOJA	AC2,DECFIL	;GO BACK FOR MORE

DECLDN:	CAIA			;RETRIEVE DIGITS IN CORRECT ORDER

DECPN1:	GO	DECPN3		;GET NEXT DIGIT
	POP	P,AC5
	MOVE	AC6,AC5		;SAVE DIGIT

	CAIN	OP1,012		;TRANSLATE?
	ADD	AC5,OFS		;NO -OFFSET

	CAIN	OP1,013
	HRRZ	AC5,E1(AC5)

	IDPB	AC5,DP		;STORE
DECPN2:	RTN

CBDOVF:	SETOM	OVERR		;INDICATE OVERFLOW
	MOVEM	DLEN,OVDLEN#	;SAVE MODIFIED FLAGS

	MOVE	AC0,[ORIGSV,,RESSV] ;RETURN WITH ORIGINAL AC'S INTACT
	BLT	AC0,RESSV+4

	HRRI	AC0,SIMDES
	HRRM	AC0,RESSV+4

	SKIPN	MIC202		;UCODE 202 TO 227 ?
	MOVEM	DLEN,RESSV+3	;NO, SAVE MODIFIED FLAGS THEN

	SETZM	SIMDES
	MOVE	AC0,[SIMDES,,SIMDES+1]
	BLT	AC0,SIMDES+^D30

	GO	RSTAC
	RTN

; **********************************************************************
;*EDTSIM -- ROUTINE TO SIMULATE THE EDIT INSTRUCTION
; **********************************************************************
	
EDTSIM:	GO	SVAC		;SAVE ACCUMULATORS

	MOVE	AC0,[ORIGSV,,AC] ;RETRIEVE INITIAL AC BLOCK
	BLT	AC0,AC+4

	SKIPN	OFFSET#		;OFFSET THE DESTINATION STRING?
	HRRI	DP,SIMDES	;MOVE DESTINATION STRING ELSEWHERE

EDTS2:	LDB	AC7,PATBN	;GET PB# FROM AC
	LDB	AC3,PATBL(AC7)	;GET THE PATTERN BYTE
	MOVE	AC2,AC3		;MAKE A COPY OF IT
	LSH	AC2,-6		;GET READY TO DECODE THE HIGH 3 BITS
	JRST	@PPTAB(AC2)	;JUMP TO THE SPECIFIED PP CODE

; **************************************************
;EOPER -- PP IS 000-005. DECODE AND JUMP AGAIN
; **************************************************

EOPER:	CAILE	AC3,5		;LEGAL OPERATOR?
	JRST	ENOP		;NO
	JRST	@PPTAB1(AC3)	;JUMP TO SPECIFIED PP CODE

; **************************************************
;EMESSG -- PP IS 1XX (MESSAG)
; **************************************************

EMESSG:	JUMPGE	PADDR,ESEL	;USE FILLER IF SIGNIFICANCE NOT SET
	MOVE	AC3,E0-77(AC3) 	;SIGNIFICANCE SET - GET MSG CHAR.
	IDPB	AC3,DP		;DEPOSIT IT IN DESTINATION STRING
	JRST	ENOP

; **************************************************
;ENOP -- UPDATES THE PATTERN ADDRESS
; **************************************************

ENOP:	GO	INCPBN		;ROUTINE TO UPDATE PATTERN ADDRESS
	JRST	EDTS2		;GO GET THE NEXT BYTE

; **************************************************
;ESKPM	-- PP IS 5XX (SKPM)
; **************************************************

ESKPM:	TLNN	PADDR,100000	;IS THE M FLAG SET?
	JRST	ENOP		;NO - DON'T SKIP LENGTH
	JRST	ESKPA		;YES - DO THE SKIP

; **************************************************
;ESKPN	-- PP IS 6XX (SKPN)
; **************************************************

ESKPN:	TLNN	PADDR,200000	;IS THE N FLAG SET?
	JRST	ENOP		;NO - DON'T SKIP LENGTH
	JRST	ESKPA		;YES - DO THE SKIP

; **************************************************
;ESKPA	-- PP IS 7XX (SKPA)
; **************************************************

ESKPA:	ANDI	AC3,77
	ADDI	AC7,1(AC3)	;ADD THE SKIP DISTANCE
	GO	INCPBN
	JRST	EDTS2

; **************************************************
;ESTOP	-- PP IS 000 (STOP)
; **************************************************

ESTOP:	AOS	(P)		;SETUP FOR A SKIP RETURN

EABORT:	GO	INCPBN		;PUSH THE PATTERN BYTE NO. PAST THE STOP

	MOVE	AC0,[PADDR,,RESSV] ;SAVE THE RESULT AC'S
	BLT	AC0,RESSV+4

	GO	RSTAC		;RESTORE ACCUMULATORS
	RTN

; **************************************************
;ESELCT	-- PP IS 011 (SELECT)
; **************************************************

ESELCT:	ILDB	AC3,SP		;GET SOURCE BYTE
	ROT	AC3,-1		;MOVE ODD,EVEN BIT TO BIT 0
	SKIPGE	AC3
	SKIPA	AC3,E1(AC3)	;LOAD TRANS TABLE ENTRY, RIGHT HALF
	MOVS	AC3,E1(AC3)	;LOAD TRANS TABLE ENTRY, LEFT HALF

	TRNE	AC3,400000	;IS THE SIGNIFICANCE FLAG SET?
	TLO	PADDR,200000	;YES - SET THE N FLAG

	LDB	AC2,[POINT 2,AC3,20]	    ;GET THE CONTROL BITS
	XCT	[JFCL			    ;0 - NO ACTION
		 JRST  EABORT		    ;1 - ABORT INSRUCTION
		 TLZ   PADDR,100000	    ;2 - CLEAR M FLAG
		 TLO   PADDR,100000](AC2)   ;3 - SET M FLAG

	JUMPL	PADDR,ESEL2	;STORE THE BYTE

	TRNE	AC3,400000	;IS THE SIGNIFICANCE FLAG SET?
	JRST	ESEL1		;YES - STORE THE BYTE

ESEL:	MOVE	AC3,E0+1	;NO - GET THE FILLER CHARACTER
	JUMPE	AC3,ENOP	;DON'T STORE IT IF = 0
	JRST	ESEL2

ESEL1:	TLO	PADDR,400000	;SET THE SIGNIFICANCE FLAG
	GO	STFLOT		;MARK AND TRY FLOAT

ESEL2:	ANDI	AC3,77777	;MASK OFF THE CONTROL BITS
	IDPB	AC3,DP		;DEPOSIT THE BYTE IN DESTIN STRING
	JRST	ENOP		;GO FOR NEXT BYTE

; **************************************************
;ESIGST	-- PP IS 002 (SIGST)
; **************************************************

ESIGST:	TLON	PADDR,400000	;TEST AND SET SIGNIFICANCE FLAG
	GO	STFLOT		;STORE FLOAT CHARACTER
	JRST	ENOP

; **************************************************
;EFLDSP	-- PP IS 003 (FLDSEP)
; **************************************************

EFLDSP:	TLZ	PADDR,700000	;CLEAR ALL FLAGS
	JRST	ENOP

; **************************************************
;EEXCHD	-- -- IS 004 (EXCHMD)
; **************************************************

EEXCHD:	EXCH	DP,(MA)		;PUT THE MARK POINTER INTO DP1
	JRST	ENOP

; **************************************************
;INCPBN -- EDIT SUPPORT ROUTINE TO UPDATE THE PATTERN ADDRESS
; **************************************************

INCPBN:	ADDI	AC7,1		;INCREMENT PB#
	MOVE	AC3,AC7		;MAKE A COPY OF IT
	LSH	AC3,-2		;GET THE WORD ADDRESS
	ADDI	PADDR,(AC3)	;UPDATE SP
	ANDI	AC7,3
	DPB	AC7,PATBN
	RTN

; **************************************************
;STFLOT -- EDIT SUPPORT ROUTINE THAT STORES THE FLOAT CHAR IN THE
;	DESTINATION STRING
; **************************************************

STFLOT:	MOVEM	DP,(MA)		;MA <== DP
	MOVE	AC2,E0+2	;GET THE FLOAT CHARACTER

	SKIPE	AC2		;DON'T STORE THE FLOAT CHARACTER IF ZERO
	IDPB	AC2,DP		;STORE IT
	RTN

SUBTTL	INSTRUCTION RESULT COMPARATOR AND ERROR REPORTER ROUTINES

; **********************************************************************
;*INSTRUCTION RESULT COMPARATOR AND ERROR REPORTER ROUTINES
;*	-- GENERAL INFORMATION
;*
;*	EACH OF THE FIVE ERROR COMPARATOR AND COMPANION ERROR REPORTER
;*	ROUTINES IS RESPONSIBLE FOR DETECTING ERROR AND PRINTING THE
;*	ERROR INFORMATION SPECIFIC TO THE INSTRUCTION UNDER TEST.
;*
;*	ALL ROUTINES ARE ENTERED WITH THE SAME PARAMETERS. THESE ARE:
;*		1. ORIGINAL AC BLOCK IN ORIGSV-ORIGSV+4
;*		2. ACTUAL RESULT BLOCK IN AC'S 10-14
;*		3. SIMULATED RESULT BLOCK IN RESSV-RESSV+4
;*		4. INSTRUCTION SKIP INFORMATION IN SKPWD1 AND SKPWD2
;*		5. SIMULATED DESTIN STRING IN SIMDES
;*		6. ACTUAL DESTIN STRING IN DESTIN
;*
;*	GENERAL HELPER ROUTINES UTILIZED BY THE ERROR REPORTERS:
;*
;*		1. PNTINS -- PRINTS THE CURRENT INSTRUCTION NAME
;*		   NO ENTRY PARAMETER SETUP, RTN+1 ALWAYS
;*		2. PNTCAS -- PRINTS THE CURRENT CASE NUMBER
;*		   ENTRY WITH CASE TABLE ADDRESS IN AC1, RTN+1 ALWAYS
;*		3. PNTSTR -- PRINTS STRING OF BYTES
;*		   ENTRY WITH STRING LENGTH IN AC1, STRING BYTE POINTER
;*		   IN AC2, RTN+1 ALWAYS
;*		4. PNTACB -- PRINTS ORIGINAL,SIMULATED, ACTUAL AC BLOCKS
;*		   NO ENTRY PARAMETER SETUP, RTN+1 ALWAYS
;*		5. PNTSKP -- PRINTS INCORRECT SKIP MESSAGE
;*		   NO ENTRY PARAMETER SETUP, RTN+1 ALWAYS
;*
;*	CMPCOM -- ROUTINE WHICH COMPARES THE SIMULATED AND ACTUAL RESULTS
;*		OF THE EXTEND COMPARE INSTRUCION.
;*	MOVCOM -- ROUTINE WHICH COMPARES THE ACTUAL AND SIMULATED RESULTS
;*		OF THE EXTEND MOVXX INSTRUCTIONS.
;*	CDBCOM -- ROUTINE WHICH COMPARES THE SIMULATED AND ACTUAL RESULTS
;*		OF THE CVTDBX INSTRUCTIONS.
;*	CBDCOM -- ROUTINE WHICH COMPARES THE ACTUAL AND SIMULATED RESULTS
;*		OF THE CVTBDX INSTRUCTIONS.
;*	EDTCOM -- ROUTINE WHICH COMPARES THE ACTUAL AND SIMULATED RESULTS
;*		OF THE EDIT INSTRUCTION AND PRINTS ERROR INFORMATION.
; **********************************************************************

; **********************************************************************
;*CMPCOM -- ROUTINE WHICH COMPARES THE SIMULATED AND ACTUAL RESULTS
;*	OF THE EXTEND COMPARE INSTRUCION.
; **********************************************************************

CMPCOM:	MOVE	AC0,SKPWD1	;SEE IF INSTR RETURNED CORRECTLY
	CAMN	AC0,SKPWD2
	JRST	CMPC1		;IT DID - CONTINUE

	SETOM	INCSKP		;SET THE INCORRECT RETURN FLAG
	JRST	CMPFAIL		;AND GO PRINT THE ERROR INFORMATION

CMPC1:	CAME	SLEN,RESSV	;CHECK THE CONTENTS OF THE SIM AC BLOCK
	JRST	CMPFAIL		;AGAINST THE REAL AC BLOCK (AC-AC+4)

	CAME	SP,RESSV+1
	JRST	CMPFAIL

	CAME	AC12,RESSV+2
	JRST	CMPFAIL

	CAME	DLEN,RESSV+3
	JRST	CMPFAIL

	CAME	DP,RESSV+4
	JRST	CMPFAIL

	AOS	(P)		;OK, SKIP RETURN
CMPFAIL:RTN

CMPPNT:	PUT	AC0
	PUT	AC1
	PUT	AC2

	GO	PNTINS		;PRINT THE CURRENT INSTRUCTION

	MOVEI	AC1,CMPCAS	;AC1 = CASE TABLE ADDRESS
	GO	PNTCAS		;PRINT THE CURRENT CASE

	PMSG	<^SOURCE STRING: >
	MOVE	AC1,ORIGSV	;COPY OF SOURCE STRING LENGTH
	MOVE	AC2,ORIGSV+1	;COPY OF SOURCE BYTE POINTER
	GO	PNTSTR		;PRINT SOURCE STRING

	PMSG	<^DESTIN STRING: >
	MOVE	AC1,ORIGSV+3	;COPY OF DESTINATION STRING LENGTH
	MOVE	AC2,ORIGSV+4	;COPY OF DESTINATION BYTE POINTER
	GO	PNTSTR		;PRINT DESTINATION STRING

	PMSG	<^E0+1: >
	MOVE	E0+1
	PNTOCS			;PRINT E0+1

	PMSG	<^E0+2: >
	MOVE	E0+2
	PNTOCS			;PRINT E0+2
	PCRL

	GO	PNTACB		;PRINT THE AC BLOCKS

	SKIPE	INCSKP		;DID INSTR RETURN OK?
	GO	PNTSKP		;NO - PRINT AN ERROR MESSAGE
	SETZM	INCSKP		;RESET INCORRECT RETURN FLAG

CMPRET:	GET	AC2
	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*MOVCOM -- ROUTINE WHICH COMPARES THE ACTUAL AND SIMULATED RESULTS
;*	OF THE EXTEND MOVXX INSTRUCTIONS.
; **********************************************************************

MOVCOM:	PUT	AC0

	MOVE	AC0,SKPWD1	;SEE IF INSTRUCTION RETURNED CORRECTLY
	CAMN	AC0,SKPWD2
	JRST	MOVC1		;IT DID - GO CHECK THE ACS

	SETOM	INCSKP		;IT DIDN'T - SET THE INCORRECT SKIP FLAG
	JRST	MOVFAIL

MOVC1:	CAME	SLEN,RESSV	;CHECK THE FINAL ACS WITH THE SIMULATED RESULT
	JRST	MOVFAIL

	CAME	SP,RESSV+1
	JRST	MOVFAIL

	CAME	AC12,RESSV+2
	JRST	MOVFAIL

	CAME	DLEN,RESSV+3
	JRST	MOVFAIL

	GO	COMSTR		;COMPARE SIMULATED AND ACTUAL STRINGS
	JRST	MOVFAIL		;ERROR RETURN

	MOVE	AC0,DP
	ADD	AC0,[SIMDES-DESTIN] ;OFFSET DP BY DIFF IN STRING LOCS
	CAME	AC0,RESSV+4
	JRST	MOVFAIL

	AOS	-1(P)
MOVFAIL:GET	AC0
	RTN

MOVPNT:	PUT	AC0
	PUT	AC1
	PUT	AC2

	GO	PNTINS		;PRINT THE CURRENT INSTRUCTION

	MOVEI	AC1,MOVCAS	;AC1 = CASE TABLE ADDRESS
	GO	PNTCAS		;PRINT THE CURRENT CASE #

	PMSG	<^SOURCE STRING:>
	SETZM	AC1
	LDB	AC1,[POINT 9,ORIGSV,35] ;COPY OF SOURCE STRING LENGTH
	MOVE	AC2,ORIGSV+1	;COPY OF SOURCE BYTE POINTER
	GO	PNTSTR

	PMSG	<^CORRECT DESTINATION STRING:>
	MOVE	AC1,ORIGSV+3	;COPY OF DESTINATION STRING LENGTH
	SUB	AC1,RESSV+3	;CALCULATE HOW MUCH WAS MOVED
	MOVE	AC2,ORIGSV+4	;COPY OF DESTINATION STRING BYTE POINTER
	HRRI	AC2,SIMDES	;MAKE LOCATION = SIMULATED DEST STRING
	GO	PNTSTR

	PMSG	<^ACTUAL DESTINATION STRING:>
	MOVE	AC1,ORIGSV+3	;COPY OF DESTINATION STRING LENGTH
	SUB	AC1,AC13	;CALULATE HOW MUCH WAS MOVED
	MOVE	AC2,ORIGSV+4	;COPY OF DESTINATION STRING BYTE POINTER
	GO	PNTSTR

	PMSG	<^E0+1: >
	MOVE	E0+1
	PNTOCS			;PRINT E0+1
	PCRL

	MOVE	AC0,[DESTIN-SIMDES]
	ADDM	AC0,RESSV+4
	GO	PNTACB		;PRINT THE AC BLOCKS

	SKIPE	TRANFG
	GO	PNTRAN		;IF MOVST PRINT TRANSLATION TABLE

	SKIPE	INCSKP		;INCORRECT RETURN TAKEN?
	GO	PNTSKP		;YES - PRINT SKIP MESSAGE
	SETZM	INCSKP		;RESET INCORRECT SKIP WORD

MOVRET:	GET	AC2
	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*CDBCOM -- ROUTINE WHICH COMPARES THE SIMULATED AND ACTUAL RESULTS
;*	OF THE CVTDBX INSTRUCTIONS.
; **********************************************************************

CDBCOM:	MOVE	AC0,SKPWD1	;SEE IF INSTRUCTION RETURNED CORRECTLY
	CAMN	AC0,SKPWD2
	JRST	CDBC1		;IT DID - GO CHECK THE ACS

	SETOM	INCSKP		;IT DIDN'T - SET THE INCORRECT SKIP FLAG
	JRST	CDBFAIL

CDBC1:	CAME	SLEN,RESSV	;CHECK THE FINAL ACS WITH THE SIMULATED RESULT
	JRST	CDBFAIL		;NOT EQUAL - JUMP TO THE ERROR PRINTER

	CAME	SP,RESSV+1
	JRST	CDBFAIL

	CAME	AC12,RESSV+2
	JRST	CDBFAIL

	CAME	DBH,RESSV+3
	JRST	CDBFAIL

	CAME	DBL,RESSV+4
	JRST	CDBFAIL

	GO	COMSTR		;COMPARE DESTINATION STRINGS
	JRST	CDBFAIL

	AOS	(P)
CDBFAIL:RTN

CDBPNT:	PUT	AC0
	PUT	AC1
	PUT	AC2

	MOVEI	AC1,CDBCAS	;AC1 = CASE TABLE ADDRESS
	GO	PNTCAS		;GO PRINT THE CURRENT CASE #

	PMSG	<^SOURCE STRING: >
	SETZM	AC1
	LDB	AC1,[POINT 9,ORIGSV,35] ;COPY OF SOURCE STRING LENGTH
	MOVE	AC2,ORIGSV+1	;COPY OF SOURCE BYTE POINTER
	GO	PNTSTR

	GO	PNTACB		;GO PRINT THE AC BLOCKS

	SKIPE	TRANFG		;IF CVTDBT THEN PRINT TRANSLATION TABLE
	GO	PNTRAN

	SKIPE	INCSKP		;INCORRECT RETURN TAKEN?
	GO	PNTSKP		;YES - PRINT SKIP MESSAGE
	SETZM	INCSKP		;RESET THE SKIP WORD

CDBRT1:	GET	AC2
	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*CBDCOM -- ROUTINE WHICH COMPARES THE ACTUAL AND SIMULATED RESULTS
;*	OF THE CVTBDX INSTRUCTIONS.
;
;	IN A MACHINE WITH MICROCODE 202 OR EARLIER OR GREATER THAN 230,
;	THE "N" AND "M" FLAGS ARE SET UP FIRST AND MAY THEREFORE BE
;	AFFECTED BY AN INSTRUCTION THAT IS ABORTED BECAUSE THE BINARY
;	INTERGER IS TOO LARGE.
; **********************************************************************

CBDCOM:	PUT	AC0

	MOVE	AC0,SKPWD1	;SEE IF INSTRUCTION RETURNED CORRECTLY
	CAMN	AC0,SKPWD2
	JRST	CBDC1		;IT DID - CONTINUE

	SETOM	INCSKP
	JRST	CBDFAIL

CBDC1:	CAME	BDH,RESSV	;CHECK THE SIMULATED AC'S WITH
	JRST	CBDFAIL		;THE FINAL RESULT

	CAME	BDL,RESSV+1
	JRST	CBDFAIL

	CAME	AC12,RESSV+2
	JRST	CBDFAIL

	CAME	DLEN,RESSV+3
	JRST	CBDC2

CBDC3:	MOVE	AC0,DP
	ADD	AC0,[SIMDES-DESTIN]
	CAME	AC0,RESSV+4
	JRST	CBDFAIL

	AOS	-1(P)
CBDFAIL:GET	AC0
	RTN

CBDC2:	SKIPN	USER		;EXEC MODE ?
	JRST	CBDFAIL		;YES, A REAL ERROR THEN

	SKIPN	OVERR		;USER MODE, OVERFLOW CASE ?
	JRST	CBDFAIL		;NO, A REAL ERROR

	MOVE	OVDLEN		;YES, CAN'T TELL ON UCODE
	CAME	RESSV+3		; SO USE EITHER DLEN
	JRST	CBDFAIL		;DOES'T COMPARE TO EITHER
	JRST	CBDC3		;OK

CBDPNT:	PUT	AC0
	PUT	AC1
	PUT	AC2

	GO	PNTINS		;PRINT THE INSTRUCTION IN ERROR

	MOVEI	AC1,CBDCAS
	GO	PNTCAS		;PRINT THE CASE IN ERROR

	GO	PNTACB		;GO PRINT THE AC BLOCKS

	PMSG	<^SIMULATED DESTINATION STRING:>
	SETZM	AC1
	LDB	AC1,[POINT 9,ORIGSV+3,35] 
	MOVE	AC2,ORIGSV+4	;COPY OF SIMULATED DESTIN BYTE POINTER
	HRRI	AC2,SIMDES
	GO	PNTSTR

	PMSG	<^ACTUAL DESTINATION STRING:>
	SETZM	AC1
	LDB	AC1,[POINT 9,ORIGSV+3,35] ;COPY OF DESTIN STRING LENGTH
	MOVE	AC2,ORIGSV+4	;COPY OF DESTIN BYTE POINTER
	GO	PNTSTR

	SKIPE	INCSKP		;INCORRECT SKIP TAKEN ?
	GO	PNTSKP		;YES - PRINT SKIP MESSAGE
	SETZM	INCSKP

CBDRT1:	GET	AC2
	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*EDTCOM -- ROUTINE WHICH COMPARES THE ACTUAL AND SIMULATED RESULTS
;*	OF THE EDIT INSTRUCTION AND PRINTS ERROR INFORMATION.
;*	THE BYTE TYPE UNDER TEST IS ACCESSED USING "BYTYPE" AS AN INDEX.
;*	MAXIMUM STRING LENGTHS ARE USED FOR PRINTING STRINGS SINCE THE
;*	EDIT INSTRUCTION HAS NO SPECIFICATION OF STRING LENGTHS. 
; **********************************************************************

EDTCOM:	PUT	AC0

	MOVE	AC0,SKPWD1	;SEE IF INSTRUCTION SKIPPED CORRECTLY
	CAMN	AC0,SKPWD2
	JRST	EDTC1		;IT DID - CONTINUE

	SETOM	INCSKP
	JRST	EDTFAIL

EDTC1:	CAME	PADDR,RESSV	;CHECK THE SIMULATED AC'S AGAINST THE 
	JRST	EDTFAIL		;THE ACTUAL AC'S

	CAME	SP,RESSV+1
	JRST	EDTFAIL

	CAME	AC12,RESSV+2
	JRST	EDTFAIL

	CAME	MA,RESSV+3
	JRST	EDTFAIL

	GO	COMSTR		;COMPARE SIMULATED AND ACTUAL STRINGS
	JRST	EDTFAIL		;ERROR RETURN

	MOVE	AC0,DP
	SKIPN	OFFSET
	ADD	AC0,[SIMDES-DESTIN]

	CAME	AC0,RESSV+4
	JRST	EDTFAIL

	AOS	-1(P)
EDTFAIL:GET	AC0
	RTN

EDTPNT:	PUT	AC0
	PUT	AC1
	PUT	AC2

	PMSG	<^PATTERN BYTE TYPE UNDER TEST: >
	MOVE	AC4,BYTYPE	;GET BYTE TYPE TABLE INDEX
	MOVE	AC0,BYTAB(AC4)	;SIXBIT BYTE NAME TO AC0
	PNTSIX			;PRINT IT

	MOVEI	AC1,EDTCAS
	GO	PNTCAS		;PRINT THE CASE NUMBER

	SKIPE	OFFSET
	JRST	EDTP1A

	MOVE	AC0,[DESTIN-SIMDES] ;GET DIFFERENCE IN STRING LOCATIONS
	ADDM	AC0,RESSV+4

EDTP1A:	GO	PNTACB		;PRINT THE AC BLOCKS

	CAIE	AC4,^D9		;IF SELECT IS BYTE TYPE 9 PRINT SRC STRING
	JRST	EDTP1

	PMSG	<^SOURCE STRING:>
	MOVEI	AC1,^D20	;SOURCE STRING MAX LENGTH
	MOVE	AC2,ORIGSV+1	;COPY OF STRING BYTE POINTER
	GO	PNTSTR

EDTP1:	SKIPE	OFFSET		;EXCHMD BYTE TYPE?
	JRST	EDTP2		;YES - DON'T PRINT DESTINATION STRINGS

	PMSG	<^CORRECT DESTINATION STRING:>
	MOVEI	AC1,^D64	;MAX DESTIN AND SIMDES STRING LENGTH
	MOVE	AC2,ORIGSV+4
	HRRI	AC2,SIMDES
	GO	PNTSTR

	PMSG	<^ACTUAL DESTINATION STRING:>
	MOVEI	AC1,^D64
	MOVE	AC2,ORIGSV+4
	GO	PNTSTR

EDTP2:	CAIE	AC4,^D9		;PRINT E0+1 IF BYTE TYPE IS SELECT
	JRST	EDTP2A

	PMSG	<^E0+1:>
	MOVE	AC0,E0+1
	PNTOCS

EDTP2A:	CAIE	AC4,2		;PRINT E0+2 IF SIGST OR SELECT
	CAIN	AC4,^D9
	SKIPA
	JRST	EDTP4

	PMSG	<^E0+2:>
	MOVE	AC0,E0+2	;GET THE FLOAT CHARACTER
	PNTOCS

EDTP4:	CAIN	AC4,^D9		;PRINT TRANSLATION TABLE IF BYTE TYPE IS SELECT
	GO	PNTRAN

	SKIPE	INCSKP		;INCORRECT RETURN TAKEN?
	GO	PNTSKP		;YES - PRINT THE INCORRECT SKIP MSG.
	SETZM	INCSKP		;RESET THE INCORRECT SKIP WORD

EDTRT1:	GET	AC2
	GET	AC1
	GET	AC0
	RTN

SUBTTL MUUO AND PAGE FAIL HANDLERS

; **********************************************************************
;*MUUOHS - MUUO HANDLER INITIALIZATION
;*	CODE TO SETUP MUUO HANDLER IN EXEC MODE
; **********************************************************************

MUUOHS:	SKIPE	USER		;USER MODE?
	JRST	TSMUUO		;YES - SETUP FOR TIMESHARE TRAPPING

	MOVEI	MUUOH		;GET ADDRESS OF MUUO HANDLER
	MOVEM	430		;SETUP ADDRESS IN USER PROCESS TABLE

	MOVE	[430,431]	;SETUP UPT WORDS 430-437
	BLT	437
	RTN

; **************************************************
;CODE TO SETUP MUUO HANDLER FOR TOPS-20
; **************************************************

TSMUUO:	SKIPN	MONTYP		;RUNNING UNDER TOPS-20?
	JRST	MUUO10		;NO - EXECUTE TOPS-10 CODE

	RESET			;CLEAR THE SOFTWARE INTERRUPT SYSTEM

	MOVEI	AC1,.FHSLF	;PROCESS HANDLE FOR THIS JOB
	MOVE	AC2,[LEVTAB,,CHNTAB] ;SETUP SOFTWARE INTERRUPT TABLES
	SIR

	MOVSI	2,(1B^D15)	;SET UP TO INTERCEPT ILLEGAL INSTR
	AIC			;TO INTERRUPT ILLEGAL INSTRUCTIONS

	EIR			;ENABLE THE INTERRUPT SYSTEM
	RTN

; **************************************************
;CODE TO SETUP MUUO HANDLER FOR TOPS-10
; **************************************************

MUUO10:	MOVEI	AC1,UUOBLK	;SET .JBINT TO ADDRESS OF CONTROL BLOCK
	MOVEM	AC1,.JBINT
	RTN

; **********************************************************************
;*MUUOH - THE ACTUAL MUUO HANDLERS (EXEC AND USER MODE)
; **********************************************************************

MUUOH:	PUT	AC0		;SAVE AC0

	AOSE	GOTRAP		;WAS A TRAP EXPECTED?
	JRST	MUUOHX		;NO, FATAL ERROR

	SKIPE	USER		;USER MODE?
	JRST	MUUOHU		;YES - GO TO USER CODE

	GET	AC0		;RESTORE AC0
	JRSTF	@425		;JUMP USING UPT PC ADDRESS

MUUOHU:	SKIPN	MONTYP		;TOPS-20 MONITOR?
	JRST	MUUOH1		;NO - EXECUTE TOPS-10 CODE

	AOS	MUOPC		;SETUP INTERRUPT RETURN
	GET	AC0		;RESTORE AC0
	DEBRK			;EXECUTE THE DISMISS INTERRUPT JSYS

MUUOH1:	AOS	UUOBLK+2	;UUOBLK+2 HAS LAST USER PS
	GET	AC0		;RESTORE AC0

	PUT	UUOBLK+2	;SETUP RETURN JUMP
	SETZM	UUOBLK+2	;THIS MUST BE 0 TO WORK AGAIN 
	RTN

; **************************************************
;*MUUOHX - UNEXPECTED MUUO ERROR REPORTING
; **************************************************
								SALL
T=	SIXBTZ	<MUUO OPERATION>
								LALL
MUUOHX:	SKIPE	USER
	JRST	MUUOHY

	MOVE	AC1,424		;GET BAD MUUO
	MOVE	AC2,425		;GET BAD MMUO PC

	ERROR1	(13,AC1,AC2,
^CORRECT=MUUO
^ACTUAL=MUUO PC,
UNEXPECTED MUUO OCCURED)
	FATAL

MUUOHY:	MOVE	AC1,MUOPC	;GET PC OF BAD MUUO
	SKIPN	MONTYP
	MOVE	AC1,UUOBLK

	ERROR1	(13,AC1,0,
^CORRECT=MUUO PC,
UNEXPECTED MUUO OCCURED)
	FATAL

; **********************************************************************
;*LUUOH - LUUO HANDLER
; **********************************************************************

LUUOH:	PUT	AC0		;SAVE AC0

	AOSE	GOTRAP		;WAS AN LUUO EXPECTED?
	JRST	LUUOHX		;NO, FATAL ERROR

	GET	AC0		;RESTORE AC0
	RTN

; **************************************************
;*LUUOHX - UNEXPECTED LUUO ERROR REPORTING
; **************************************************
								SALL
T=	SIXBTZ	<LUUO OPERATION>
								LALL
LUUOHX:	MOVE	SVLUUO		;RESTORE SUBROU. PKG. TRAP ROUTINE SETUP
	MOVEM	41

	MOVE	AC1,40		;GET BAD LUUO
	MOVE	AC2,-1(P)	;GET BAD LUUO PC

	ERROR1	(13,AC1,AC2,
^CORRECT=LUUO
^ACTUAL=LUUO PC,
UNEXPECTED LUUO OCCURED)
	FATAL

; **********************************************************************
;*PFHAND -- PAGE FAIL HANDLER
;*
;*	IN THIS ROUTINE THE CURRENT VALUE OF THE EXTEND INSTR AC BLOCK
;*	IS COMPARED WITH THE CORRECT RESULT WHICH IS STORED IN MEMORY.
;*
;*	ALSO, THE PAGE FAIL WORD AND PAGE FAIL PC ARE COMPARED AGAINST
;*	THE CORRECT VALUES. IF A DISCREPANCY EXISTS THE ROUTINE TAKES
;*	AN ERROR RETURN THROUGH "PFHEPC" BACK TO THE MAIN TEST.
;*
;*	ON ENTRY, AC4 CONTAINS THE ADDRESS OF THE CORRECT AC BLOCK STORED
;*	IN MEMORY, INSTR CONTAINS THE INDEX TO THE SIXBIT INSTRUCTION
;*	NAME TABLE.
; **********************************************************************

PFHAND:	AOSE	PFTRAP		;INDICATE THAT PF OCCURED
	JRST	PFFAIL		;THIS IS SECOND PAGE FAILURE

	HRRZ	AC7,LPFWPC	;ACTUAL PAGE FAIL PC
	MOVE	AC6,FAILOC	;CORRECT PF PC WORD
	CAME	AC6,AC7		;CORRECT?
	JRST	PFFAIL		;NO

	MOVE	AC7,(AC4)	;GET THE CORRECT AC CONTENTS
	SKIPE	TRANFG		;TRANSLATE INSTR?
	OR	AC7,BIT0	;YES - CORRECT RESULT HAS SFL SET

	CAME	AC7,AC10	;CORRECT?
	JRST	PFFAIL		;NO

	MOVE	AC7,1(AC4)	;GET THE CORRECT AC CONTENTS
	CAME	AC7,AC11	;CORRECT?
	JRST	PFFAIL		;NO

	MOVE	AC7,2(AC4)	;GET THE CORRECT AC+2 CONTENTS
	CAME	AC7,AC12	;CORRECT?
	JRST	PFFAIL		;NO

	MOVE	AC7,3(AC4)	;GET THE CORRECT AC CONTENTS
	CAME	AC7,AC13	;CORRECT?
	JRST	PFFAIL		;NO

	MOVE	AC7,4(AC4)	;GET THE CORRECT AC CONTENTS
	CAME	AC7,AC14	;CORRECT?
	JRST	PFFAIL		;NO

; **************************************************
;SET UP THE PAGE TABLE FOR CONTINUE
; **************************************************

	MOVE	AC0,[740000!75,,740000!76]
	MOVEM	AC0,200		;SETUP PAGE MAP

;D02	CONO	PAG,LTRPEN	;CAUSE NEW PAGING TO HAVE AN EFFECT
	GO	CHNGPE		;A02 ENABLE PAGING PRESERVING CACHE 

	JRSTF	@LPFWPC		;RETURN

; **************************************************
;TAKE AN ERROR RETURN THROUGH "PFHEPC" BACK TO THE MAIN TEST.
; **************************************************

PFFAIL:	JRST	@PFHEPC#

; **********************************************************************
;*PFPNT -- PAGE FAIL ERROR PRINTER
;*
;*	ON ENTRY, AC4 CONTAINS THE ADDRESS OF THE CORRECT AC BLOCK STORED
;*	IN MEMORY, INSTR CONTAINS THE INDEX TO THE SIXBIT INSTRUCTION
;*	NAME TABLE.
; **********************************************************************
									SALL
T=	SIXBTZ	<PAGE FAIL>
									LALL
PFPNT:	HRRZ	AC7,LPFWPC	;ACTUAL PAGE FAIL PC
	MOVE	AC6,FAILOC	;CORRECT PF PC WORD
	CAME	AC6,AC7		;CORRECT?
	ERROR1	(13,6,7,PAGE FAIL PC WRONG,,PFINS)

	MOVE	AC7,(AC4)	;GET THE CORRECT AC CONTENTS
	SKIPE	TRANFG		;TRANSLATE INSTR?
	OR	AC7,BIT0	;YES - CORRECT RESULT HAS SFL SET

	CAME	AC7,AC10	;CORRECT?
	ERROR1	(13,7,10,INTERMEDIATE AC INCORRECT,,PFINS)

	MOVE	AC7,1(AC4)	;GET THE CORRECT AC+1 CONTENTS
	CAME	AC7,AC11	;CORRECT?
	ERROR1	(13,7,11,INTERMEDIATE AC+1 INCORRECT,,PFINS)

	MOVE	AC7,2(AC4)	;GET THE CORRECT AC+2 CONTENTS
	CAME	AC7,AC12	;CORRECT?
	ERROR1	(13,7,12,INTERMEDIATE AC+2 INCORRECT,,PFINS)

	MOVE	AC7,3(AC4)	;GET THE CORRECT AC+3 CONTENTS
	CAME	AC7,AC13	;CORRECT?
	ERROR1	(13,7,13,INTERMEDIATE AC+3 INCORRECT,,PFINS)

	MOVE	AC7,4(AC4)	;GET THE CORRECT AC+4 CONTENTS
	CAME	AC7,AC14	;CORRECT?
	ERROR1	(13,7,14,INTERMEDIATE AC+4 INCORRECT,,PFINS)

	RTN
								XALL
SUBTTL	PROGRAM SUPPORT ROUTINES

; **********************************************************************
;*EDTSET -- ROUTINE TO SET UP THE AC BLOCK FOR THE EDIT INSTRUCTION
;*	ACCORDING TO THE PARAMETERS CONTAINED IN THE CASE TABLE. 
;*
;*	UPON ENTRY, THE RIGHT HALF OF AC7 CONTAINS THE ADDRESS OF THE
;*	CASE TABLE PARAMETER WORD.
;*
;*	RETURN IS ALWAYS +1.
; **********************************************************************

EDTSET:	MOVE	AC1,(AC7)	;RETRIEVE THE CASE PARAMETER WORD

; **************************************************
;DETERMINE THE INITIAL VALUES FOR THE S,N AND M FLAG
; **************************************************

	SETZM	PADDR
	TRNE	AC1,(SFL)	;SET THE S FLAG?
	OR	PADDR,BIT0	;YES

	TRNE	AC1,(NFL)	;SET THE N FLAG?
	OR	PADDR,BIT1	;YES

	TRNE	AC1,(MFL)	;SET THE M FLAG?
	OR	PADDR,BIT2	;YES

; **************************************************
;SET UP THE PATTERN BYTE #
; **************************************************

	MOVE	AC4,AC1		;MAKE COPY OF CASE WORD
	ANDI	AC4,PB		;ISOLATE THE PB#
	LSH	AC4,PBSH	;SHIFT INTO RIGHT-MOST PART OF AC
	DPB	AC4,PATBN	;LOAD PB# INTO PADDR
	HRRI	PADDR,PATTBL	;LOAD BYTE PATTERN TABLE ADDRESS

; **************************************************
;SETUP THE SOURCE AND DESTINATION BYTE POINTERS
; **************************************************

	TLNE	AC1,(S44)	;FULL WORD SOURCE BYTES?
	MOVE	SP,[POINT 36,SOURCE]

	TLNN	AC1,(S44)
	MOVE	SP,[POINT 5,SOURCE] ;SETUP SOURCE POINTER

	TLNE	AC1,(D44)	;FULL WORD DESTIN BYTE SIZE?
	MOVE	DP,[POINT 36,DESTIN]

	TLNN	AC1,(D44)
	MOVE	DP,[POINT 5,DESTIN] ;SETUP DESTINATION POINTER

	SETZM	MA		;SET MARK ADDRESS TO 0

; **************************************************
;SETUP THE E0+1 AND E0+2 (FILL AND FLOAT CHARACTERS) AS FOLLOWS:
;	IF EQFILL=1 THEN E0+1= 62, E0+2= 63
;	IF LFILL =1 THEN E0+1=  0, E0+2= 63
;	IF GFILL =1 THEN E0+1= 62, E0+2=  0
;	IF NONE OF THE ABOVE ARE SPECIFIED BOTH WORDS WILL BE SET TO 0
; **************************************************

	TLNN	AC1,(EQFIL)
	JRST	EDS2

	MOVEI	AC0,62
	MOVEM	AC0,E0+1

	MOVEI	AC0,63
	MOVEM	AC0,E0+2

	JRST	EDSRTN

EDS2:	TLNN	AC1,(LFILL)
	JRST	EDS3

	MOVEI	AC0,0
	MOVEM	AC0,E0+1

	MOVEI	AC0,63
	MOVEM	AC0,E0+2

	JRST	EDSRTN

EDS3:	TLNN	AC1,(GFILL)
	JRST	EDS4

	MOVEI	AC0,62
	MOVEM	AC0,E0+1

	MOVEI	AC0,0
	MOVEM	AC0,E0+2

	JRST	EDSRTN

EDS4:	SETZM	E0+1
	SETZM	E0+2

; **************************************************
;SETUP SOURCE STRING AND TRANSLATE TABLE IF BYTE TYPE IS SELECT
; **************************************************

	MOVE	AC0,BYTYPE	;CURRENT BYTE TYPE
	CAIE	AC0,^D9		;IS IT SELECT?
	JRST	EDSRTN		;NO

	MOVE	AC4,SP		;COPY OF SOURCE BYTE POINTER
	MOVEI	AC5,-^D20	;SETUP 20 BYTES
	MOVEI	AC0,1		;PATTERN STARTS WITH 1 AND INCREMENTS

EDS5:	SOSG	AC5
	JRST	EDS6

	IDPB	AC0,AC4		;PUT BYTE IN THE STRING
	ADDI	AC0,1		;INCREMENT THE PATTERN
	JRST	EDS5

; **************************************************
;SET THE CODE BITS IN THE TRANSLATION TABLE
; **************************************************

EDS6:	SETZM	AC0		;TEMP LOC FOR CONTROL BITS
	TRNE	AC1,(C1)		;SETUP THE SECOND HALFWORD
	OR	BIT18

	TRNE	AC1,(C2)
	OR	BIT19

	TRNE	AC1,(C3)
	OR	BIT20

	TRNE	AC1,(C4)		;SETUP THE THIRD HALFWORD
	OR	BIT0

	TRNE	AC1,(C5)
	OR	BIT1

	TRNE	AC1,(C6)
	OR	BIT2

	GO	SETRAN		;YES - SET UP THE TRANSLATION TABLE

EDSRTN:	MOVE	AC0,[004000,,E1]	;SETUP E0 WORD
	MOVEM	AC0,E0
	RTN

; **********************************************************************
;*PFINS -- ROUTINE TO PRINT INSTRUCTION NAME
;*	ENTRY WITH SCRIPT TABLE INDEX IN INSTR
; **********************************************************************

PFINS:	PUT	AC0
	PUT	AC1

	MOVE	AC1,INSTR	;GET OPCODE INDEX TO TABLE
	PMSG	<^INSTRUCTION: >
	MOVE	AC0,SCRIPT(AC1)	;GET SIXBIT NAME
	PNTSIX			;PRINT IT

	PCRL
	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*CDBTN -- USED IN CVTDBT PF TEST
; **********************************************************************

CDBTN:	SETZM	E1
	RTN

; **********************************************************************
;*CBDTRN -- ROUTINE TO SET UP THE TRANSLATE TABLE FOR THE CVTBDX INSTR
; **********************************************************************

CBDTRN:	MOVE	AC0,[CBDTR,,E1]
	BLT	AC0,E1+^D9
	RTN
	
; **********************************************************************
;*COMAC -- ROUTINE USED IN PAGE FAIL TESTING TO COMPARE THE
;*	FINAL AC BLOCK WITH THAT OF THE SIMULATOR
; **********************************************************************

COMAC:	CAME	AC,RESSV	;COMPARE THE AC BLOCK,PRINT ON ERROR
	JRST	COMFAIL

	CAME	AC+1,RESSV+1
	JRST	COMFAIL

	CAME	AC+2,RESSV+2
	JRST	COMFAIL

	CAME	AC+3,RESSV+3
	JRST	COMFAIL

	CAME	AC+4,RESSV+4
	JRST	COMFAIL

	AOS	(P)
COMFAIL:RTN

COMPNT:	GO	PFINS		;PRINT THE INSTRUCTION IN ERROR

	GO	PNTACB		;PRINT THE AC BLOCKS

	RTN

; **********************************************************************
;*CHKTRN -- ROUTINE TO CHECK THE OPCODE UNDER TEST AND SET TRANSFG
;*	IF IT IS A TRANSLATE INSTRUCTION.
;*
;*	TAKE OPCODE IN AC0, RTN +1 ALWAYS
; **********************************************************************

CHKTRN:	SETZM	TRANFG

	CAIN	AC0,015		;MOVST INSTRUCTION?
	JRST	SETFG		;YES - SET TRANFG

	CAIN	AC0,011		;CVTDBT INSTRUCTION?
	JRST	SETFG

	CAIN	AC0,013		;CVTBDT INSTRUCTION?
SETFG:	SETOM	TRANFG		;SET THE FLAG
	RTN

; **********************************************************************
;*PAGSET -- ROUTINE TO CLEAR PAGE TABLE,
;*	SET UP RELOCATION DATA IN THE TABLE,
;*	SET PAGING AND TRAP ENABLE,
;*	AND LOAD THE USER BASE REGISTER
; **********************************************************************

;A02 fix for MCA20 with 1 quad enabled
	KLPMSK==760000		;PRESERVE CURRENT STATE OF CACHE
	PAGBIT==20000		;PAGE ENABLE BIT

CHNGPE:	MOVEM	AC0,SAVZ#	;TAKE NO CHANCES, SAVE AC
	CONI	PAG,AC0		;READ CURRENT STATE OF CACHE
	ANDI	AC0,KLPMSK	;TO BUILD NEW CONO
	IORI	AC0,PAGBIT	;SET PAGE ENABLE
	HLL	AC0,[CONO PAG,LTRPEN]	;OP CODE PORTION ONLY
	XCT	AC0		;NOW DO IT
	MOVE	AC0,SAVZ	;THIS PROBABLY ISN'T NECESSARY
	RTN			;GO BACK WHERE YOU CAME FROM

;END A02 PATCH

PAGSET:	SETZM	200		;CLEAR THE PAGE TABLE
	MOVE	AC0,[200,,201]
	BLT	AC0,417

	MOVSI	AC0,740000!75	;SET UP THE RELOCATION DATA
	MOVEM	AC0,200		;LOCATIONS 400XXX ==> LOCATIONS 75XXX

	SETOM	LEUPFW

;D02	CONO	PAG,LTRPEN	;SET TRAP AND PAGING ENABLE
	GO	CHNGPE		;A02 ENABLE PAGING PRESERVING CACHE 

	DATAO	PAG,[LLDUSB,,400000] ;LOAD THE USER BASE REGISTER
	RTN

; **********************************************************************
;*PFACB -- ROUTINE TO SETUP PAGE FAIL AC BLOCK
;*	ENTRY WITH AC3 CONTAINING ADDRESS OF BLOCK IN MEMORY
; **********************************************************************

PFACB:	MOVE	AC0,(AC3)
	MOVEM	AC

	MOVE	AC0,1(AC3)
	MOVEM	AC+1

	MOVE	AC0,2(AC3)
	MOVEM	AC+2

	MOVE	AC0,3(AC3)
	MOVEM	AC+3

	MOVE	AC0,4(AC3)
	MOVEM	AC+4

	SETZM	FILLF		;CLEAR FILLER FAILURE FLAG

	MOVE	AC0,5(AC3)	;GET INDICATOR OF WHERE E0 WORD WILL GO
	SKIPE	AC0		;AC0 = 0 MEANS THIS CASE NOT FILLER FAIL
	SETOM	FILLF#		;PAGE FAIL SETUP TO OCCUR FOR FILLER
	RTN

; **********************************************************************
;*SVAC,RSTAC- ROUTINES TO SAVE AND RESTORE AC'S 0-16
; **********************************************************************

SVAC:	MOVEM	0,AC0SV#	;SAVE AC'S
	MOVEM	1,AC1SV#
	MOVEM	2,AC2SV#
	MOVEM	3,AC3SV#
	MOVEM	4,AC4SV#
	MOVEM	5,AC5SV#
	MOVEM	6,AC6SV#
	MOVEM	7,AC7SV#
	MOVEM	10,AC10SV#
	MOVEM	11,AC11SV#
	MOVEM	12,AC12SV#
	MOVEM	13,AC13SV#
	MOVEM	14,AC14SV#
	MOVEM	15,AC15SV#
	MOVEM	16,AC16SV#
	RTN

RSTAC:	MOVE	0,AC0SV		;RESTORE AC'S
	MOVE	1,AC1SV
	MOVE	2,AC2SV
	MOVE	3,AC3SV
	MOVE	4,AC4SV
	MOVE	5,AC5SV
	MOVE	6,AC6SV
	MOVE	7,AC7SV
	MOVE	10,AC10SV
	MOVE	11,AC11SV
	MOVE	12,AC12SV
	MOVE	13,AC13SV
	MOVE	14,AC14SV
	MOVE	15,AC15SV
	MOVE	16,AC16SV
	RTN

; **********************************************************************
;*CLRSTR -- ROUTINE WHICH CLEARS THE SOURCE, DESTIN, AND SIMDES BLOCKS
; **********************************************************************

CLRSTR:	PUT	AC0

	SETZM	SOURCE
	MOVE	AC0,[SOURCE,,SOURCE+1]
	BLT	AC0,SOURCE+^D19

	SETZM	DESTIN
	MOVE	AC0,[DESTIN,,DESTIN+1]
	BLT	AC0,DESTIN+^D63

	SETZM	SIMDES
	MOVE	AC0,[SIMDES,,SIMDES+1]
	BLT	AC0,SIMDES+^D63

	GET	AC0
	RTN

; **********************************************************************
;*COMSTR -- ROUTINE TO COMPARE SIMULATED AND ACTUAL DESTINATION STRINGS
; **********************************************************************

COMSTR:	PUT	AC0
	PUT	AC1

	MOVEI	AC1,^D63	;LOOP COUNTER AND WORD INDEX

COMS1:	MOVE	AC0,DESTIN(AC1)	;GET DESTINATION WORD
	CAME	AC0,SIMDES(AC1)
	JRST	COMRT		;ERROR RETURN

	SOJG	AC1,COMS1

	AOS	-2(P)		;CORRECT RETURN
COMRT:	GET	AC1
	GET	AC0
	RTN

SUBTTL	PROGRAM PRINT ROUTINES

; **********************************************************************
;*PNTACB -- ROUTINE TO PRINT THE ORIGINAL, CORRECT AND ACTUAL AC BLOCKS
; **********************************************************************

PNTACB:	PUT	AC0
	PUT	AC1

	PNTMSG	[ASCIZ/
AC BLOCKS:	       ---- FINAL ----
   ORIGINAL	   CORRECT	   ACTUAL
/]
	HRLZI	AC1,-5		;AC1/- BLOCK LENGTH,,0

PNTBLK:	MOVE	ORIGSV(AC1)
	PNTHW
	PNTCI	11

	MOVE	RESSV(AC1)
	PNTHW
	PNTCI	11

	MOVE	10(AC1)
	PNTHW
	PCRL

	AOBJN	AC1,PNTBLK

	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*PNTINS -- ROUTINE TO PRINT THE CURRENT INSTRUCTION IN ENGLISH
; **********************************************************************

PNTINS:	PMSG	<^INSTRUCTION: >
	LDB	AC1,E0OP	;GET THE CURRENT OPCODE
	MOVE	AC0,SCRIPT(AC1)	;PRINT THE INSTRUCTION NAME
	PNTSXF
	RTN

; **********************************************************************
;*PNTSKP -- ROUTINE WHICH PRINTS INCORRECT INSTRUCTION RETURN MESSAGE
; **********************************************************************

PNTSKP:	PUT	AC0

	PMSG	<^INSTRUCTION MADE AN INCORRECT >

	MOVE	AC0,[SIXBIT /SKIP/]
	SKIPN	SKPWD1
	MOVE	AC0,[SIXBIT /N-SKIP/]
	PNTSXF

	PMSG	< RETURN^>

	GET	AC0
	RTN

; **********************************************************************
;*PNTSTR -- ROUTINE WHICH PRINTS STRINGS IN ROWS OF 5 BYTES EACH
;*	ON ENTRY AC1 CONTAINS THE LENGTH OF THE STRING TO BE PRINTED
;*	AND AC2 CONTAINS THE BYTE POINTER TO BE USED.
; **********************************************************************

PNTSTR:	PUT	AC0
	PUT	AC1
	PUT	AC4
	PCRL

	AND	AC1,[77777,,777777] ;MASK OFF FLAGS

PNTS1:	MOVEI	AC4,5		;BYTES/ROW COUNTER

PNTS2:	SOSGE	AC1		;MORE BYTES TO PRINT?
	JRST	PNTSRT		;NO - RETURN

	ILDB	AC0,AC2		;YES - BYTE TO AC0
	PNTOCS			;PRINT BYTE IN OCTAL
	PNTCI	11		;TAB

	SOJN	AC4,PNTS2	;JUMP IF MORE BYTES TO GO IN THIS ROW

	PCRL			;GO TO NEXT ROW
	JRST	PNTS1		;RELOAD BYTES/ROW COUNTER

PNTSRT:	PCRL
	GET	AC4
	GET	AC1
	GET	AC0
	RTN

; **********************************************************************
;*PNTCAS -- ROUTINE WHICH PRINTS CASE CURRENT CASE #. (AC1)=  CASE TABLE ADDR)
; **********************************************************************

PNTCAS:	PUT	AC0

	PMSG	<^CASE # >
	HRRZ	AC0,AC7		;GET ADDRESS OF CASE
	ADDI	AC0,1		;ADJUST
	SUB	AC0,AC1		;SUBTRACT THE TABLE ADDRESS
	PNTDEC			;PRINT CASE #
	PCRL

	GET	AC0
	RTN

; **********************************************************************
;*RANLEN -- ROUTINE WHICH RETURNS STRING LENGTHS SEQUENTIALLY FROM 2 - 20 (10)
; **********************************************************************

RANLEN:	PUT	AC0

	MOVE	AC0,RLEN	;GET LAST LENGTH USED
	CAIN	AC0,^D20	;RLEN REACHED HIGH LIMIT?
	MOVEI	AC0,1		;YES - RESET IT

	ADDI	AC0,1		;GENERATE NEXT STRING LENGTH
	MOVEM	RLEN		;STORE IT FOR NEXT TIME

	GET	AC0
	RTN

; **********************************************************************
;*PNTRAN -- ROUTINE TO PRINT THE CONTENTS OF A TRANSLATION TABLE
;*	LOCATED AT E1 FOR LENGTH OF 20
; **********************************************************************

PNTRAN:	PUT	AC0
	PUT	AC1

	HRLZI	AC1,-^D10	;AC1/-# FULL WORDS,,0
	HRRI	AC1,E1		;AC1/-# FULL WORDS,,TRANS TABLE ADDRESS

	PMSG	<^TRANSLATION TABLE:>

	PMSG	<^CODE]FUNCTION]CODE]FUNCTION^>

PNTRN:	MOVS	AC0,(AC1)	;GET WORD FROM TABLE
	LSH	AC0,-^D15	;SHIFT CODE INTO POSITION
	ANDI	AC0,7		;SAVE ONLY THE CODE
	PNTOCS
	PNTCI	11

	MOVS	AC0,(AC1)
	ANDI	AC0,77777
	PNTOCS

	PMSG	<]]>		;PRINT TWO TABS

	MOVE	AC0,(AC1)
	LSH	AC0,-^D15
	ANDI	AC0,7
	PNTOCS
	PNTCI	11

	MOVE	AC0,(AC1)
	ANDI	AC0,77777
	PNTOCS
	PCRL

	AOBJN	AC1,PNTRN

	GET	AC1
	GET	AC0
	RTN

;END OF FILE
    